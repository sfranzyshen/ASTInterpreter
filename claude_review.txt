Looking at your bug report and the code, I can see the issue clearly. The problem is in the JavaScript export code (CompactAST.js) where it writes empty strings for operator nodes instead of extracting the actual operator values. Let me trace through the issue and provide a fix.
The Problem
In CompactAST.js, the writeNode() method has this logic:
javascript// Write value if present (node.value takes precedence over node.operator/node.op)
if (node.value !== undefined) {
    offset = this.writeValue(view, offset, node.value);
} else if (node.operator !== undefined) {
    // Write operator as a regular string value for C++ compatibility
    offset = this.writeValue(view, offset, node.operator);
} else if (node.op && node.op.value !== undefined) {
    // Write op.value for BinaryOpNode and UnaryOpNode for C++ compatibility
    offset = this.writeValue(view, offset, node.op.value);
} else if (node.type === 'UnaryOpNode' || node.type === 'BinaryOpNode') {
    // Fallback: Force empty string for operator nodes if no operator found
    // This ensures HAS_VALUE flag consistency
    offset = this.writeValue(view, offset, "");
}
The issue is that this code assumes the operator will be in node.value, node.operator, or node.op.value. However, based on your bug report, it seems the actual AST structure might be different, causing it to fall through to the last case which writes an empty string.
The Solution
Here's the fix for CompactAST.js. We need to update both the collectNodes() method to properly identify where operators are stored, and the writeNode() method to extract them correctly:


// In CompactAST.js, update the collectNodes method to better handle operators:

collectNodes(node, index = 0) {
    if (!node) return index;
    
    // Add to node list
    this.nodes[index] = node;
    this.nodeMap.set(node, index);
    
    // Add strings to string table
    if (node.value && typeof node.value === 'string') {
        this.addString(node.value);
    }
    
    // Handle various operator field locations
    if (node.operator && typeof node.operator === 'string') {
        this.addString(node.operator);
    }
    
    // Handle op field for BinaryOpNode and UnaryOpNode
    if (node.op) {
        if (typeof node.op === 'string') {
            // Direct string operator
            this.addString(node.op);
        } else if (typeof node.op === 'object' && node.op.value && typeof node.op.value === 'string') {
            // Operator wrapped in object
            this.addString(node.op.value);
        }
    }
    
    if (node.name && typeof node.name === 'string') {
        this.addString(node.name);
    }
    
    let nextIndex = index + 1;
    
    // Process children
    if (node.children) {
        for (const child of node.children) {
            nextIndex = this.collectNodes(child, nextIndex);
        }
    }
    
    // Process named children based on node type
    const namedChildren = this.getNamedChildren(node);
    for (const childName of namedChildren) {
        if (node[childName]) {
            if (Array.isArray(node[childName])) {
                // Special handling for VarDeclNode declarations array
                if (node.type === 'VarDeclNode' && childName === 'declarations') {
                    for (const decl of node[childName]) {
                        // Process declarator and initializer directly (skip declaration wrapper)
                        if (decl.declarator) {
                            nextIndex = this.collectNodes(decl.declarator, nextIndex);
                        }
                        if (decl.initializer) {
                            nextIndex = this.collectNodes(decl.initializer, nextIndex);
                        }
                    }
                } else {
                    for (const child of node[childName]) {
                        nextIndex = this.collectNodes(child, nextIndex);
                    }
                }
            } else {
                nextIndex = this.collectNodes(node[childName], nextIndex);
            }
        }
    }
    
    return nextIndex;
}

// Update the writeNode method to properly extract operators:

writeNode(view, offset, node, nodeIndex) {
    const startOffset = offset;
    
    // Write node type
    if (!node || !node.type) {
        throw new Error(`Invalid node during AST export: ${JSON.stringify(node)}`);
    }
    const nodeType = this.nodeTypeMap[node.type];
    if (nodeType === undefined) {
        throw new Error(`Unknown node type: ${node.type}`);
    }
    view.setUint8(offset, nodeType);
    offset += 1;
    
    // Calculate flags
    let flags = 0;
    if (this.getChildCount(node) > 0) flags |= 0x01; // HAS_CHILDREN
    
    // CRITICAL FIX: Ensure operator nodes always get HAS_VALUE flag and have operator
    if (node.type === 'UnaryOpNode' || node.type === 'BinaryOpNode') {
        flags |= 0x02; // HAS_VALUE - always set for operator nodes
    } else if (node.value !== undefined || node.operator !== undefined) {
        flags |= 0x02; // HAS_VALUE
    }
    
    view.setUint8(offset, flags);
    offset += 1;
    
    // Skip data size for now, will write at end
    const dataSizeOffset = offset;
    offset += 2;
    
    const dataStartOffset = offset;
    
    // CRITICAL FIX: Better operator extraction logic
    if (node.type === 'UnaryOpNode' || node.type === 'BinaryOpNode') {
        // Special handling for operator nodes - find the operator string
        let operatorString = null;
        
        // Try different possible locations for the operator
        if (node.operator && typeof node.operator === 'string') {
            operatorString = node.operator;
        } else if (node.op) {
            if (typeof node.op === 'string') {
                operatorString = node.op;
            } else if (typeof node.op === 'object' && node.op.value) {
                operatorString = node.op.value;
            }
        }
        
        // If we still don't have an operator, check common field names
        if (!operatorString) {
            // Check if there's an 'operation' field
            if (node.operation && typeof node.operation === 'string') {
                operatorString = node.operation;
            }
            // As last resort, check the value field
            else if (node.value && typeof node.value === 'string') {
                operatorString = node.value;
            }
        }
        
        if (!operatorString) {
            console.error(`WARNING: No operator found for ${node.type} node:`, node);
            operatorString = ""; // Use empty string as fallback
        }
        
        // Write the operator as a string value
        offset = this.writeValue(view, offset, operatorString);
        
    } else if (node.value !== undefined) {
        // Regular value handling for non-operator nodes
        offset = this.writeValue(view, offset, node.value);
    } else if (node.operator !== undefined) {
        // Write operator as a regular string value for other nodes
        offset = this.writeValue(view, offset, node.operator);
    }
    
    // Write children indices
    const childIndices = this.getChildIndices(node);
    for (const childIndex of childIndices) {
        view.setUint16(offset, childIndex, true);
        offset += 2;
    }
    
    // Write actual data size
    const dataSize = offset - dataStartOffset;
    view.setUint16(dataSizeOffset, dataSize, true);
    
    return offset;
}


Additional Debugging Suggestion
To help debug what structure your AST nodes actually have, you can add this diagnostic code to CompactAST.js:

// Add this debug function to CompactAST.js to understand your AST structure:

function debugOperatorNode(node) {
    if (node.type === 'UnaryOpNode' || node.type === 'BinaryOpNode') {
        console.log(`\n=== DEBUG: ${node.type} ===`);
        console.log('node.operator:', node.operator);
        console.log('node.op:', node.op);
        console.log('node.op?.value:', node.op?.value);
        console.log('node.value:', node.value);
        console.log('node.operation:', node.operation);
        console.log('Full node structure:', JSON.stringify(node, null, 2));
        console.log('========================\n');
    }
}

// Then in the writeNode method, add this call:
// Right before the operator extraction logic:
if (node.type === 'UnaryOpNode' || node.type === 'BinaryOpNode') {
    debugOperatorNode(node); // Add this line to see what the actual structure is
}


Key Points
The core issue is that the JavaScript export code needs to know exactly where to find the operator string in your AST nodes. The fix I've provided:

Improves operator detection - Checks multiple possible locations for the operator string (node.operator, node.op, node.op.value, node.operation, node.value)
Always sets HAS_VALUE flag for operator nodes to ensure C++ calls setValue()
Adds debugging capability to help you see the actual structure of your AST nodes

Next Steps

Apply the fix to your CompactAST.js file (specifically the writeNode method changes)
Run the debug code to see what structure your operator nodes actually have
Re-export your AST files using the fixed JavaScript code
Test with your C++ parser to verify operators are now loaded correctly

The key insight from your bug report is that the string table contains the correct operators, but the JavaScript export is writing empty strings instead of referencing those operators. This fix should resolve that by properly extracting the operator from wherever it's stored in your AST node structure.


