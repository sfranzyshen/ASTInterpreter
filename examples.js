const examplesFiles = [
  { "name": "AnalogReadSerial.ino", "content": "// 01.Basics AnalogReadSerial.ino\n\n// the setup routine runs once when you press reset:\nvoid setup() {\n  // initialize serial communication at 9600 bits per second:\n  Serial.begin(9600);\n}\n\n// the loop routine runs over and over again forever:\nvoid loop() {\n  // read the input on analog pin 0:\n  int sensorValue = analogRead(A0);\n  // print out the value you read:\n  Serial.println(sensorValue);\n  delay(1);\n  // delay in between reads for stability\n}\n" },
  { "name": "BareMinimum.ino", "content": "// 01.Basics BareMinimum.ino\n\nvoid setup() {\n  // put your setup code here, to run once:\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n}\n" },
  { "name": "Blink.ino", "content": "// 01.Basics Blink.ino\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  // initialize digital pin LED_BUILTIN as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n  digitalWrite(LED_BUILTIN, HIGH);\n  delay(1000);\n  digitalWrite(LED_BUILTIN, LOW);\n  delay(1000);\n}\n" },
  { "name": "DigitalReadSerial.ino", "content": "// 01.Basics DigitalReadSerial.ino\n\n// digital pin 7 has a pushbutton attached to it.\nint pushButton = 7;\n\n// the setup routine runs once when you press reset:\nvoid setup() {\n  // initialize serial communication at 9600 bits per second:\n  Serial.begin(9600);\n  // make the pushbutton's pin an input:\n  pinMode(pushButton, INPUT);\n}\n\n// the loop routine runs over and over again forever:\nvoid loop() {\n  // read the input pin:\n  int buttonState = digitalRead(pushButton);\n  // print out the state of the button:\n  Serial.println(buttonState);\n  delay(1);\n}\n" },
  { "name": "Fade.ino", "content": "// 01.Basics Fade.ino \n\nint led = 9;\nint brightness = 0;\nint fadeAmount = 5;\n\n// the setup routine runs once when you press reset:\nvoid setup() {\n  // declare pin 9 to be an output:\n  pinMode(led, OUTPUT);\n}\n\n// the loop routine runs over and over again forever:\nvoid loop() {\n  // set the brightness of pin 9:\n  analogWrite(led, brightness);\n  // change the brightness for next time through the loop:\n  brightness = brightness + fadeAmount;\n  // reverse the direction of the fading at the ends of the fade:\n  if (brightness <= 0 || brightness >= 255) {\n    fadeAmount = -fadeAmount;\n  }\n  // wait for 30 milliseconds to see the dimming effect\n  delay(30);\n}\n" },
  { "name": "ReadAnalogVoltage.ino", "content": "// 01.Basics ReadAnalogVoltage.ino\n\n// the setup routine runs once when you press reset:\nvoid setup() {\n  // initialize serial communication at 9600 bits per second:\n  Serial.begin(9600);\n}\n\n// the loop routine runs over and over again forever:\nvoid loop() {\n  // read the input on analog pin 0:\n  int sensorValue = analogRead(A0);\n  // Convert the analog reading (which goes from 0 - 1023) to a voltage (0 - 5V):\n  float voltage = sensorValue * (5.0 / 1023.0);\n  // print out the value you read:\n  Serial.println(voltage);\n}\n" },
  { "name": "BlinkWithoutDelay.ino", "content": "// 02.Digital BlinkWithoutDelay.ino\n\n\n\n// constants won't change.\nconst int ledPin = LED_BUILTIN;\n\n// Variables will change:\nint ledState = LOW;\n\n// Generally, you should use \"unsigned long\" for variables that hold time\n// The value will quickly become too large for an int to store\nunsigned long previousMillis = 0;\n\n// constants won't change:\nconst long interval = 1000;\n\nvoid setup() {\n  // set the digital pin as output:\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  // here is where you'd put code that needs to be running all the time.\n  // check to see if it's time to blink the LED;\n  unsigned long currentMillis = millis();\n\n  if (currentMillis - previousMillis >= interval) {\n    // save the last time you blinked the LED\n    previousMillis = currentMillis;\n\n    // if the LED is off turn it on and vice-versa:\n    if (ledState == LOW) {\n      ledState = HIGH;\n    } else {\n      ledState = LOW;\n    }\n\n    // set the LED with the ledState of the variable:\n    digitalWrite(ledPin, ledState);\n  }\n}\n" },
  { "name": "Button.ino", "content": "// 02.Digital Button.ino\n\n// constants won't change. They're used here to set pin numbers:\nconst int buttonPin = 2;\nconst int ledPin = 13;\n\n// variables will change:\nint buttonState = 0;\n\nvoid setup() {\n  // initialize the LED pin as an output:\n  pinMode(ledPin, OUTPUT);\n  // initialize the pushbutton pin as an input:\n  pinMode(buttonPin, INPUT);\n}\n\nvoid loop() {\n  // read the state of the pushbutton value:\n  buttonState = digitalRead(buttonPin);\n\n  // check if the pushbutton is pressed. If it is, the buttonState is HIGH:\n  if (buttonState == HIGH) {\n    // turn LED on:\n    digitalWrite(ledPin, HIGH);\n  } else {\n    // turn LED off:\n    digitalWrite(ledPin, LOW);\n  }\n}\n" },
  { "name": "Debounce.ino", "content": "// 02.Digital Debounce.ino\n\n// constants won't change. They're used here to set pin numbers:\nconst int buttonPin = 2;\nconst int ledPin = 13;\n\n// Variables will change:\nint ledState = HIGH;\nint buttonState;\nint lastButtonState = LOW;\n\n// the following variables are unsigned longs because the time, measured in\n// milliseconds, will quickly become a bigger number than can be stored in an int.\nunsigned long lastDebounceTime = 0;\nunsigned long debounceDelay = 50;\n\nvoid setup() {\n  pinMode(buttonPin, INPUT);\n  pinMode(ledPin, OUTPUT);\n  // set initial LED state\n  digitalWrite(ledPin, ledState);\n}\n\nvoid loop() {\n  // read the state of the switch into a local variable:\n  int reading = digitalRead(buttonPin);\n\n  // If the switch changed, due to noise or pressing:\n  if (reading != lastButtonState) {\n    // reset the debouncing timer\n    lastDebounceTime = millis();\n  }\n\n  if ((millis() - lastDebounceTime) > debounceDelay) {\n    // if the button state has changed:\n    if (reading != buttonState) {\n      buttonState = reading;\n\n      // only toggle the LED if the new button state is HIGH\n      if (buttonState == HIGH) {\n        ledState = !ledState;\n      }\n    }\n  }\n\n  // set the LED:\n  digitalWrite(ledPin, ledState);\n\n  // save the reading.\n  lastButtonState = reading;\n}\n" },
  { "name": "DigitalInputPullup.ino", "content": "// 02.Digital DigitalInputPullup.ino\n\nvoid setup() {\n  //start serial connection\n  Serial.begin(9600);\n  //configure pin 2 as an input and enable the internal pull-up resistor\n  pinMode(2, INPUT_PULLUP);\n  pinMode(13, OUTPUT);\n}\n\nvoid loop() {\n  //read the pushbutton value into a variable\n  int sensorVal = digitalRead(2);\n  //print out the value of the pushbutton\n  Serial.println(sensorVal);\n\n  // Keep in mind the pull-up means the pushbutton's logic is inverted.\n  // It goes\n  // HIGH when it's open, and LOW when it's pressed.\n  // Turn on pin 13 when the\n  // button's pressed, and off when it's not:\n  if (sensorVal == HIGH) {\n    digitalWrite(13, LOW);\n  } else {\n    digitalWrite(13, HIGH);\n  }\n}\n" },
  { "name": "StateChangeDetection.ino", "content": "// 02.Digital StateChangeDetection.ino\n\n// this constant won't change:\nconst int buttonPin = 2;\nconst int ledPin = 13;\n\n// Variables will change:\nint buttonPushCounter = 0;\nint buttonState = 0;\nint lastButtonState = 0;\n\nvoid setup() {\n  // initialize the button pin as a input:\n  pinMode(buttonPin, INPUT);\n  // initialize the LED as an output:\n  pinMode(ledPin, OUTPUT);\n  // initialize serial communication:\n  Serial.begin(9600);\n}\n\n\nvoid loop() {\n  // read the pushbutton input pin:\n  buttonState = digitalRead(buttonPin);\n\n  // compare the buttonState to its previous state\n  if (buttonState != lastButtonState) {\n    // if the state has changed, increment the counter\n    if (buttonState == HIGH) {\n      // if the current state is HIGH then the button went from off to on:\n      buttonPushCounter++;\n      Serial.println(\"on\");\n      Serial.print(\"number of button pushes: \");\n      Serial.println(buttonPushCounter);\n    } else {\n      // if the current state is LOW then the button went from on to off:\n      Serial.println(\"off\");\n    }\n    // Delay a little bit to avoid bouncing\n    delay(50);\n  }\n\n  // save the current state as the last state, for next time through the loop\n  lastButtonState = buttonState;\n\n  // turns on the LED every four button pushes by checking the modulo of the\n  // button push counter.\n  if (buttonPushCounter % 4 == 0) {\n    digitalWrite(ledPin, HIGH);\n  } else {\n    digitalWrite(ledPin, LOW);\n  }\n}\n" },
  { "name": "toneKeyboard.ino", "content": "// 02.Digital toneKeyboard.ino\n\n#include \"pitches.h\"\n\nconst int threshold = 10;\n\n// notes to play, corresponding to the 3 sensors:\nint notes[] = {\n  NOTE_A4, NOTE_B4, NOTE_C3\n};\n\nvoid setup() {\n}\n\nvoid loop() {\n  for (int thisSensor = 0; thisSensor < 3; thisSensor++) {\n    // get a sensor reading:\n    int sensorReading = analogRead(thisSensor);\n\n    // if the sensor is pressed hard enough:\n    if (sensorReading > threshold) {\n      // play the note corresponding to this sensor:\n      tone(8, notes[thisSensor], 20);\n    }\n  }\n}\n" },
  { "name": "toneMelody.ino", "content": "// 02.Digital toneMelody.ino\n\n#include \"pitches.h\"\n\n// notes in the melody:\nint melody[] = {\n  NOTE_C4, NOTE_G3, NOTE_G3, NOTE_A3, NOTE_G3, 0, NOTE_B3, NOTE_C4\n};\n// note durations: 4 = quarter note, 8 = eighth note, etc.:\nint noteDurations[] = {\n  4, 8, 8, 4, 4, 4, 4, 4\n};\n\nvoid setup() {\n  // iterate over the notes of the melody:\n  for (int thisNote = 0; thisNote < 8; thisNote++) {\n\n    // to calculate the note duration, take one second divided by the note type.\n    int noteDuration = 1000 / noteDurations[thisNote];\n    tone(8, melody[thisNote], noteDuration);\n\n    // to distinguish the notes, set a minimum time between them.\n    int pauseBetweenNotes = (noteDuration * 130) / 100;\n    delay(pauseBetweenNotes);\n\n    // stop the tone playing:\n    noTone(8);\n  }\n}\n\nvoid loop() {\n  // no need to repeat the melody.\n}\n" },
  { "name": "toneMultiple.ino", "content": "// 02.Digital toneMultiple.ino\n\nvoid setup() {\n}\n\nvoid loop() {\n  // turn off tone function for pin 8:\n  noTone(8);\n\n  // play a note on pin 6 for 200 ms:\n  tone(6, 440, 200);\n  delay(200);\n\n  // turn off tone function for pin 6:\n  noTone(6);\n\n  // play a note on pin 7 for 500 ms:\n  tone(7, 494, 500);\n  delay(500);\n\n  // turn off tone function for pin 7:\n  noTone(7);\n\n  // play a note on pin 8 for 300 ms:\n  tone(8, 523, 300);\n  delay(300);\n}\n" },
  { "name": "tonePitchFollower.ino", "content": "// 02.Digital tonePitchFollower.ino\n\nvoid setup() {\n  // initialize serial communications (for debugging only):\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  // read the sensor:\n  int sensorReading = analogRead(A0);\n\n  // print the sensor reading so you know its range\n  Serial.println(sensorReading);\n\n  // map the analog input range (in this case, 400 - 1000 from the photoresistor)\n  // to the output pitch range (120 - 1500Hz)\n  // change the minimum and maximum input numbers below depending on the range\n  // your sensor's giving:\n  int thisPitch = map(sensorReading, 400, 1000, 120, 1500);\n\n  // play the pitch:\n  tone(9, thisPitch, 10);\n  delay(1);\n}\n" },
  { "name": "AnalogInOutSerial.ino", "content": "// 03.Analog AnalogInOutSerial.ino\n\n// These constants won't change.\nconst int analogInPin = A0;\nconst int analogOutPin = 9;\n\nint sensorValue = 0;\nint outputValue = 0;\n\nvoid setup() {\n  // initialize serial communications at 9600 bps:\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  // read the analog in value:\n  sensorValue = analogRead(analogInPin);\n\n  // map it to the range of the analog out:\n  outputValue = map(sensorValue, 0, 1023, 0, 255);\n\n  // change the analog out value:\n  analogWrite(analogOutPin, outputValue);\n\n  // print the results to the Serial Monitor:\n  Serial.print(\"sensor = \");\n  Serial.print(sensorValue);\n  Serial.print(\"\\t output = \");\n  Serial.println(outputValue);\n\n  // wait 2 milliseconds before the next loop for the analog-to-digital\n  // converter to settle after the last reading:\n  delay(2);\n}\n" },
  { "name": "AnalogInput.ino", "content": "// 03.Analog AnalogInput.ino\n\nint sensorPin = A0;\nint ledPin = LED_BUILTIN;\nint sensorValue = 0;\n\nvoid setup() {\n  // declare the ledPin as an OUTPUT:\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  // read the value from the sensor:\n  sensorValue = analogRead(sensorPin);\n\n  // turn the ledPin on\n  digitalWrite(ledPin, HIGH);\n  // stop the program for <sensorValue> milliseconds:\n  delay(sensorValue);\n\n  // turn the ledPin off:\n  digitalWrite(ledPin, LOW);\n  // stop the program for <sensorValue> milliseconds:\n  delay(sensorValue);\n}\n" },
  { "name": "AnalogWriteMega.ino", "content": "// 03.Analog AnalogWriteMega.ino\n\n// These constants won't change. They're used to give names to the pins used:\nconst int lowestPin = 2;\nconst int highestPin = 13;\n\n\nvoid setup() {\n  // set pins 2 through 13 as outputs:\n  for (int thisPin = lowestPin; thisPin <= highestPin; thisPin++) {\n    pinMode(thisPin, OUTPUT);\n  }\n}\n\nvoid loop() {\n  // iterate over the pins:\n  for (int thisPin = lowestPin; thisPin <= highestPin; thisPin++) {\n    // fade the LED on thisPin from off to brightest:\n    for (int brightness = 0; brightness < 255; brightness++) {\n      analogWrite(thisPin, brightness);\n      delay(2);\n    }\n    // fade the LED on thisPin from brightest to off:\n    for (int brightness = 255; brightness >= 0; brightness--) {\n      analogWrite(thisPin, brightness);\n      delay(2);\n    }\n    // pause between LEDs:\n    delay(100);\n  }\n}\n" },
  { "name": "Calibration.ino", "content": "// 03.Analog Calibration.ino\n\n// These constants won't change:\nconst int sensorPin = A0;\nconst int ledPin = 9;\n\n// variables:\nint sensorValue = 0;\nint sensorMin = 1023;\nint sensorMax = 0;\n\n\nvoid setup() {\n  // turn on LED to signal the start of the calibration period:\n  pinMode(13, OUTPUT);\n  digitalWrite(13, HIGH);\n\n  // calibrate during the first five seconds\n  while (millis() < 5000) {\n    sensorValue = analogRead(sensorPin);\n\n    // record the maximum sensor value\n    if (sensorValue > sensorMax) {\n      sensorMax = sensorValue;\n    }\n\n    // record the minimum sensor value\n    if (sensorValue < sensorMin) {\n      sensorMin = sensorValue;\n    }\n  }\n\n  // signal the end of the calibration period\n  digitalWrite(13, LOW);\n}\n\nvoid loop() {\n  // read the sensor:\n  sensorValue = analogRead(sensorPin);\n\n  // in case the sensor value is outside the range seen during calibration\n  sensorValue = constrain(sensorValue, sensorMin, sensorMax);\n\n  // apply the calibration to the sensor reading\n  sensorValue = map(sensorValue, sensorMin, sensorMax, 0, 255);\n\n  // fade the LED using the calibrated value:\n  analogWrite(ledPin, sensorValue);\n}\n" },
  { "name": "Fading.ino", "content": "// 03.Analog Fading.ino\n\nint ledPin = 9;\n\nvoid setup() {\n  // nothing happens in setup\n}\n\nvoid loop() {\n  // fade in from min to max in increments of 5 points:\n  for (int fadeValue = 0; fadeValue <= 255; fadeValue += 5) {\n    // sets the value (range from 0 to 255):\n    analogWrite(ledPin, fadeValue);\n    // wait for 30 milliseconds to see the dimming effect\n    delay(30);\n  }\n\n  // fade out from max to min in increments of 5 points:\n  for (int fadeValue = 255; fadeValue >= 0; fadeValue -= 5) {\n    // sets the value (range from 0 to 255):\n    analogWrite(ledPin, fadeValue);\n    // wait for 30 milliseconds to see the dimming effect\n    delay(30);\n  }\n}\n" },
  { "name": "Smoothing.ino", "content": "// 03.Analog Smoothing.ino\n\n// Define the number of samples to keep track of.\nconst int numReadings = 10;\n\nint readings[numReadings];\nint readIndex = 0;\nint total = 0;\nint average = 0;\n\nint inputPin = A0;\n\nvoid setup() {\n  // initialize serial communication with computer:\n  Serial.begin(9600);\n  // initialize all the readings to 0:\n  for (int thisReading = 0; thisReading < numReadings; thisReading++) {\n    readings[thisReading] = 0;\n  }\n}\n\nvoid loop() {\n  // subtract the last reading:\n  total = total - readings[readIndex];\n  // read from the sensor:\n  readings[readIndex] = analogRead(inputPin);\n  // add the reading to the total:\n  total = total + readings[readIndex];\n  // advance to the next position in the array:\n  readIndex = readIndex + 1;\n  // if we're at the end of the array...\n  if (readIndex >= numReadings) {\n    // ...wrap around to the beginning:\n    readIndex = 0;\n  }\n\n  // calculate the average:\n  average = total / numReadings;\n  // send it to the computer as ASCII digits\n  Serial.println(average);\n  delay(1);\n}\n" },
  { "name": "ASCIITable.ino", "content": "// 04.Communication ASCIITable.ino\n\nvoid setup() {\n  //Initialize serial and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ;\n  }\n\n  // prints title with ending line break\n  Serial.println(\"ASCII Table ~ Character Map\");\n}\n\n// first visible ASCIIcharacter '!' is number 33:\nint thisByte = 33;\n\nvoid loop() {\n  // prints value unaltered, i.e. the raw binary version of the byte.\n  Serial.write(thisByte);\n\n  Serial.print(\", dec: \");\n  // prints value as string as an ASCII-encoded decimal (base 10).\n  Serial.print(thisByte);\n\n  Serial.print(\", hex: \");\n  // prints value as string in hexadecimal (base 16):\n  Serial.print(thisByte, HEX);\n\n  Serial.print(\", oct: \");\n  // prints value as string in octal (base 8);\n  Serial.print(thisByte, OCT);\n\n  Serial.print(\", bin: \");\n  // prints value as string in binary (base 2) also prints ending line break:\n  Serial.println(thisByte, BIN);\n\n  // if printed last visible character '~' or 126, stop:\n  if (thisByte == 126) {\n    // This loop loops forever and does nothing\n    while (true) {\n      continue;\n    }\n  }\n  // go on to the next character\n  thisByte++;\n}\n" },
  { "name": "Dimmer.ino", "content": "// 04.Communication Dimmer.ino\n\nconst int ledPin = 9;\n\nvoid setup() {\n  // initialize the serial communication:\n  Serial.begin(9600);\n  // initialize the ledPin as an output:\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  byte brightness;\n  // check if data has been sent from the computer:\n  if (Serial.available()) {\n    // read the most recent byte (which will be from 0 to 255):\n    brightness = Serial.read();\n    // set the brightness of the LED:\n    analogWrite(ledPin, brightness);\n  }\n}\n" },
  { "name": "Graph.ino", "content": "// 04.Communication Graph.ino\n\nvoid setup() {\n  // initialize the serial communication:\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  // send the value of analog input 0:\n  Serial.println(analogRead(A0));\n  // wait a bit for the analog-to-digital converter to stabilize after the last\n  // reading:\n  delay(2);\n}\n" },
  { "name": "Midi.ino", "content": "// 04.Communication Midi.ino\n\nvoid setup() {\n  // Set MIDI baud rate:\n  Serial.begin(31250);\n}\n\nvoid loop() {\n  // play notes from F#-0 (0x1E) to F#-5 (0x5A):\n  for (int note = 0x1E; note < 0x5A; note++) {\n    //Note on channel 1 (0x90), some note value (note), middle velocity (0x45):\n    noteOn(0x90, note, 0x45);\n    delay(100);\n    //Note on channel 1 (0x90), some note value (note), silent velocity (0x00):\n    noteOn(0x90, note, 0x00);\n    delay(100);\n  }\n}\n\n// plays a MIDI note. Doesn't check to see that cmd is greater than 127, or that\n// data values are less than 127:\nvoid noteOn(int cmd, int pitch, int velocity) {\n  Serial.write(cmd);\n  Serial.write(pitch);\n  Serial.write(velocity);\n}\n" },
  { "name": "MultiSerial.ino", "content": "// 04.Communication MultiSerial.ino\n\nvoid setup() {\n  // initialize both serial ports:\n  Serial.begin(9600);\n  Serial1.begin(9600);\n}\n\nvoid loop() {\n  // read from port 1, send to port 0:\n  if (Serial1.available()) {\n    int inByte = Serial1.read();\n    Serial.write(inByte);\n  }\n\n  // read from port 0, send to port 1:\n  if (Serial.available()) {\n    int inByte = Serial.read();\n    Serial1.write(inByte);\n  }\n}\n" },
  { "name": "PhysicalPixel.ino", "content": "// 04.Communication PhysicalPixel.ino\n\nconst int ledPin = 13;\nint incomingByte;\n\nvoid setup() {\n  // initialize serial communication:\n  Serial.begin(9600);\n  // initialize the LED pin as an output:\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  // see if there's incoming serial data:\n  if (Serial.available() > 0) {\n    // read the oldest byte in the serial buffer:\n    incomingByte = Serial.read();\n\n    // if it's a capital H (ASCII 72), turn on the LED:\n    if (incomingByte == 'H') {\n      digitalWrite(ledPin, HIGH);\n    }\n    // if it's an L (ASCII 76) turn off the LED:\n    if (incomingByte == 'L') {\n      digitalWrite(ledPin, LOW);\n    }\n  }\n}\n" },
  { "name": "ReadASCIIString.ino", "content": "// 04.Communication ReadASCIIString.ino\n\n// pins for the LEDs:\nconst int redPin = 3;\nconst int greenPin = 5;\nconst int bluePin = 6;\n\nvoid setup() {\n  // initialize serial:\n  Serial.begin(9600);\n  // make the pins outputs:\n  pinMode(redPin, OUTPUT);\n  pinMode(greenPin, OUTPUT);\n  pinMode(bluePin, OUTPUT);\n}\n\nvoid loop() {\n  // if there's any serial available, read it:\n  while (Serial.available() > 0) {\n\n    // look for the next valid integer in the incoming serial stream:\n    int red = Serial.parseInt();\n    // do it again:\n    int green = Serial.parseInt();\n    // do it again:\n    int blue = Serial.parseInt();\n\n    // look for the newline.\n    if (Serial.read() == '\\n') {\n      // constrain the values to 0 - 255 and invert\n      red = 255 - constrain(red, 0, 255);\n      green = 255 - constrain(green, 0, 255);\n      blue = 255 - constrain(blue, 0, 255);\n\n      // fade the red, green, and blue legs of the LED:\n      analogWrite(redPin, red);\n      analogWrite(greenPin, green);\n      analogWrite(bluePin, blue);\n\n      // print the three numbers in one string as hexadecimal:\n      Serial.print(red, HEX);\n      Serial.print(green, HEX);\n      Serial.println(blue, HEX);\n    }\n  }\n}\n" },
  { "name": "SerialCallResponse.ino", "content": "// 04.Communication SerialCallResponse.ino\n\nint firstSensor = 0;\nint secondSensor = 0;\nint thirdSensor = 0;\nint inByte = 0;\n\nvoid setup() {\n  // start serial port at 9600 bps:\n  Serial.begin(9600);\n  while (!Serial) {\n    ;\n  }\n\n  pinMode(2, INPUT);\n  establishContact();\n}\n\nvoid loop() {\n  // if we get a valid byte, read analog ins:\n  if (Serial.available() > 0) {\n    // get incoming byte:\n    inByte = Serial.read();\n\n    // read first analog input, divide by 4 to make the range 0-255:\n    firstSensor = analogRead(A0) / 4;\n    // delay 10ms to let the ADC recover:\n    delay(10);\n\n    // read second analog input, divide by 4 to make the range 0-255:\n    secondSensor = analogRead(1) / 4;\n\n    // read switch, map it to 0 or 255L\n    thirdSensor = map(digitalRead(2), 0, 1, 0, 255);\n\n    // send sensor values:\n    Serial.write(firstSensor);\n    Serial.write(secondSensor);\n    Serial.write(thirdSensor);\n  }\n}\n\nvoid establishContact() {\n  while (Serial.available() <= 0) {\n    Serial.print('A');\n    delay(300);\n  }\n}\n" },
  { "name": "SerialCallResponseASCII.ino", "content": "// 04.Communication SerialCallResponseASCII.ino\n\nint firstSensor = 0;\nint secondSensor = 0;\nint thirdSensor = 0;\nint inByte = 0;\n\nvoid setup() {\n  // start serial port at 9600 bps and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ;\n  }\n\n\n  pinMode(2, INPUT);\n  establishContact();\n}\n\nvoid loop() {\n  // if we get a valid byte, read analog ins:\n  if (Serial.available() > 0) {\n    // get incoming byte:\n    inByte = Serial.read();\n\n    // read first analog input:\n    firstSensor = analogRead(A0);\n\n    // read second analog input:\n    secondSensor = analogRead(A1);\n\n    // read switch, map it to 0 or 255\n    thirdSensor = map(digitalRead(2), 0, 1, 0, 255);\n\n    // send sensor values:\n    Serial.print(firstSensor);\n    Serial.print(\",\");\n    Serial.print(secondSensor);\n    Serial.print(\",\");\n    Serial.println(thirdSensor);\n  }\n}\n\nvoid establishContact() {\n  while (Serial.available() <= 0) {\n    Serial.println(\"0,0,0\");\n    delay(300);\n  }\n}\n" },
  { "name": "SerialEvent.ino", "content": "// 04.Communication SerialEvent.ino\n\nString inputString = \"\";\nbool stringComplete = false;\n\nvoid setup() {\n  // initialize serial:\n  Serial.begin(9600);\n  // reserve 200 bytes for the inputString:\n  inputString.reserve(200);\n}\n\nvoid loop() {\n  // print the string when a newline arrives:\n  if (stringComplete) {\n    Serial.println(inputString);\n\n    // clear the string:\n    inputString = \"\";\n    stringComplete = false;\n  }\n}\n\n\nvoid serialEvent() {\n  while (Serial.available()) {\n    // get the new byte:\n    char inChar = (char)Serial.read();\n    // add it to the inputString:\n    inputString += inChar;\n\n    // if the incoming character is a newline, set a flag so the main loop can\n    // do something about it:\n    if (inChar == '\\n') {\n      stringComplete = true;\n    }\n  }\n}\n" },
  { "name": "SerialPassthrough.ino", "content": "// 04.Communication SerialPassthrough.ino\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial1.begin(9600);\n}\n\nvoid loop() {\n  if (Serial.available()) {\n    Serial1.write(Serial.read());\n  }\n\n  if (Serial1.available()) {\n    Serial.write(Serial1.read());\n  }\n}\n" },
  { "name": "VirtualColorMixer.ino", "content": "// 04.Communication VirtualColorMixer.ino\n\nconst int redPin = A0;\nconst int greenPin = A1;\nconst int bluePin = A2;\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  Serial.print(analogRead(redPin));\n  Serial.print(\",\");\n  Serial.print(analogRead(greenPin));\n  Serial.print(\",\");\n  Serial.println(analogRead(bluePin));\n}\n" },
  { "name": "Arrays.ino", "content": "// 05.Control Arrays.ino\n\nint timer = 100;\nint ledPins[] = {\n  2, 7, 4, 6, 5, 3\n};\nint pinCount = 6;\n\nvoid setup() {\n  // use a for loop to initialize each pin as an output:\n  for (int thisPin = 0; thisPin < pinCount; thisPin++) {\n    pinMode(ledPins[thisPin], OUTPUT);\n  }\n}\n\nvoid loop() {\n  // loop from the lowest pin to the highest:\n  for (int thisPin = 0; thisPin < pinCount; thisPin++) {\n    // turn the pin on:\n    digitalWrite(ledPins[thisPin], HIGH);\n    delay(timer);\n    // turn the pin off:\n    digitalWrite(ledPins[thisPin], LOW);\n  }\n\n  // loop from the highest pin to the lowest:\n  for (int thisPin = pinCount - 1; thisPin >= 0; thisPin--) {\n    // turn the pin on:\n    digitalWrite(ledPins[thisPin], HIGH);\n    delay(timer);\n    // turn the pin off:\n    digitalWrite(ledPins[thisPin], LOW);\n  }\n}\n" },
  { "name": "ForLoopIteration.ino", "content": "// 05.Control ForLoopIteration.ino\n\nint timer = 100;\n\nvoid setup() {\n  // use a for loop to initialize each pin as an output:\n  for (int thisPin = 2; thisPin < 8; thisPin++) {\n    pinMode(thisPin, OUTPUT);\n  }\n}\n\nvoid loop() {\n  // loop from the lowest pin to the highest:\n  for (int thisPin = 2; thisPin < 8; thisPin++) {\n    // turn the pin on:\n    digitalWrite(thisPin, HIGH);\n    delay(timer);\n    // turn the pin off:\n    digitalWrite(thisPin, LOW);\n  }\n\n  // loop from the highest pin to the lowest:\n  for (int thisPin = 7; thisPin >= 2; thisPin--) {\n    // turn the pin on:\n    digitalWrite(thisPin, HIGH);\n    delay(timer);\n    // turn the pin off:\n    digitalWrite(thisPin, LOW);\n  }\n}\n" },
  { "name": "IfStatementConditional.ino", "content": "// 05.Control IfStatementConditional.ino\n\n// These constants won't change:\nconst int analogPin = A0;\nconst int ledPin = 13;\nconst int threshold = 400;\n\nvoid setup() {\n  // initialize the LED pin as an output:\n  pinMode(ledPin, OUTPUT);\n  // initialize serial communications:\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  // read the value of the potentiometer:\n  int analogValue = analogRead(analogPin);\n\n  // if the analog value is high enough, turn on the LED:\n  if (analogValue > threshold) {\n    digitalWrite(ledPin, HIGH);\n  } else {\n    digitalWrite(ledPin, LOW);\n  }\n\n  // print the analog value:\n  Serial.println(analogValue);\n  delay(1);\n}\n" },
  { "name": "WhileStatementConditional.ino", "content": "// 05.Control WhileStatementConditional.ino\n\n// These constants won't change:\nconst int sensorPin = A0;\nconst int ledPin = 9;\nconst int indicatorLedPin = 13;\nconst int buttonPin = 2;\n\n\n// These variables will change:\nint sensorMin = 1023;\nint sensorMax = 0;\nint sensorValue = 0;\n\n\nvoid setup() {\n  // set the LED pins as outputs and the switch pin as input:\n  pinMode(indicatorLedPin, OUTPUT);\n  pinMode(ledPin, OUTPUT);\n  pinMode(buttonPin, INPUT);\n}\n\nvoid loop() {\n  // while the button is pressed, take calibration readings:\n  while (digitalRead(buttonPin) == HIGH) {\n    calibrate();\n  }\n  // signal the end of the calibration period\n  digitalWrite(indicatorLedPin, LOW);\n\n  // read the sensor:\n  sensorValue = analogRead(sensorPin);\n\n  // apply the calibration to the sensor reading\n  sensorValue = map(sensorValue, sensorMin, sensorMax, 0, 255);\n\n  // in case the sensor value is outside the range seen during calibration\n  sensorValue = constrain(sensorValue, 0, 255);\n\n  // fade the LED using the calibrated value:\n  analogWrite(ledPin, sensorValue);\n}\n\nvoid calibrate() {\n  // turn on the indicator LED to indicate that calibration is happening:\n  digitalWrite(indicatorLedPin, HIGH);\n\n  // read the sensor:\n  sensorValue = analogRead(sensorPin);\n\n  // record the maximum sensor value\n  if (sensorValue > sensorMax) {\n    sensorMax = sensorValue;\n  }\n\n  // record the minimum sensor value\n  if (sensorValue < sensorMin) {\n    sensorMin = sensorValue;\n  }\n}\n" },
  { "name": "switchCase.ino", "content": "// 05.Control switchCase.ino\n\n// these constants won't change. They are the lowest and highest readings you\n// get from your sensor:\nconst int sensorMin = 0;\nconst int sensorMax = 600;\n\nvoid setup() {\n  // initialize serial communication:\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  // read the sensor:\n  int sensorReading = analogRead(A0);\n\n  // map the sensor range to a range of four options:\n  int range = map(sensorReading, sensorMin, sensorMax, 0, 3);\n\n  // do something different depending on the range value:\n  switch (range) {\n    case 0:\n      Serial.println(\"dark\");\n      break;\n    case 1:\n      Serial.println(\"dim\");\n      break;\n    case 2:\n      Serial.println(\"medium\");\n      break;\n    case 3:\n      Serial.println(\"bright\");\n      break;\n  }\n  delay(1);\n}\n" },
  { "name": "switchCase2.ino", "content": "// 05.Control switchCase2.ino\n\nvoid setup() {\n  // initialize serial communication:\n  Serial.begin(9600);\n  // initialize the LED pins:\n  for (int thisPin = 2; thisPin < 7; thisPin++) {\n    pinMode(thisPin, OUTPUT);\n  }\n}\n\nvoid loop() {\n  // read the sensor:\n  if (Serial.available() > 0) {\n    int inByte = Serial.read();\n\n    switch (inByte) {\n      case 'a':\n        digitalWrite(2, HIGH);\n        break;\n      case 'b':\n        digitalWrite(3, HIGH);\n        break;\n      case 'c':\n        digitalWrite(4, HIGH);\n        break;\n      case 'd':\n        digitalWrite(5, HIGH);\n        break;\n      case 'e':\n        digitalWrite(6, HIGH);\n        break;\n      default:\n        // turn all the LEDs off:\n        for (int thisPin = 2; thisPin < 7; thisPin++) {\n          digitalWrite(thisPin, LOW);\n        }\n    }\n  }\n}\n" },
  { "name": "ADXL3xx.ino", "content": "// 06.Sensors ADXL3xx.ino\n\n// these constants describe the pins.\nconst int groundpin = 18;\nconst int powerpin = 19;\nconst int xpin = A3;\nconst int ypin = A2;\nconst int zpin = A1;\n\nvoid setup() {\n  // initialize the serial communications:\n  Serial.begin(9600);\n\n  // Provide ground and power by using the analog inputs as normal digital pins.\n  pinMode(groundpin, OUTPUT);\n  pinMode(powerpin, OUTPUT);\n  digitalWrite(groundpin, LOW);\n  digitalWrite(powerpin, HIGH);\n}\n\nvoid loop() {\n  // print the sensor values:\n  Serial.print(analogRead(xpin));\n  // print a tab between values:\n  Serial.print(\"\\t\");\n  Serial.print(analogRead(ypin));\n  // print a tab between values:\n  Serial.print(\"\\t\");\n  Serial.print(analogRead(zpin));\n  Serial.println();\n\n  // delay before next reading:\n  delay(100);\n}\n" },
  { "name": "Knock.ino", "content": "// 06.Sensors Knock.ino\n\n// these constants won't change:\nconst int ledPin = 13;\nconst int knockSensor = A0;\nconst int threshold = 100;\n\n\n// these variables will change:\nint sensorReading = 0;\nint ledState = LOW;\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  // read the sensor and store it in the variable sensorReading:\n  sensorReading = analogRead(knockSensor);\n\n  // if the sensor reading is greater than the threshold:\n  if (sensorReading >= threshold) {\n    // toggle the status of the ledPin:\n    ledState = !ledState;\n    // update the LED pin itself:\n    digitalWrite(ledPin, ledState);\n    // send the string \"Knock!\"\n    Serial.println(\"Knock!\");\n    delay(100);\n  }\n}\n" },
  { "name": "Memsic2125.ino", "content": "// 06.Sensors Memsic2125.ino\n\n// these constants won't change:\nconst int xPin = 2;\nconst int yPin = 3;\n\nvoid setup() {\n  // initialize serial communications:\n  Serial.begin(9600);\n  // initialize the pins connected to the accelerometer as inputs:\n  pinMode(xPin, INPUT);\n  pinMode(yPin, INPUT);\n}\n\nvoid loop() {\n  // variables to read the pulse widths:\n  int pulseX, pulseY;\n  // variables to contain the resulting accelerations\n  int accelerationX, accelerationY;\n\n  // read pulse from x- and y-axes:\n  pulseX = pulseIn(xPin, HIGH);\n  pulseY = pulseIn(yPin, HIGH);\n\n  // convert the pulse width into acceleration\n  accelerationX = ((pulseX / 10) - 500) * 8;\n  accelerationY = ((pulseY / 10) - 500) * 8;\n\n  // print the acceleration\n  Serial.print(accelerationX);\n  // print a tab character:\n  Serial.print(\"\\t\");\n  Serial.print(accelerationY);\n  Serial.println();\n\n  delay(100);\n}\n" },
  { "name": "Ping.ino", "content": "// 06.Sensors Ping.ino\n\n// this constant won't change. It's the pin number of the sensor's output:\nconst int pingPin = 7;\n\nvoid setup() {\n  // initialize serial communication:\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  // establish variables for duration of the ping, and the distance result\n  // in inches and centimeters:\n  long duration, inches, cm;\n\n  // The PING))) is triggered by a HIGH pulse of 2 or more microseconds.\n  // Give a short LOW pulse beforehand to ensure a clean HIGH pulse:\n  pinMode(pingPin, OUTPUT);\n  digitalWrite(pingPin, LOW);\n  delayMicroseconds(2);\n  digitalWrite(pingPin, HIGH);\n  delayMicroseconds(5);\n  digitalWrite(pingPin, LOW);\n\n  // The same pin is used to read the signal from the PING))): a HIGH pulse\n  // whose duration is the time (in microseconds) from the sending of the ping\n  // to the reception of its echo off of an object.\n  pinMode(pingPin, INPUT);\n  duration = pulseIn(pingPin, HIGH);\n\n  // convert the time into a distance\n  inches = microsecondsToInches(duration);\n  cm = microsecondsToCentimeters(duration);\n\n  Serial.print(inches);\n  Serial.print(\"in, \");\n  Serial.print(cm);\n  Serial.print(\"cm\");\n  Serial.println();\n\n  delay(100);\n}\n\nlong microsecondsToInches(long microseconds) {\n  // According to Parallax's datasheet for the PING))), there are 73.746\n  // microseconds per inch (i.e. sound travels at 1130 feet per second).\n  // This gives the distance travelled by the ping, outbound and return,\n  // so we divide by 2 to get the distance of the obstacle.\n  return microseconds / 74 / 2;\n}\n\nlong microsecondsToCentimeters(long microseconds) {\n  // The speed of sound is 340 m/s or 29 microseconds per centimeter.\n  // The ping travels out and back, so to find the distance of the object we\n  // take half of the distance travelled.\n  return microseconds / 29 / 2;\n}\n" },
  { "name": "RowColumnScanning.ino", "content": "// 07.Display RowColumnScanning.ino\n\n// 2-dimensional array of row pin numbers:\nconst int row[8] = {\n  2, 7, 19, 5, 13, 18, 12, 16\n};\n// 2-dimensional array of column pin numbers:\nconst int col[8] = {\n  6, 11, 10, 3, 17, 4, 8, 9\n};\n// 2-dimensional array of pixels:\nint pixels[8][8];\n\n// cursor position:\nint x = 5;\nint y = 5;\n\nvoid setup() {\n  // initialize the I/O pins as outputs iterate over the pins:\n  for (int thisPin = 0; thisPin < 8; thisPin++) {\n    // initialize the output pins:\n    pinMode(col[thisPin], OUTPUT);\n    pinMode(row[thisPin], OUTPUT);\n    // take the col pins (i.e. the cathodes) high to ensure that the LEDS are off:\n    digitalWrite(col[thisPin], HIGH);\n  }\n\n  // initialize the pixel matrix:\n  for (int x = 0; x < 8; x++) {\n    for (int y = 0; y < 8; y++) {\n      pixels[x][y] = HIGH;\n    }\n  }\n}\n\nvoid loop() {\n  // read input:\n  readSensors();\n\n  // draw the screen:\n  refreshScreen();\n}\n\nvoid readSensors() {\n  // turn off the last position:\n  pixels[x][y] = HIGH;\n  // read the sensors for X and Y values:\n  x = 7 - map(analogRead(A0), 0, 1023, 0, 7);\n  y = map(analogRead(A1), 0, 1023, 0, 7);\n  // set the new pixel position low so that the LED will turn on in the next\n  // screen refresh:\n  pixels[x][y] = LOW;\n}\n\nvoid refreshScreen() {\n  // iterate over the rows (anodes):\n  for (int thisRow = 0; thisRow < 8; thisRow++) {\n    // take the row pin (anode) high:\n    digitalWrite(row[thisRow], HIGH);\n\n    // iterate over the cols (cathodes):\n    for (int thisCol = 0; thisCol < 8; thisCol++) {\n      // get the state of the current pixel;\n      int thisPixel = pixels[thisRow][thisCol];\n\n      // when the row is HIGH and the col is LOW,\n      // the LED where they meet turns on:\n      digitalWrite(col[thisCol], thisPixel);\n\n      // turn the pixel off:\n      if (thisPixel == LOW) {\n        digitalWrite(col[thisCol], HIGH);\n      }\n    }\n    // take the row pin low to turn off the whole row:\n    digitalWrite(row[thisRow], LOW);\n  }\n}\n" },
  { "name": "barGraph.ino", "content": "// 07.Display barGraph.ino\n\n// these constants won't change:\nconst int analogPin = A0;\nconst int ledCount = 10;\n\nint ledPins[] = {\n  2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n};\n\n\nvoid setup() {\n  // loop over the pin array and set them all to output:\n  for (int thisLed = 0; thisLed < ledCount; thisLed++) {\n    pinMode(ledPins[thisLed], OUTPUT);\n  }\n}\n\nvoid loop() {\n  // read the potentiometer:\n  int sensorReading = analogRead(analogPin);\n\n  // map the result to a range from 0 to the number of LEDs:\n  int ledLevel = map(sensorReading, 0, 1023, 0, ledCount);\n\n  // loop over the LED array:\n  for (int thisLed = 0; thisLed < ledCount; thisLed++) {\n    // if the array element's index is less than ledLevel,\n    // turn the pin for this element on:\n    if (thisLed < ledLevel) {\n      digitalWrite(ledPins[thisLed], HIGH);\n    }\n    // turn off all pins higher than the ledLevel:\n    else {\n      digitalWrite(ledPins[thisLed], LOW);\n    }\n  }\n}\n" },
  { "name": "CharacterAnalysis", "content": "// 08.Strings CharacterAnalysis\n\nvoid setup() {\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ;\n  }\n\n  // send an intro:\n  Serial.println(\"send any byte and I'll tell you everything I can about it\");\n  Serial.println();\n}\n\nvoid loop() {\n  // get any incoming bytes:\n  if (Serial.available() > 0) {\n    int thisChar = Serial.read();\n\n    // say what was sent:\n    Serial.print(\"You sent me: '\");\n    Serial.write(thisChar);\n    Serial.print(\"'  ASCII Value: \");\n    Serial.println(thisChar);\n\n    // analyze what was sent:\n    if (isAlphaNumeric(thisChar)) {\n      Serial.println(\"it's alphanumeric\");\n    }\n    if (isAlpha(thisChar)) {\n      Serial.println(\"it's alphabetic\");\n    }\n    if (isAscii(thisChar)) {\n      Serial.println(\"it's ASCII\");\n    }\n    if (isWhitespace(thisChar)) {\n      Serial.println(\"it's whitespace\");\n    }\n    if (isControl(thisChar)) {\n      Serial.println(\"it's a control character\");\n    }\n    if (isDigit(thisChar)) {\n      Serial.println(\"it's a numeric digit\");\n    }\n    if (isGraph(thisChar)) {\n      Serial.println(\"it's a printable character that's not whitespace\");\n    }\n    if (isLowerCase(thisChar)) {\n      Serial.println(\"it's lower case\");\n    }\n    if (isPrintable(thisChar)) {\n      Serial.println(\"it's printable\");\n    }\n    if (isPunct(thisChar)) {\n      Serial.println(\"it's punctuation\");\n    }\n    if (isSpace(thisChar)) {\n      Serial.println(\"it's a space character\");\n    }\n    if (isUpperCase(thisChar)) {\n      Serial.println(\"it's upper case\");\n    }\n    if (isHexadecimalDigit(thisChar)) {\n      Serial.println(\"it's a valid hexadecimaldigit (i.e. 0 - 9, a - F, or A - F)\");\n    }\n\n    // add some space and ask for another byte:\n    Serial.println();\n    Serial.println(\"Give me another byte:\");\n    Serial.println();\n  }\n}\n" },
  { "name": "StringAdditionOperator", "content": "// 08.Strings StringAdditionOperator\n\nString stringOne, stringTwo, stringThree;\n\nvoid setup() {\n  // initialize serial and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ;\n  }\n\n  stringOne = String(\"You added \");\n  stringTwo = String(\"this string\");\n  stringThree = String();\n\n  // send an intro:\n  Serial.println(\"\\n\\nAdding Strings together (concatenation):\");\n  Serial.println();\n}\n\nvoid loop() {\n  // adding a constant integer to a String:\n  stringThree = stringOne + 123;\n  Serial.println(stringThree);\n\n  // adding a constant long integer to a String:\n  stringThree = stringOne + 123456789;\n  Serial.println(stringThree);\n\n  // adding a constant character to a String:\n  stringThree = stringOne + 'A';\n  Serial.println(stringThree);\n\n  // adding a constant string to a String:\n  stringThree = stringOne + \"abc\";\n  Serial.println(stringThree);\n\n  stringThree = stringOne + stringTwo;\n  Serial.println(stringThree);\n\n  // adding a variable integer to a String:\n  int sensorValue = analogRead(A0);\n  stringOne = \"Sensor value: \";\n  stringThree = stringOne + sensorValue;\n  Serial.println(stringThree);\n\n  // adding a variable long integer to a String:\n  stringOne = \"millis() value: \";\n  stringThree = stringOne + millis();\n  Serial.println(stringThree);\n\n  // do nothing while true:\n  while (true)\n    ;\n}\n" },
  { "name": "StringAppendOperator", "content": "// 08.Strings StringAppendOperator\n\nString stringOne, stringTwo;\n\nvoid setup() {\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ;\n  }\n\n  stringOne = String(\"Sensor \");\n  stringTwo = String(\"value\");\n\n  // send an intro:\n  Serial.println(\"\\n\\nAppending to a String:\");\n  Serial.println();\n}\n\nvoid loop() {\n  Serial.println(stringOne);\n\n  // adding a string to a String:\n  stringOne += stringTwo;\n  Serial.println(stringOne);\n\n  // adding a constant string to a String:\n  stringOne += \" for input \";\n  Serial.println(stringOne);\n\n  // adding a constant character to a String:\n  stringOne += 'A';\n  Serial.println(stringOne);\n\n  // adding a constant integer to a String:\n  stringOne += 0;\n  Serial.println(stringOne);\n\n  // adding a constant string to a String:\n  stringOne += \": \";\n  Serial.println(stringOne);\n\n  // adding a variable integer to a String:\n  stringOne += analogRead(A0);\n  Serial.println(stringOne);\n\n  Serial.println(\"\\n\\nchanging the Strings' values\");\n  stringOne = \"A long integer: \";\n  stringTwo = \"The millis(): \";\n\n  // adding a constant long integer to a String:\n  stringOne += 123456789;\n  Serial.println(stringOne);\n\n  // using concat() to add a long variable to a String:\n  stringTwo.concat(millis());\n  Serial.println(stringTwo);\n\n  // do nothing while true:\n  while (true)\n    ;\n}\n" },
  { "name": "StringCaseChanges.ino", "content": "// 08.Strings StringCaseChanges\n\nvoid setup() {\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ;\n  }\n\n  // send an intro:\n  Serial.println(\"\\n\\nString case changes:\");\n  Serial.println();\n}\n\nvoid loop() {\n  // toUpperCase() changes all letters to upper case:\n  String stringOne = \"<html><head><body>\";\n  Serial.println(stringOne);\n  stringOne.toUpperCase();\n  Serial.println(stringOne);\n\n  // toLowerCase() changes all letters to lower case:\n  String stringTwo = \"</BODY></HTML>\";\n  Serial.println(stringTwo);\n  stringTwo.toLowerCase();\n  Serial.println(stringTwo);\n\n  // do nothing while true:\n  while (true)\n    ;\n}\n" },
  { "name": "StringCharacters.ino", "content": "// 08.Strings StringCharacters\n\nvoid setup() {\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ;\n  }\n\n  Serial.println(\"\\n\\nString charAt() and setCharAt():\");\n}\n\nvoid loop() {\n  // make a String to report a sensor reading:\n  String reportString = \"SensorReading: 456\";\n  Serial.println(reportString);\n\n  // the reading's most significant digit is at position 15 in the reportString:\n  char mostSignificantDigit = reportString.charAt(15);\n  String message = \"Most significant digit of the sensor reading is: \";\n  Serial.println(message + mostSignificantDigit);\n\n  // add blank space:\n  Serial.println();\n\n  // you can also set the character of a String.\n  reportString.setCharAt(13, '=');\n  Serial.println(reportString);\n\n  // do nothing while true:\n  while (true)\n    ;\n}\n" },
  { "name": "StringComparisonOperators.ino", "content": "// 08.Strings StringComparisonOperators\n\nString stringOne, stringTwo;\n\nvoid setup() {\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ;\n  }\n\n\n  stringOne = String(\"this\");\n  stringTwo = String(\"that\");\n\n  // send an intro:\n  Serial.println(\"\\n\\nComparing Strings:\");\n  Serial.println();\n}\n\nvoid loop() {\n  // two Strings equal:\n  if (stringOne == \"this\") {\n    Serial.println(\"StringOne == \\\"this\\\"\");\n  }\n\n  // two Strings not equal:\n  if (stringOne != stringTwo) {\n    Serial.println(stringOne + \" =! \" + stringTwo);\n  }\n\n  // two Strings not equal (case sensitivity matters):\n  stringOne = \"This\";\n  stringTwo = \"this\";\n  if (stringOne != stringTwo) {\n    Serial.println(stringOne + \" =! \" + stringTwo);\n  }\n  // you can also use equals() to see if two Strings are the same:\n  if (stringOne.equals(stringTwo)) {\n    Serial.println(stringOne + \" equals \" + stringTwo);\n  } else {\n    Serial.println(stringOne + \" does not equal \" + stringTwo);\n  }\n\n  // or perhaps you want to ignore case:\n  if (stringOne.equalsIgnoreCase(stringTwo)) {\n    Serial.println(stringOne + \" equals (ignoring case) \" + stringTwo);\n  } else {\n    Serial.println(stringOne + \" does not equal (ignoring case) \" + stringTwo);\n  }\n\n  // a numeric String compared to the number it represents:\n  stringOne = \"1\";\n  int numberOne = 1;\n  if (stringOne.toInt() == numberOne) {\n    Serial.println(stringOne + \" = \" + numberOne);\n  }\n\n\n\n  // two numeric Strings compared:\n  stringOne = \"2\";\n  stringTwo = \"1\";\n  if (stringOne >= stringTwo) {\n    Serial.println(stringOne + \" >= \" + stringTwo);\n  }\n\n  // comparison operators can be used to compare Strings for alphabetic sorting too:\n  stringOne = String(\"Brown\");\n  if (stringOne < \"Charles\") {\n    Serial.println(stringOne + \" < Charles\");\n  }\n\n  if (stringOne > \"Adams\") {\n    Serial.println(stringOne + \" > Adams\");\n  }\n\n  if (stringOne <= \"Browne\") {\n    Serial.println(stringOne + \" <= Browne\");\n  }\n\n\n  if (stringOne >= \"Brow\") {\n    Serial.println(stringOne + \" >= Brow\");\n  }\n\n  // the compareTo() operator also allows you to compare Strings\n  stringOne = \"Cucumber\";\n  stringTwo = \"Cucuracha\";\n  if (stringOne.compareTo(stringTwo) < 0) {\n    Serial.println(stringOne + \" comes before \" + stringTwo);\n  } else {\n    Serial.println(stringOne + \" comes after \" + stringTwo);\n  }\n\n  delay(10000);\n\n  // compareTo() is handy when you've got Strings with numbers in them too:\n\n  while (true) {\n    stringOne = \"Sensor: \";\n    stringTwo = \"Sensor: \";\n\n    stringOne += analogRead(A0);\n    stringTwo += analogRead(A5);\n\n    if (stringOne.compareTo(stringTwo) < 0) {\n      Serial.println(stringOne + \" comes before \" + stringTwo);\n    } else {\n      Serial.println(stringOne + \" comes after \" + stringTwo);\n    }\n  }\n}\n" },
  { "name": "StringConstructors.ino", "content": "// 08.Strings StringConstructors\n\nvoid setup() {\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ;\n  }\n\n  // send an intro:\n  Serial.println(\"\\n\\nString Constructors:\");\n  Serial.println();\n}\n\nvoid loop() {\n  // using a constant String:\n  String stringOne = \"Hello String\";\n  Serial.println(stringOne);\n\n  // converting a constant char into a String:\n  stringOne = String('a');\n  Serial.println(stringOne);\n\n  // converting a constant string into a String object:\n  String stringTwo = String(\"This is a string\");\n  Serial.println(stringTwo);\n\n  // concatenating two strings:\n  stringOne = String(stringTwo + \" with more\");\n  Serial.println(stringOne);\n\n  // using a constant integer:\n  stringOne = String(13);\n  Serial.println(stringOne);\n\n  // using an int and a base:\n  stringOne = String(analogRead(A0), DEC);\n  Serial.println(stringOne);\n\n  // using an int and a base (hexadecimal):\n  stringOne = String(45, HEX);\n  Serial.println(stringOne);\n\n  // using an int and a base (binary)\n  stringOne = String(255, BIN);\n  Serial.println(stringOne);\n\n  // using a long and a base:\n  stringOne = String(millis(), DEC);\n  Serial.println(stringOne);\n\n  // using a float and the right decimal places:\n  stringOne = String(5.698, 3);\n  Serial.println(stringOne);\n\n  // using a float and less decimal places to use rounding:\n  stringOne = String(5.698, 2);\n  Serial.println(stringOne);\n\n  // do nothing while true:\n  while (true)\n    ;\n}\n" },
  { "name": "StringLength.ino", "content": "// 08.Strings StringLength\n\nString txtMsg = \"\";\nunsigned int lastStringLength = txtMsg.length();\n\nvoid setup() {\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ;\n  }\n\n  // send an intro:\n  Serial.println(\"\\n\\nString  length():\");\n  Serial.println();\n}\n\nvoid loop() {\n  // add any incoming characters to the String:\n  while (Serial.available() > 0) {\n    char inChar = Serial.read();\n    txtMsg += inChar;\n  }\n\n  // print the message and a notice if it's changed:\n  if (txtMsg.length() != lastStringLength) {\n    Serial.println(txtMsg);\n    Serial.println(txtMsg.length());\n\n    // if the String's longer than 140 characters, complain:\n    if (txtMsg.length() < 140) {\n      Serial.println(\"That's a perfectly acceptable text message\");\n    } else {\n      Serial.println(\"That's too long for a text message.\");\n    }\n    // note the length for next time through the loop:\n    lastStringLength = txtMsg.length();\n  }\n}\n" },
  { "name": "StringLengthTrim.ino", "content": "// 08.Strings StringLengthTrim\n\nvoid setup() {\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ;\n  }\n\n  // send an intro:\n  Serial.println(\"\\n\\nString length() and trim():\");\n  Serial.println();\n}\n\nvoid loop() {\n  // here's a String with empty spaces at the end (called white space):\n  String stringOne = \"Hello!       \";\n  Serial.print(stringOne);\n  Serial.print(\"<--- end of string. Length: \");\n  Serial.println(stringOne.length());\n\n  // trim the white space off the string:\n  stringOne.trim();\n  Serial.print(stringOne);\n  Serial.print(\"<--- end of trimmed string. Length: \");\n  Serial.println(stringOne.length());\n\n  // do nothing while true:\n  while (true)\n    ;\n}\n" },
  { "name": "StringReplace.ino", "content": "// 08.Strings StringReplace\n\nvoid setup() {\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ;\n  }\n\n  // send an intro:\n  Serial.println(\"\\n\\nString replace:\\n\");\n  Serial.println();\n}\n\nvoid loop() {\n  String stringOne = \"<html><head><body>\";\n  Serial.println(stringOne);\n\n  // replace() changes all instances of one substring with another:\n  // first, make a copy of the original string:\n  String stringTwo = stringOne;\n  // then perform the replacements:\n  stringTwo.replace(\"<\", \"</\");\n  // print the original:\n  Serial.println(\"Original string: \" + stringOne);\n  // and print the modified string:\n  Serial.println(\"Modified string: \" + stringTwo);\n\n  // you can also use replace() on single characters:\n  String normalString = \"bookkeeper\";\n  Serial.println(\"normal: \" + normalString);\n  String leetString = normalString;\n  leetString.replace('o', '0');\n  leetString.replace('e', '3');\n  Serial.println(\"l33tspeak: \" + leetString);\n\n  // do nothing while true:\n  while (true)\n    ;\n}\n" },
  { "name": "StringStartsWithEndsWith.ino", "content": "// 08.Strings StringStartsWithEndsWith\n\nvoid setup() {\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ;\n  }\n\n  // send an intro:\n  Serial.println(\"\\n\\nString startsWith() and endsWith():\");\n  Serial.println();\n}\n\nvoid loop() {\n  // startsWith() checks to see if a String starts with a particular substring:\n  String stringOne = \"HTTP/1.1 200 OK\";\n  Serial.println(stringOne);\n  if (stringOne.startsWith(\"HTTP/1.1\")) {\n    Serial.println(\"Server's using http version 1.1\");\n  }\n\n  // you can also look for startsWith() at an offset position in the string:\n  stringOne = \"HTTP/1.1 200 OK\";\n  if (stringOne.startsWith(\"200 OK\", 9)) {\n    Serial.println(\"Got an OK from the server\");\n  }\n\n  // endsWith() checks to see if a String ends with a particular character:\n  String sensorReading = \"sensor = \";\n  sensorReading += analogRead(A0);\n  Serial.print(sensorReading);\n  if (sensorReading.endsWith(\"0\")) {\n    Serial.println(\". This reading is divisible by ten\");\n  } else {\n    Serial.println(\". This reading is not divisible by ten\");\n  }\n\n  // do nothing while true:\n  while (true)\n    ;\n}\n" },
  { "name": "StringSubstring.ino", "content": "// 08.Strings StringSubstring\n\nvoid setup() {\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ;\n  }\n\n  // send an intro:\n  Serial.println(\"\\n\\nString  substring():\");\n  Serial.println();\n}\n\nvoid loop() {\n  // Set up a String:\n  String stringOne = \"Content-Type: text/html\";\n  Serial.println(stringOne);\n\n  // substring(index) looks for the substring from the index position to the end:\n  if (stringOne.substring(19) == \"html\") {\n    Serial.println(\"It's an html file\");\n  }\n  // you can also look for a substring in the middle of a string:\n  if (stringOne.substring(14, 18) == \"text\") {\n    Serial.println(\"It's a text-based file\");\n  }\n\n  // do nothing while true:\n  while (true)\n    ;\n}\n" },
  { "name": "StringToInt.ino", "content": "// 08.Strings StringToInt\n\nString inString = \"\";\n\nvoid setup() {\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ;\n  }\n\n  // send an intro:\n  Serial.println(\"\\n\\nString toInt():\");\n  Serial.println();\n}\n\nvoid loop() {\n  // Read serial input:\n  while (Serial.available() > 0) {\n    int inChar = Serial.read();\n    if (isDigit(inChar)) {\n      // convert the incoming byte to a char and add it to the string:\n      inString += (char)inChar;\n    }\n    // if you get a newline, print the string, then the string's value:\n    if (inChar == '\\n') {\n      Serial.print(\"Value:\");\n      Serial.println(inString.toInt());\n      Serial.print(\"String: \");\n      Serial.println(inString);\n\n      // clear the string for new input:\n      inString = \"\";\n    }\n  }\n}\n" },
  { "name": "KeyboardLogout.ino", "content": "// 09.USB Keyboard/KeyboardLogout\n\n#define OSX 0\n#define WINDOWS 1\n#define UBUNTU 2\n\n#include \"Keyboard.h\"\n\n// change this to match your platform:\nint platform = OSX;\n\nvoid setup() {\n  // make pin 2 an input and turn on the pull-up resistor so it goes high unless\n  // connected to ground:\n  pinMode(2, INPUT_PULLUP);\n  Keyboard.begin();\n}\n\nvoid loop() {\n  while (digitalRead(2) == HIGH) {\n    // do nothing until pin 2 goes low\n    delay(500);\n  }\n  delay(1000);\n\n  switch (platform) {\n    case OSX:\n      Keyboard.press(KEY_LEFT_GUI);\n      Keyboard.press(KEY_LEFT_SHIFT);\n      Keyboard.press('Q');\n      delay(100);\n      Keyboard.releaseAll();\n      Keyboard.write(KEY_RETURN);\n      break;\n    case WINDOWS:\n      Keyboard.press(KEY_LEFT_CTRL);\n      Keyboard.press(KEY_LEFT_ALT);\n      Keyboard.press(KEY_DELETE);\n      delay(100);\n      Keyboard.releaseAll();\n      delay(2000);\n      Keyboard.press(KEY_LEFT_ALT);\n      Keyboard.press('l');\n      Keyboard.releaseAll();\n      break;\n    case UBUNTU:\n      Keyboard.press(KEY_LEFT_CTRL);\n      Keyboard.press(KEY_LEFT_ALT);\n      Keyboard.press(KEY_DELETE);\n      delay(1000);\n      Keyboard.releaseAll();\n      Keyboard.write(KEY_RETURN);\n      break;\n  }\n\n  // do nothing:\n  while (true)\n    ;\n}\n" },
  { "name": "KeyboardReprogram.ino", "content": "// 09.USB Keyboard/KeyboardReprogram\n\n#include \"Keyboard.h\"\n\nconst int buttonPin = 4;\nint previousButtonState = HIGH;\nint counter = 0;\n\nvoid setup() {\n  // make the pushButton pin an input:\n  pinMode(buttonPin, INPUT);\n  // initialize control over the keyboard:\n  Keyboard.begin();\n}\n\nvoid loop() {\n  // read the pushbutton:\n  int buttonState = digitalRead(buttonPin);\n\n  // if the button state has changed,\n  if ((buttonState != previousButtonState)\n      // and it's currently pressed:\n      && (buttonState == HIGH)) {\n    // increment the button counter\n    counter++;\n    // type out a message\n    Keyboard.print(\"You pressed the button \");\n    Keyboard.print(counter);\n    Keyboard.println(\" times.\");\n  }\n\n  // save the current button state for comparison next time:\n  previousButtonState = buttonState;\n}\n" },
  { "name": "KeyboardSerial.ino", "content": "// 09.USB Keyboard/KeyboardSerial\n\n#include \"Keyboard.h\"\n\n// use this option for OSX.\nchar ctrlKey = KEY_LEFT_GUI;\n// use this option for Windows and Linux.\n// char ctrlKey = KEY_LEFT_CTRL;\n\nvoid setup() {\n  // make pin 2 an input and turn on the pull-up resistor so it goes high unless\n  // connected to ground:\n  pinMode(2, INPUT_PULLUP);\n  // initialize control over the keyboard:\n  Keyboard.begin();\n}\n\nvoid loop() {\n  while (digitalRead(2) == HIGH) {\n    // do nothing until pin 2 goes low\n    delay(500);\n  }\n  delay(1000);\n\n  // new document:\n  Keyboard.press(ctrlKey);\n  Keyboard.press('n');\n  delay(100);\n  Keyboard.releaseAll();\n  // wait for new window to open:\n  delay(1000);\n\n  // versions of the Arduino IDE after 1.5 pre-populate new sketches with\n  // setup() and loop() functions let's clear the window before typing anything new\n  // select all\n  Keyboard.press(ctrlKey);\n  Keyboard.press('a');\n  delay(500);\n  Keyboard.releaseAll();\n  // delete the selected text\n  Keyboard.write(KEY_BACKSPACE);\n  delay(500);\n\n  // Type out \"blink\":\n  Keyboard.println(\"void setup() {\");\n  Keyboard.println(\"pinMode(13, OUTPUT);\");\n  Keyboard.println(\"}\");\n  Keyboard.println();\n  Keyboard.println(\"void loop() {\");\n  Keyboard.println(\"digitalWrite(13, HIGH);\");\n  Keyboard.print(\"delay(3000);\");\n  // 3000 ms is too long.\n  for (int keystrokes = 0; keystrokes < 6; keystrokes++) {\n    delay(500);\n    Keyboard.write(KEY_BACKSPACE);\n  }\n  // make it 1000 instead:\n  Keyboard.println(\"1000);\");\n  Keyboard.println(\"digitalWrite(13, LOW);\");\n  Keyboard.println(\"delay(1000);\");\n  Keyboard.println(\"}\");\n  // tidy up:\n  Keyboard.press(ctrlKey);\n  Keyboard.press('t');\n  delay(100);\n  Keyboard.releaseAll();\n  delay(3000);\n\n  // upload code:\n  Keyboard.press(ctrlKey);\n  Keyboard.press('u');\n  delay(100);\n  Keyboard.releaseAll();\n\n  // wait for the sweet oblivion of reprogramming:\n  while (true)\n    ;\n}\n" },
  { "name": "KeyboardAndMouseControl.ino", "content": "// 09.USB KeyboardAndMouseControl\n\n#include \"Keyboard.h\"\n#include \"Mouse.h\"\n\n// set pin numbers for the five buttons:\nconst int upButton = 2;\nconst int downButton = 3;\nconst int leftButton = 4;\nconst int rightButton = 5;\nconst int mouseButton = 6;\n\nvoid setup() {\n  // initialize the buttons' inputs:\n  pinMode(upButton, INPUT);\n  pinMode(downButton, INPUT);\n  pinMode(leftButton, INPUT);\n  pinMode(rightButton, INPUT);\n  pinMode(mouseButton, INPUT);\n\n  Serial.begin(9600);\n  // initialize mouse control:\n  Mouse.begin();\n  Keyboard.begin();\n}\n\nvoid loop() {\n  // use serial input to control the mouse:\n  if (Serial.available() > 0) {\n    char inChar = Serial.read();\n    switch (inChar) {\n      case 'u':\n        // move mouse up\n        Mouse.move(0, -40);\n        break;\n      case 'd':\n        // move mouse down\n        Mouse.move(0, 40);\n        break;\n      case 'l':\n        // move mouse left\n        Mouse.move(-40, 0);\n        break;\n      case 'r':\n        // move mouse right\n        Mouse.move(40, 0);\n        break;\n      case 'm':\n        // perform mouse left click\n        Mouse.click(MOUSE_LEFT);\n        break;\n    }\n  }\n\n  // use the pushbuttons to control the keyboard:\n  if (digitalRead(upButton) == HIGH) {\n    Keyboard.write('u');\n  }\n  if (digitalRead(downButton) == HIGH) {\n    Keyboard.write('d');\n  }\n  if (digitalRead(leftButton) == HIGH) {\n    Keyboard.write('l');\n  }\n  if (digitalRead(rightButton) == HIGH) {\n    Keyboard.write('r');\n  }\n  if (digitalRead(mouseButton) == HIGH) {\n    Keyboard.write('m');\n  }\n}\n" },
  { "name": "ButtonMouseControl.ino", "content": "// 09.USB Mouse/ButtonMouseControl\n\n#include \"Mouse.h\"\n\n// set pin numbers for the five buttons:\nconst int upButton = 2;\nconst int downButton = 3;\nconst int leftButton = 4;\nconst int rightButton = 5;\nconst int mouseButton = 6;\n\nint range = 5;\nint responseDelay = 10;\n\n\nvoid setup() {\n  // initialize the buttons' inputs:\n  pinMode(upButton, INPUT);\n  pinMode(downButton, INPUT);\n  pinMode(leftButton, INPUT);\n  pinMode(rightButton, INPUT);\n  pinMode(mouseButton, INPUT);\n  // initialize mouse control:\n  Mouse.begin();\n}\n\nvoid loop() {\n  // read the buttons:\n  int upState = digitalRead(upButton);\n  int downState = digitalRead(downButton);\n  int rightState = digitalRead(rightButton);\n  int leftState = digitalRead(leftButton);\n  int clickState = digitalRead(mouseButton);\n\n  // calculate the movement distance based on the button states:\n  int xDistance = (leftState - rightState) * range;\n  int yDistance = (upState - downState) * range;\n\n  // if X or Y is non-zero, move:\n  if ((xDistance != 0) || (yDistance != 0)) {\n    Mouse.move(xDistance, yDistance, 0);\n  }\n\n  // if the mouse button is pressed:\n  if (clickState == HIGH) {\n    // if the mouse is not pressed, press it:\n    if (!Mouse.isPressed(MOUSE_LEFT)) {\n      Mouse.press(MOUSE_LEFT);\n    }\n  }\n  // else the mouse button is not pressed:\n  else {\n    // if the mouse is pressed, release it:\n    if (Mouse.isPressed(MOUSE_LEFT)) {\n      Mouse.release(MOUSE_LEFT);\n    }\n  }\n\n  // a delay so the mouse doesn't move too fast:\n  delay(responseDelay);\n}\n" },
  { "name": "JoystickMouseControl.ino", "content": "// 09.USB Mouse/JoystickMouseControl\n\n#include \"Mouse.h\"\n\n// set pin numbers for switch, joystick axes, and LED:\nconst int switchPin = 2;\nconst int mouseButton = 3;\nconst int xAxis = A0;\nconst int yAxis = A1;\nconst int ledPin = 5;\n\n// parameters for reading the joystick:\nint range = 12;\nint responseDelay = 5;\nint threshold = range / 4;\nint center = range / 2;\n\nbool mouseIsActive = false;\nint lastSwitchState = LOW;\n\nvoid setup() {\n  pinMode(switchPin, INPUT);\n  pinMode(mouseButton, INPUT);\n  pinMode(ledPin, OUTPUT);\n  // take control of the mouse:\n  Mouse.begin();\n}\n\nvoid loop() {\n  // read the switch:\n  int switchState = digitalRead(switchPin);\n\n  // if it's changed and it's high, toggle the mouse state:\n  if (switchState != lastSwitchState) {\n    if (switchState == HIGH) {\n      mouseIsActive = !mouseIsActive;\n      // turn on LED to indicate mouse state:\n      digitalWrite(ledPin, mouseIsActive);\n    }\n  }\n  // save switch state for next comparison:\n  lastSwitchState = switchState;\n\n  // read and scale the two axes:\n  int xReading = readAxis(A0);\n  int yReading = readAxis(A1);\n\n  // if the mouse control state is active, move the mouse:\n  if (mouseIsActive) {\n    Mouse.move(xReading, yReading, 0);\n  }\n\n  // read the mouse button and click or not click:\n  // if the mouse button is pressed:\n  if (digitalRead(mouseButton) == HIGH) {\n    // if the mouse is not pressed, press it:\n    if (!Mouse.isPressed(MOUSE_LEFT)) {\n      Mouse.press(MOUSE_LEFT);\n    }\n  }\n  // else the mouse button is not pressed:\n  else {\n    // if the mouse is pressed, release it:\n    if (Mouse.isPressed(MOUSE_LEFT)) {\n      Mouse.release(MOUSE_LEFT);\n    }\n  }\n\n  delay(responseDelay);\n}\n\n\nint readAxis(int thisAxis) {\n  // read the analog input:\n  int reading = analogRead(thisAxis);\n\n  // map the reading from the analog input range to the output range:\n  reading = map(reading, 0, 1023, 0, range);\n\n  // if the output reading is outside from the rest position threshold, use it:\n  int distance = reading - center;\n  if (abs(distance) < threshold) {\n    distance = 0;\n  }\n\n  // return the distance for this axis:\n  return distance;\n}\n" },
  { "name": "p02_SpaceshipInterface.ino", "content": "// 10.StarterKit_BasicKit p02_SpaceshipInterface\n\nint switchstate = 0;\n\nvoid setup() {\n  // declare the LED pins as outputs\n  pinMode(3, OUTPUT);\n  pinMode(4, OUTPUT);\n  pinMode(5, OUTPUT);\n  // declare the switch pin as an input\n  pinMode(2, INPUT);\n}\n\nvoid loop() {\n\n  // read the value of the switch\n  switchstate = digitalRead(2);\n\n  // if the button is not pressed turn on the green LED and off the red LEDs\n  if (switchstate == LOW) {\n    digitalWrite(3, HIGH);\n    digitalWrite(4, LOW);\n    digitalWrite(5, LOW);\n  }\n  // if the switch is not LOW (the button is pressed) turn off the green LED and\n  // blink alternatively the red LEDs\n  else {\n    digitalWrite(3, LOW);\n    digitalWrite(4, LOW);\n    digitalWrite(5, HIGH);\n    // wait for a quarter second before changing the light\n    delay(250);\n    digitalWrite(4, HIGH);\n    digitalWrite(5, LOW);\n    // wait for a quarter second before changing the light\n    delay(250);\n  }\n}\n" },
  { "name": "p03_LoveOMeter.ino", "content": "// 10.StarterKit_BasicKit p03_LoveOMeter\n\n// named constant for the pin the sensor is connected to\nconst int sensorPin = A0;\n// room temperature in Celsius\nconst float baselineTemp = 20.0;\n\nvoid setup() {\n  // open a serial connection to display values\n  Serial.begin(9600);\n  // set the LED pins as outputs\n  for (int pinNumber = 2; pinNumber < 5; pinNumber++) {\n    pinMode(pinNumber, OUTPUT);\n    digitalWrite(pinNumber, LOW);\n  }\n}\n\nvoid loop() {\n  // read the value on AnalogIn pin 0 and store it in a variable\n  int sensorVal = analogRead(sensorPin);\n  // send the 10-bit sensor value out the serial port\n  Serial.print(\"sensor Value: \");\n  Serial.print(sensorVal);\n\n  // convert the ADC reading to voltage\n  float voltage = (sensorVal / 1024.0) * 5.0;\n  // Send the voltage level out the Serial port\n  Serial.print(\", Volts: \");\n  Serial.print(voltage);\n\n  // convert the voltage to temperature in degrees C\n  Serial.print(\", degrees C: \");\n  float temperature = (voltage - .5) * 100;\n  Serial.println(temperature);\n\n  // if the current temperature is lower than the baseline turn off all LEDs\n  if (temperature < baselineTemp + 2) {\n    digitalWrite(2, LOW);\n    digitalWrite(3, LOW);\n    digitalWrite(4, LOW);\n  }\n  // if the temperature rises 2-4 degrees, turn an LED on\n  else if (temperature >= baselineTemp + 2 && temperature < baselineTemp + 4) {\n    digitalWrite(2, HIGH);\n    digitalWrite(3, LOW);\n    digitalWrite(4, LOW);\n  }\n  // if the temperature rises 4-6 degrees, turn a second LED on\n  else if (temperature >= baselineTemp + 4 && temperature < baselineTemp + 6) {\n    digitalWrite(2, HIGH);\n    digitalWrite(3, HIGH);\n    digitalWrite(4, LOW);\n  }\n  // if the temperature rises more than 6 degrees, turn all LEDs on\n  else if (temperature >= baselineTemp + 6) {\n    digitalWrite(2, HIGH);\n    digitalWrite(3, HIGH);\n    digitalWrite(4, HIGH);\n  }\n  delay(1);\n}\n" },
  { "name": "p04_ColorMixingLamp.ino", "content": "// 10.StarterKit_BasicKit p04_ColorMixingLamp\n\nconst int greenLEDPin = 9;\nconst int redLEDPin = 10;\nconst int blueLEDPin = 11;\n\nconst int redSensorPin = A0;\nconst int greenSensorPin = A1;\nconst int blueSensorPin = A2;\n\nint redValue = 0;\nint greenValue = 0;\nint blueValue = 0;\n\nint redSensorValue = 0;\nint greenSensorValue = 0;\nint blueSensorValue = 0;\n\nvoid setup() {\n  // initialize serial communications at 9600 bps:\n  Serial.begin(9600);\n  // set the digital pins as outputs\n  pinMode(greenLEDPin, OUTPUT);\n  pinMode(redLEDPin, OUTPUT);\n  pinMode(blueLEDPin, OUTPUT);\n}\n\nvoid loop() {\n  // Read the sensors first:\n\n  // read the value from the red-filtered photoresistor:\n  redSensorValue = analogRead(redSensorPin);\n  // give the ADC a moment to settle\n  delay(5);\n\n  // read the value from the green-filtered photoresistor:\n  greenSensorValue = analogRead(greenSensorPin);\n  // give the ADC a moment to settle\n  delay(5);\n\n  // read the value from the blue-filtered photoresistor:\n  blueSensorValue = analogRead(blueSensorPin);\n\n  // print out the values to the Serial Monitor\n  Serial.print(\"raw sensor Values \\t red: \");\n  Serial.print(redSensorValue);\n  Serial.print(\"\\t green: \");\n  Serial.print(greenSensorValue);\n  Serial.print(\"\\t Blue: \");\n  Serial.println(blueSensorValue);\n\n  \n  redValue = redSensorValue / 4;\n  greenValue = greenSensorValue / 4;\n  blueValue = blueSensorValue / 4;\n\n  // print out the mapped values\n  Serial.print(\"Mapped sensor Values \\t red: \");\n  Serial.print(redValue);\n  Serial.print(\"\\t green: \");\n  Serial.print(greenValue);\n  Serial.print(\"\\t Blue: \");\n  Serial.println(blueValue);\n\n  \n  analogWrite(redLEDPin, redValue);\n  analogWrite(greenLEDPin, greenValue);\n  analogWrite(blueLEDPin, blueValue);\n}\n" },
  { "name": "p05_ServoMoodIndicator.ino", "content": "// 10.StarterKit_BasicKit p05_ServoMoodIndicator\n\n// include the Servo library\n#include <Servo.h>\n\nServo myServo;\n\nint const potPin = A0;\nint potVal;\nint angle;\n\nvoid setup() {\n  myServo.attach(9);\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  potVal = analogRead(potPin);\n\n  // print out the value to the Serial Monitor\n  Serial.print(\"potVal: \");\n  Serial.print(potVal);\n\n  // scale the numbers from the pot\n  angle = map(potVal, 0, 1023, 0, 179);\n  // print out the angle for the servo motor\n  Serial.print(\", angle: \");\n  Serial.println(angle);\n\n  // set the servo position\n  myServo.write(angle);\n\n  // wait for the servo to get there\n  delay(15);\n}\n" },
  { "name": "p06_LightTheremin.ino", "content": "// 10.StarterKit_BasicKit p06_LightTheremin\n\n// variable to hold sensor value\nint sensorValue;\n// variable to calibrate low value\nint sensorLow = 1023;\n// variable to calibrate high value\nint sensorHigh = 0;\n// LED pin\nconst int ledPin = 13;\n\nvoid setup() {\n  // Make the LED pin an output and turn it on\n  pinMode(ledPin, OUTPUT);\n  digitalWrite(ledPin, HIGH);\n\n  // calibrate for the first five seconds after program runs\n  while (millis() < 5000) {\n    // record the maximum sensor value\n    sensorValue = analogRead(A0);\n    if (sensorValue > sensorHigh) {\n      sensorHigh = sensorValue;\n    }\n    // record the minimum sensor value\n    if (sensorValue < sensorLow) {\n      sensorLow = sensorValue;\n    }\n  }\n  // turn the LED off, signaling the end of the calibration period\n  digitalWrite(ledPin, LOW);\n}\n\nvoid loop() {\n  //read the input from A0 and store it in a variable\n  sensorValue = analogRead(A0);\n\n  // map the sensor values to a wide range of pitches\n  int pitch = map(sensorValue, sensorLow, sensorHigh, 50, 4000);\n  // play the tone for 20 ms on pin 8\n  tone(8, pitch, 20);\n\n  // wait for a moment\n  delay(10);\n}\n" },
  { "name": "p07_Keyboard.ino", "content": "// 10.StarterKit_BasicKit p07_Keyboard\n\n// create an array of notes\nint notes[] = { 262, 294, 330, 349 };\n\nvoid setup() {\n  //start serial communication\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  // create a local variable to hold the input on pin A0\n  int keyVal = analogRead(A0);\n  // send the value from A0 to the Serial Monitor\n  Serial.println(keyVal);\n\n  // play the note corresponding to each value on A0\n  if (keyVal == 1023) {\n    // play the first frequency in the array on pin 8\n    tone(8, notes[0]);\n  } else if (keyVal >= 990 && keyVal <= 1010) {\n    // play the second frequency in the array on pin 8\n    tone(8, notes[1]);\n  } else if (keyVal >= 505 && keyVal <= 515) {\n    // play the third frequency in the array on pin 8\n    tone(8, notes[2]);\n  } else if (keyVal >= 5 && keyVal <= 10) {\n    // play the fourth frequency in the array on pin 8\n    tone(8, notes[3]);\n  } else {\n    // if the value is out of range, play no tone\n    noTone(8);\n  }\n}\n" },
  { "name": "p08_DigitalHourglass.ino", "content": "// 10.StarterKit_BasicKit p08_DigitalHourglass\n\n// named constant for the switch pin\nconst int switchPin = 8;\n\nunsigned long previousTime = 0;\nint switchState = 0;\nint prevSwitchState = 0;\nint led = 2;\n\n// 600000 = 10 minutes in milliseconds\nlong interval = 600000;\n\nvoid setup() {\n  // set the LED pins as outputs\n  for (int x = 2; x < 8; x++) {\n    pinMode(x, OUTPUT);\n  }\n  // set the tilt switch pin as input\n  pinMode(switchPin, INPUT);\n}\n\nvoid loop() {\n  // store the time since the Arduino started running in a variable\n  unsigned long currentTime = millis();\n\n  // compare the current time to the previous time an LED turned on\n  // if it is greater than your interval, run the if statement\n  if (currentTime - previousTime > interval) {\n    // save the current time as the last time you changed an LED\n    previousTime = currentTime;\n\n    // Turn the LED on\n    digitalWrite(led, HIGH);\n\n    // increment the led variable\n    // in 10 minutes the next LED will light up\n    led++;\n\n    if (led == 7) {\n      // the hour is up\n      // add your indicator code here\n    }\n  }\n\n  // read the switch value\n  switchState = digitalRead(switchPin);\n\n  // if the switch has changed\n  if (switchState != prevSwitchState) {\n    // turn all the LEDs low\n    for (int x = 2; x < 8; x++) {\n      digitalWrite(x, LOW);\n    }\n\n    // reset the LED variable to the first one\n    led = 2;\n    //reset the timer\n    previousTime = currentTime;\n  }\n  // set the previous switch state to the current state\n  prevSwitchState = switchState;\n}\n" },
  { "name": "p09_MotorizedPinwheel.ino", "content": "// 10.StarterKit_BasicKit p09_MotorizedPinwheel\n\n// named constants for the switch and motor pins\nconst int switchPin = 2;\nconst int motorPin = 9;\n\nint switchState = 0;\n\nvoid setup() {\n  // initialize the motor pin as an output:\n  pinMode(motorPin, OUTPUT);\n  // initialize the switch pin as an input:\n  pinMode(switchPin, INPUT);\n}\n\nvoid loop() {\n  // read the state of the switch value:\n  switchState = digitalRead(switchPin);\n\n  // check if the switch is pressed.\n  if (switchState == HIGH) {\n    // turn motor on:\n    digitalWrite(motorPin, HIGH);\n  } else {\n    // turn motor off:\n    digitalWrite(motorPin, LOW);\n  }\n}\n" },
  { "name": "p10_Zoetrope.ino", "content": "// 10.StarterKit_BasicKit p10_Zoetrope\n\nconst int controlPin1 = 2;\nconst int controlPin2 = 3;\nconst int enablePin = 9;\nconst int directionSwitchPin = 4;\nconst int onOffSwitchStateSwitchPin = 5;\nconst int potPin = A0;\n\n// create some variables to hold values from your inputs\nint onOffSwitchState = 0;\nint previousOnOffSwitchState = 0;\nint directionSwitchState = 0;\nint previousDirectionSwitchState = 0;\n\nint motorEnabled = 0;\nint motorSpeed = 0;\nint motorDirection = 1;\n\nvoid setup() {\n  // initialize the inputs and outputs\n  pinMode(directionSwitchPin, INPUT);\n  pinMode(onOffSwitchStateSwitchPin, INPUT);\n  pinMode(controlPin1, OUTPUT);\n  pinMode(controlPin2, OUTPUT);\n  pinMode(enablePin, OUTPUT);\n\n  // pull the enable pin LOW to start\n  digitalWrite(enablePin, LOW);\n}\n\nvoid loop() {\n  // read the value of the on/off switch\n  onOffSwitchState = digitalRead(onOffSwitchStateSwitchPin);\n  delay(1);\n  // read the value of the direction switch\n  directionSwitchState = digitalRead(directionSwitchPin);\n\n  // read the value of the pot and divide by 4 to get a value that can be\n  // used for PWM\n  motorSpeed = analogRead(potPin) / 4;\n\n  // if the on/off button changed state since the last loop()\n  if (onOffSwitchState != previousOnOffSwitchState) {\n    // change the value of motorEnabled if pressed\n    if (onOffSwitchState == HIGH) {\n      motorEnabled = !motorEnabled;\n    }\n  }\n\n  // if the direction button changed state since the last loop()\n  if (directionSwitchState != previousDirectionSwitchState) {\n    // change the value of motorDirection if pressed\n    if (directionSwitchState == HIGH) {\n      motorDirection = !motorDirection;\n    }\n  }\n\n  // change the direction the motor spins by talking to the control pins\n  // on the H-Bridge\n  if (motorDirection == 1) {\n    digitalWrite(controlPin1, HIGH);\n    digitalWrite(controlPin2, LOW);\n  } else {\n    digitalWrite(controlPin1, LOW);\n    digitalWrite(controlPin2, HIGH);\n  }\n\n  // if the motor is supposed to be on\n  if (motorEnabled == 1) {\n    // PWM the enable pin to vary the speed\n    analogWrite(enablePin, motorSpeed);\n  } else {\n    //turn the motor off\n    analogWrite(enablePin, 0);\n  }\n\n  // save the current on/off switch state as the previous\n  previousDirectionSwitchState = directionSwitchState;\n  // save the current switch state as the previous\n  previousOnOffSwitchState = onOffSwitchState;\n}\n" },
  { "name": "p11_CrystalBall.ino", "content": "// 10.StarterKit_BasicKit p11_CrystalBall\n\n// include the library code:\n#include <LiquidCrystal.h>\n\n// initialize the library with the numbers of the interface pins\nLiquidCrystal lcd(12, 11, 5, 4, 3, 2);\n\n// set up a constant for the tilt switch pin\nconst int switchPin = 6;\n\n// variable to hold the value of the switch pin\nint switchState = 0;\n// variable to hold previous value of the switch pin\nint prevSwitchState = 0;\n// a variable to choose which reply from the crystal ball\nint reply;\n\nvoid setup() {\n  // set up the number of columns and rows on the LCD\n  lcd.begin(16, 2);\n  // set up the switch pin as an input\n  pinMode(switchPin, INPUT);\n\n  // Print a message to the LCD.\n  lcd.print(\"Ask the\");\n  // set the cursor to column 0, line 1\n  lcd.setCursor(0, 1);\n  // print to the second line\n  lcd.print(\"Crystal Ball!\");\n}\n\nvoid loop() {\n  // check the status of the switch\n  switchState = digitalRead(switchPin);\n\n  // compare the switchState to its previous state\n  if (switchState != prevSwitchState) {\n    // if the state has changed from HIGH to LOW you know that the ball has been\n    // tilted from one direction to the other\n    if (switchState == LOW) {\n\n      // randomly chose a reply\n      reply = random(8);\n\n      // clean up the screen before printing a new reply\n      lcd.clear();\n\n      // set the cursor to column 0, line 0\n      lcd.setCursor(0, 0);\n\n      // print some text\n      lcd.print(\"the ball says:\");\n\n      // move the cursor to the second line\n      lcd.setCursor(0, 1);\n\n      // choose a saying to print based on the value in reply\n      switch (reply) {\n        case 0:\n          lcd.print(\"Yes\");\n          break;\n\n        case 1:\n          lcd.print(\"Most likely\");\n          break;\n\n        case 2:\n          lcd.print(\"Certainly\");\n          break;\n\n        case 3:\n          lcd.print(\"Outlook good\");\n          break;\n\n        case 4:\n          lcd.print(\"Unsure\");\n          break;\n\n        case 5:\n          lcd.print(\"Ask again\");\n          break;\n\n        case 6:\n          lcd.print(\"Doubtful\");\n          break;\n\n        case 7:\n          lcd.print(\"No\");\n          break;\n      }\n    }\n  }\n  // save the current switch state as the last state\n  prevSwitchState = switchState;\n}\n" },
  { "name": "p12_KnockLock.ino", "content": "// 10.StarterKit_BasicKit p12_KnockLock\n\n// import the library\n#include <Servo.h>\n// create an instance of the Servo library\nServo myServo;\n\nconst int piezo = A0;\nconst int switchPin = 2;\nconst int yellowLed = 3;\nconst int greenLed = 4;\nconst int redLed = 5;\n\n// variable for the piezo value\nint knockVal;\n// variable for the switch value\nint switchVal;\n\n// variables for the high and low limits of the knock value\nconst int quietKnock = 10;\nconst int loudKnock = 100;\n\n// variable to indicate if locked or not\nbool locked = false;\n// how many valid knocks you've received\nint numberOfKnocks = 0;\n\nvoid setup() {\n  // attach the servo to pin 9\n  myServo.attach(9);\n  // make the LED pins outputs\n  pinMode(yellowLed, OUTPUT);\n  pinMode(redLed, OUTPUT);\n  pinMode(greenLed, OUTPUT);\n  // set the switch pin as an input\n  pinMode(switchPin, INPUT);\n\n  // start serial communication for debugging\n  Serial.begin(9600);\n\n  // turn the green LED on\n  digitalWrite(greenLed, HIGH);\n\n  // move the servo to the unlocked position\n  myServo.write(0);\n\n  // print status to the Serial Monitor\n  Serial.println(\"the box is unlocked!\");\n}\n\nvoid loop() {\n\n  // if the box is unlocked\n  if (locked == false) {\n\n    // read the value of the switch pin\n    switchVal = digitalRead(switchPin);\n\n    // if the button is pressed, lock the box\n    if (switchVal == HIGH) {\n      // set the locked variable to \"true\"\n      locked = true;\n\n      // change the status LEDs\n      digitalWrite(greenLed, LOW);\n      digitalWrite(redLed, HIGH);\n\n      // move the servo to the locked position\n      myServo.write(90);\n\n      // print out status\n      Serial.println(\"the box is locked!\");\n\n      // wait for the servo to move into position\n      delay(1000);\n    }\n  }\n\n  // if the box is locked\n  if (locked == true) {\n\n    // check the value of the piezo\n    knockVal = analogRead(piezo);\n\n    // if there are not enough valid knocks\n    if (numberOfKnocks < 3 && knockVal > 0) {\n\n      // check to see if the knock is in range\n      if (checkForKnock(knockVal) == true) {\n\n        // increment the number of valid knocks\n        numberOfKnocks++;\n      }\n\n      // print status of knocks\n      Serial.print(3 - numberOfKnocks);\n      Serial.println(\" more knocks to go\");\n    }\n\n    // if there are three knocks\n    if (numberOfKnocks >= 3) {\n      // unlock the box\n      locked = false;\n\n      // move the servo to the unlocked position\n      myServo.write(0);\n\n      // wait for it to move\n      delay(20);\n\n      // change status LEDs\n      digitalWrite(greenLed, HIGH);\n      digitalWrite(redLed, LOW);\n      Serial.println(\"the box is unlocked!\");\n\n      numberOfKnocks = 0;\n    }\n  }\n}\n\n// this function checks to see if a detected knock is within max and min range\nbool checkForKnock(int value) {\n  // if the value of the knock is greater than the minimum, and larger\n  // than the maximum\n  if (value > quietKnock && value < loudKnock) {\n    // turn the status LED on\n    digitalWrite(yellowLed, HIGH);\n    delay(50);\n    digitalWrite(yellowLed, LOW);\n\n    // print out the status\n    Serial.print(\"Valid knock of value \");\n    Serial.println(value);\n\n    // return true\n    return true;\n  }\n  // if the knock is not within range\n  else {\n    // print status\n    Serial.print(\"Bad knock value \");\n    Serial.println(value);\n\n    // return false\n    return false;\n  }\n}\n" },
  { "name": "p13_TouchSensorLamp.ino", "content": "// 10.StarterKit_BasicKit p13_TouchSensorLamp\n\n// import the library (must be located in the Arduino/libraries directory)\n#include <CapacitiveSensor.h>\n\n// create an instance of the library\n// pin 4 sends electrical energy\n// pin 2 senses senses a change\nCapacitiveSensor capSensor = CapacitiveSensor(4, 2);\n\n// threshold for turning the lamp on\nint threshold = 1000;\n// pin the LED is connected to\nconst int ledPin = 12;\n\nvoid setup() {\n  // open a serial connection\n  Serial.begin(9600);\n  // set the LED pin as an output\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  // store the value reported by the sensor in a variable\n  long sensorValue = capSensor.capacitiveSensor(30);\n\n  // print out the sensor value\n  Serial.println(sensorValue);\n\n  // if the value is greater than the threshold\n  if (sensorValue > threshold) {\n    // turn the LED on\n    digitalWrite(ledPin, HIGH);\n  }\n  // if it's lower than the threshold\n  else {\n    // turn the LED off\n    digitalWrite(ledPin, LOW);\n  }\n\n  delay(10);\n}\n" },
  { "name": "p14_TweakTheArduinoLogo.ino", "content": "// 10.StarterKit_BasicKit p14_TweakTheArduinoLogo\n\nvoid setup() {\n  // initialize serial communication\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  // read the value of A0, divide by 4 and send it as a byte over the\n  // serial connection\n  Serial.write(analogRead(A0) / 4);\n  delay(1);\n}\n" },
  { "name": "p15_HackingButtons.ino", "content": "// 10.StarterKit_BasicKit p15_HackingButtons\n\nconst int optoPin = 2;\n\nvoid setup() {\n  // make the pin with the optocoupler an output\n  pinMode(optoPin, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(optoPin, HIGH);\n  delay(15);\n  digitalWrite(optoPin, LOW);\n  delay(10000);\n}\n" },
  { "name": "ArduinoISP.ino", "content": "// 11.ArduinoISP ArduinoISP.ino\n\n#include \"Arduino.h\"\n#undef SERIAL\n\n\n#define PROG_FLICKER true\n\n// Configure SPI clock (in Hz).\n#define SPI_CLOCK (1000000 / 6)\n\n\n// Select hardware or software SPI, depending on SPI clock.\n#if defined(ARDUINO_ARCH_AVR)\n\n#if SPI_CLOCK > (F_CPU / 128)\n#define USE_HARDWARE_SPI\n#endif\n\n#endif\n\n// Configure which pins to use:\n\n// The standard pin configuration.\n#ifndef ARDUINO_HOODLOADER2\n\n#define RESET 10\n#define LED_HB 9\n#define LED_ERR 8\n#define LED_PMODE 7\n\n#ifdef USE_OLD_STYLE_WIRING\n\n#define ARDUINOISP_PIN_MOSI 11\n#define ARDUINOISP_PIN_MISO 12\n#define ARDUINOISP_PIN_SCK 13\n\n#endif\n\n#else\n\n#define RESET 4\n#define LED_HB 7\n#define LED_ERR 6\n#define LED_PMODE 5\n\n#endif\n\n// By default, use hardware SPI pins:\n#ifndef ARDUINOISP_PIN_MOSI\n#define ARDUINOISP_PIN_MOSI MOSI\n#endif\n\n#ifndef ARDUINOISP_PIN_MISO\n#define ARDUINOISP_PIN_MISO MISO\n#endif\n\n#ifndef ARDUINOISP_PIN_SCK\n#define ARDUINOISP_PIN_SCK SCK\n#endif\n\n// Force bitbanged SPI if not using the hardware SPI pins:\n#if (ARDUINOISP_PIN_MISO != MISO) || (ARDUINOISP_PIN_MOSI != MOSI) || (ARDUINOISP_PIN_SCK != SCK)\n#undef USE_HARDWARE_SPI\n#endif\n\n\n// Configure the serial port to use.\n\n#ifdef SERIAL_PORT_USBVIRTUAL\n#define SERIAL SERIAL_PORT_USBVIRTUAL\n#else\n#define SERIAL Serial\n#endif\n\n\n// Configure the baud rate:\n\n#define BAUDRATE 19200\n\n\n#define HWVER 2\n#define SWMAJ 1\n#define SWMIN 18\n\n// STK Definitions\n#define STK_OK 0x10\n#define STK_FAILED 0x11\n#define STK_UNKNOWN 0x12\n#define STK_INSYNC 0x14\n#define STK_NOSYNC 0x15\n#define CRC_EOP 0x20\n\nvoid pulse(int pin, int times);\n\n#ifdef USE_HARDWARE_SPI\n#include \"SPI.h\"\n#else\n\n#if !defined(ARDUINO_API_VERSION) || ARDUINO_API_VERSION != 10001\nclass SPISettings {\npublic:\n  SPISettings(uint32_t clock, uint8_t bitOrder, uint8_t dataMode)\n    : clockFreq(clock) {\n    (void)bitOrder;\n    (void)dataMode;\n  };\n\n  uint32_t getClockFreq() const {\n    return clockFreq;\n  }\n\nprivate:\n  uint32_t clockFreq;\n};\n#endif\n\nclass BitBangedSPI {\npublic:\n  void begin() {\n    digitalWrite(ARDUINOISP_PIN_SCK, LOW);\n    digitalWrite(ARDUINOISP_PIN_MOSI, LOW);\n    pinMode(ARDUINOISP_PIN_SCK, OUTPUT);\n    pinMode(ARDUINOISP_PIN_MOSI, OUTPUT);\n    pinMode(ARDUINOISP_PIN_MISO, INPUT);\n  }\n\n  void beginTransaction(SPISettings settings) {\n    pulseWidth = (500000 + settings.getClockFreq() - 1) / settings.getClockFreq();\n    if (pulseWidth == 0) {\n      pulseWidth = 1;\n    }\n  }\n\n  void end() {}\n\n  uint8_t transfer(uint8_t b) {\n    for (unsigned int i = 0; i < 8; ++i) {\n      digitalWrite(ARDUINOISP_PIN_MOSI, (b & 0x80) ? HIGH : LOW);\n      digitalWrite(ARDUINOISP_PIN_SCK, HIGH);\n      delayMicroseconds(pulseWidth);\n      b = (b << 1) | digitalRead(ARDUINOISP_PIN_MISO);\n      digitalWrite(ARDUINOISP_PIN_SCK, LOW);\n      delayMicroseconds(pulseWidth);\n    }\n    return b;\n  }\n\nprivate:\n  unsigned long pulseWidth;\n};\n\nstatic BitBangedSPI SPI;\n\n#endif\n\nvoid setup() {\n  SERIAL.begin(BAUDRATE);\n\n  pinMode(LED_PMODE, OUTPUT);\n  pulse(LED_PMODE, 2);\n  pinMode(LED_ERR, OUTPUT);\n  pulse(LED_ERR, 2);\n  pinMode(LED_HB, OUTPUT);\n  pulse(LED_HB, 2);\n}\n\nint ISPError = 0;\nint pmode = 0;\nunsigned int here;\nuint8_t buff[256];\n\n#define beget16(addr) (*addr * 256 + *(addr + 1))\ntypedef struct param {\n  uint8_t devicecode;\n  uint8_t revision;\n  uint8_t progtype;\n  uint8_t parmode;\n  uint8_t polling;\n  uint8_t selftimed;\n  uint8_t lockbytes;\n  uint8_t fusebytes;\n  uint8_t flashpoll;\n  uint16_t eeprompoll;\n  uint16_t pagesize;\n  uint16_t eepromsize;\n  uint32_t flashsize;\n} parameter;\n\nparameter param;\n\nuint8_t hbval = 128;\nint8_t hbdelta = 8;\nvoid heartbeat() {\n  static unsigned long last_time = 0;\n  unsigned long now = millis();\n  if ((now - last_time) < 40) {\n    return;\n  }\n  last_time = now;\n  if (hbval > 192) {\n    hbdelta = -hbdelta;\n  }\n  if (hbval < 32) {\n    hbdelta = -hbdelta;\n  }\n  hbval += hbdelta;\n  analogWrite(LED_HB, hbval);\n}\n\nstatic bool rst_active_high;\n\nvoid reset_target(bool reset) {\n  digitalWrite(RESET, ((reset && rst_active_high) || (!reset && !rst_active_high)) ? HIGH : LOW);\n}\n\nvoid loop(void) {\n  // is pmode active?\n  if (pmode) {\n    digitalWrite(LED_PMODE, HIGH);\n  }\n  else {\n    digitalWrite(LED_PMODE, LOW);\n  }\n  // is there an error?\n  if (ISPError) {\n    digitalWrite(LED_ERR, HIGH);\n  }\n  else {\n    digitalWrite(LED_ERR, LOW);\n  }\n\n  // light the heartbeat LED\n  heartbeat();\n  if (SERIAL.available()) {\n    avrisp();\n  }\n}\n\nuint8_t getch() {\n  while (!SERIAL.available())\n    ;\n  return SERIAL.read();\n}\nvoid fill(int n) {\n  for (int x = 0; x < n; x++) {\n    buff[x] = getch();\n  }\n}\n\n#define PTIME 30\nvoid pulse(int pin, int times) {\n  do {\n    digitalWrite(pin, HIGH);\n    delay(PTIME);\n    digitalWrite(pin, LOW);\n    delay(PTIME);\n  } while (times--);\n}\n\nvoid prog_lamp(int state) {\n  if (PROG_FLICKER) {\n    digitalWrite(LED_PMODE, state);\n  }\n}\n\nuint8_t spi_transaction(uint8_t a, uint8_t b, uint8_t c, uint8_t d) {\n  SPI.transfer(a);\n  SPI.transfer(b);\n  SPI.transfer(c);\n  return SPI.transfer(d);\n}\n\nvoid empty_reply() {\n  if (CRC_EOP == getch()) {\n    SERIAL.print((char)STK_INSYNC);\n    SERIAL.print((char)STK_OK);\n  }\n  else {\n    ISPError++;\n    SERIAL.print((char)STK_NOSYNC);\n  }\n}\n\nvoid breply(uint8_t b) {\n  if (CRC_EOP == getch()) {\n    SERIAL.print((char)STK_INSYNC);\n    SERIAL.print((char)b);\n    SERIAL.print((char)STK_OK);\n  }\n  else {\n    ISPError++;\n    SERIAL.print((char)STK_NOSYNC);\n  }\n}\n\nvoid get_version(uint8_t c) {\n  switch (c) {\n    case 0x80:\n      breply(HWVER);\n      break;\n    case 0x81:\n      breply(SWMAJ);\n      break;\n    case 0x82:\n      breply(SWMIN);\n      break;\n    case 0x93:\n      breply('S');\n      break;\n    default:\n      breply(0);\n  }\n}\n\nvoid set_parameters() {\n  param.devicecode = buff[0];\n  param.revision = buff[1];\n  param.progtype = buff[2];\n  param.parmode = buff[3];\n  param.polling = buff[4];\n  param.selftimed = buff[5];\n  param.lockbytes = buff[6];\n  param.fusebytes = buff[7];\n  param.flashpoll = buff[8];\n  param.eeprompoll = beget16(&buff[10]);\n  param.pagesize = beget16(&buff[12]);\n  param.eepromsize = beget16(&buff[14]);\n\n  param.flashsize = buff[16] * 0x01000000\n                    + buff[17] * 0x00010000\n                    + buff[18] * 0x00000100\n                    + buff[19];\n  rst_active_high = (param.devicecode >= 0xe0);\n}\n\nvoid start_pmode() {\n\n  \n  reset_target(true);\n  pinMode(RESET, OUTPUT);\n  SPI.begin();\n  SPI.beginTransaction(SPISettings(SPI_CLOCK, MSBFIRST, SPI_MODE0));\n\n  \n  digitalWrite(ARDUINOISP_PIN_SCK, LOW);\n  delay(20);\n  reset_target(false);\n  delayMicroseconds(100);\n  reset_target(true);\n\n  \n  delay(50);\n  spi_transaction(0xAC, 0x53, 0x00, 0x00);\n  pmode = 1;\n}\n\nvoid end_pmode() {\n  SPI.end();\n  pinMode(ARDUINOISP_PIN_MOSI, INPUT);\n  pinMode(ARDUINOISP_PIN_SCK, INPUT);\n  reset_target(false);\n  pinMode(RESET, INPUT);\n  pmode = 0;\n}\n\nvoid universal() {\n  uint8_t ch;\n\n  fill(4);\n  ch = spi_transaction(buff[0], buff[1], buff[2], buff[3]);\n  breply(ch);\n}\n\nvoid flash(uint8_t hilo, unsigned int addr, uint8_t data) {\n  spi_transaction(0x40 + 8 * hilo,\n                  addr >> 8 & 0xFF,\n                  addr & 0xFF,\n                  data);\n}\nvoid commit(unsigned int addr) {\n  if (PROG_FLICKER) {\n    prog_lamp(LOW);\n  }\n  spi_transaction(0x4C, (addr >> 8) & 0xFF, addr & 0xFF, 0);\n  if (PROG_FLICKER) {\n    delay(PTIME);\n    prog_lamp(HIGH);\n  }\n}\n\nunsigned int current_page() {\n  if (param.pagesize == 32) {\n    return here & 0xFFFFFFF0;\n  }\n  if (param.pagesize == 64) {\n    return here & 0xFFFFFFE0;\n  }\n  if (param.pagesize == 128) {\n    return here & 0xFFFFFFC0;\n  }\n  if (param.pagesize == 256) {\n    return here & 0xFFFFFF80;\n  }\n  return here;\n}\n\n\nvoid write_flash(int length) {\n  fill(length);\n  if (CRC_EOP == getch()) {\n    SERIAL.print((char)STK_INSYNC);\n    SERIAL.print((char)write_flash_pages(length));\n  }\n  else {\n    ISPError++;\n    SERIAL.print((char)STK_NOSYNC);\n  }\n}\n\nuint8_t write_flash_pages(int length) {\n  int x = 0;\n  unsigned int page = current_page();\n  while (x < length) {\n    if (page != current_page()) {\n      commit(page);\n      page = current_page();\n    }\n    flash(LOW, here, buff[x++]);\n    flash(HIGH, here, buff[x++]);\n    here++;\n  }\n\n  commit(page);\n\n  return STK_OK;\n}\n\n#define EECHUNK (32)\nuint8_t write_eeprom(unsigned int length) {\n  \n  unsigned int start = here * 2;\n  unsigned int remaining = length;\n  if (length > param.eepromsize) {\n    ISPError++;\n    return STK_FAILED;\n  }\n  while (remaining > EECHUNK) {\n    write_eeprom_chunk(start, EECHUNK);\n    start += EECHUNK;\n    remaining -= EECHUNK;\n  }\n  write_eeprom_chunk(start, remaining);\n  return STK_OK;\n}\n\nuint8_t write_eeprom_chunk(unsigned int start, unsigned int length) {\n  \n  fill(length);\n  prog_lamp(LOW);\n  for (unsigned int x = 0; x < length; x++) {\n    unsigned int addr = start + x;\n    spi_transaction(0xC0, (addr >> 8) & 0xFF, addr & 0xFF, buff[x]);\n    delay(45);\n  }\n  prog_lamp(HIGH);\n  return STK_OK;\n}\n\nvoid program_page() {\n  char result = (char)STK_FAILED;\n  unsigned int length = 256 * getch();\n  length += getch();\n  char memtype = getch();\n  \n  if (memtype == 'F') {\n    write_flash(length);\n    return;\n  }\n  if (memtype == 'E') {\n    result = (char)write_eeprom(length);\n    if (CRC_EOP == getch()) {\n      SERIAL.print((char)STK_INSYNC);\n      SERIAL.print(result);\n    }\n    else {\n      ISPError++;\n      SERIAL.print((char)STK_NOSYNC);\n    }\n    return;\n  }\n  SERIAL.print((char)STK_FAILED);\n  return;\n}\n\nuint8_t flash_read(uint8_t hilo, unsigned int addr) {\n  return spi_transaction(0x20 + hilo * 8,\n                         (addr >> 8) & 0xFF,\n                         addr & 0xFF,\n                         0);\n}\n\nchar flash_read_page(int length) {\n  for (int x = 0; x < length; x += 2) {\n    uint8_t low = flash_read(LOW, here);\n    SERIAL.print((char)low);\n    uint8_t high = flash_read(HIGH, here);\n    SERIAL.print((char)high);\n    here++;\n  }\n  return STK_OK;\n}\n\nchar eeprom_read_page(int length) {\n  \n  int start = here * 2;\n  for (int x = 0; x < length; x++) {\n    int addr = start + x;\n    uint8_t ee = spi_transaction(0xA0, (addr >> 8) & 0xFF, addr & 0xFF, 0xFF);\n    SERIAL.print((char)ee);\n  }\n  return STK_OK;\n}\n\nvoid read_page() {\n  char result = (char)STK_FAILED;\n  unsigned int length = 256 * getch();\n  length += getch();\n  char memtype = getch();\n  \n  if (memtype == 'F') {\n    SERIAL.print((char)STK_INSYNC);\n    SERIAL.print((char)flash_read_page(length));\n  }\n  else if (memtype == 'E') {\n    SERIAL.print((char)STK_INSYNC);\n    SERIAL.print((char)eeprom_read_page(length));\n  }\n  else {\n    SERIAL.print((char)STK_FAILED);\n  }\n}\n\nvoid read_signature() {\n  if (CRC_EOP != getch()) {\n    ISPError++;\n    SERIAL.print((char)STK_NOSYNC);\n    return;\n  }\n  SERIAL.print((char)STK_INSYNC);\n  uint8_t high = spi_transaction(0x30, 0x00, 0x00, 0x00);\n  SERIAL.print((char)high);\n  uint8_t middle = spi_transaction(0x30, 0x00, 0x01, 0x00);\n  SERIAL.print((char)middle);\n  uint8_t low = spi_transaction(0x30, 0x00, 0x02, 0x00);\n  SERIAL.print((char)low);\n  SERIAL.print((char)STK_OK);\n}\n\nvoid avrisp() {\n  uint8_t ch = getch();\n  switch (ch) {\n    case '0':\n      ISPError = 0;\n      empty_reply();\n      break;\n    case '1':\n      if (getch() == CRC_EOP) {\n        SERIAL.print((char)STK_INSYNC);\n        SERIAL.print(\"AVR ISP\");\n        SERIAL.print((char)STK_OK);\n      }\n      else {\n        ISPError++;\n        SERIAL.print((char)STK_NOSYNC);\n      }\n      break;\n    case 'A':\n      get_version(getch());\n      break;\n    case 'B':\n      fill(20);\n      set_parameters();\n      empty_reply();\n      break;\n    case 'E':\n      fill(5);\n      empty_reply();\n      break;\n    case 'P':\n      if (!pmode) {\n        start_pmode();\n      }\n      empty_reply();\n      break;\n    case 'U':\n      here = getch();\n      here += 256 * getch();\n      empty_reply();\n      break;\n\n    case 0x60:\n      getch();\n      getch();\n      empty_reply();\n      break;\n    case 0x61:\n      getch();\n      empty_reply();\n      break;\n    case 0x64:\n      program_page();\n      break;\n    case 0x74:\n      read_page();\n      break;\n    case 'V':\n      universal();\n      break;\n    case 'Q':\n      ISPError = 0;\n      end_pmode();\n      empty_reply();\n      break;\n    case 0x75:\n      read_signature();\n      break;\n    case CRC_EOP:\n      ISPError++;\n      SERIAL.print((char)STK_NOSYNC);\n      break;\n\n    default:\n      ISPError++;\n      if (CRC_EOP == getch()) {\n        SERIAL.print((char)STK_UNKNOWN);\n      }\n      else {\n        SERIAL.print((char)STK_NOSYNC);\n      }\n  }\n}\n" }
];

// --- Examples Harness Runner Logic ---
// This function runs the parser against all 79 examples.

function runExamples() {
    const logElement = document.getElementById('log');
    let fullLog = '';
    let testsPassed = 0;
    
    const timestamp = new Date().toLocaleString();
    fullLog += `Parser Version: ${PARSER_VERSION} | Test run at: ${timestamp}\n\n`;

    examplesFiles.forEach(testFile => {
        fullLog += `--- Running: ${testFile.name} ---\n`;
        
        try {
            const ast = parse(testFile.content);
            
            // Properly check for ErrorNodes anywhere in the AST tree
            function hasErrors(node) {
                if (!node || typeof node !== 'object') return false;
                if (node.type === 'ErrorNode') return true;
                
                for (const key in node) {
                    if (typeof node[key] === 'object' && node[key] !== null) {
                        if (Array.isArray(node[key])) {
                            for (const item of node[key]) {
                                if (hasErrors(item)) return true;
                            }
                        } else {
                            if (hasErrors(node[key])) return true;
                        }
                    }
                }
                return false;
            }
            
            function collectErrors(node, errors = []) {
                if (!node || typeof node !== 'object') return errors;
                if (node.type === 'ErrorNode') {
                    errors.push(node.value || 'Unknown error');
                    return errors;
                }
                
                for (const key in node) {
                    if (typeof node[key] === 'object' && node[key] !== null) {
                        if (Array.isArray(node[key])) {
                            for (const item of node[key]) {
                                collectErrors(item, errors);
                            }
                        } else {
                            collectErrors(node[key], errors);
                        }
                    }
                }
                return errors;
            }
            
            if (hasErrors(ast)) {
                const errors = collectErrors(ast);
                throw new Error(`ErrorNodes found in AST: ${errors.slice(0, 3).join('; ')}`);
            }
            
            fullLog += `<span class="success">[SUCCESS]</span> Parsed successfully.\n`;
            fullLog += `--- Abstract Syntax Tree ---\n`;
            fullLog += prettyPrintAST(ast);
            fullLog += `--- End of AST ---\n\n`;
            testsPassed++;
        } catch (error) {
            fullLog += `<span class="failure">[FAILURE]</span> ${error.name}: ${error.message}\n\n`;
        }
    });

    fullLog += `--- Test Summary ---\n`;
    fullLog += `${testsPassed} / ${examplesFiles.length} examples parsed successfully.\n`;
    logElement.innerHTML = fullLog;
}

// Universal export for Node.js and browser compatibility
if (typeof window !== 'undefined') {
    // Browser environment
    window.examplesFiles = examplesFiles;
    window.runExamples = runExamples;
    
    // Run the tests automatically when the page loads
    window.onload = runExamples;
} else if (typeof module !== 'undefined' && module.exports) {
    // Node.js environment
    module.exports = {
        examplesFiles,
        runExamples
    };
}

