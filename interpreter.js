const INTERPRETER_VERSION="6.3.0";const COMMAND_TYPES={PIN_MODE:'PIN_MODE',DIGITAL_WRITE:'DIGITAL_WRITE',DIGITAL_READ:'DIGITAL_READ',ANALOG_WRITE:'ANALOG_WRITE',ANALOG_READ:'ANALOG_READ',ANALOG_READ_REQUEST:'ANALOG_READ_REQUEST',DIGITAL_READ_REQUEST:'DIGITAL_READ_REQUEST',MILLIS_REQUEST:'MILLIS_REQUEST',MICROS_REQUEST:'MICROS_REQUEST',LIBRARY_METHOD_REQUEST:'LIBRARY_METHOD_REQUEST',DELAY:'DELAY',DELAY_MICROSECONDS:'DELAY_MICROSECONDS',VAR_SET:'VAR_SET',VAR_GET:'VAR_GET',FUNCTION_CALL:'FUNCTION_CALL',FUNCTION_CALL_WITH_ARGS:'FUNCTION_CALL_WITH_ARGS',LOOP_START:'LOOP_START',LOOP_END:'LOOP_END',LOOP_LIMIT_REACHED:'LOOP_LIMIT_REACHED',CONDITION_EVAL:'CONDITION_EVAL',CONSTRUCTOR_CALL:'CONSTRUCTOR_CALL',IF_STATEMENT:'IF_STATEMENT',SWITCH_STATEMENT:'SWITCH_STATEMENT',SWITCH_CASE:'SWITCH_CASE',FOR_LOOP:'FOR_LOOP',WHILE_LOOP:'WHILE_LOOP',DO_WHILE_LOOP:'DO_WHILE_LOOP',BREAK_STATEMENT:'BREAK_STATEMENT',CONTINUE_STATEMENT:'CONTINUE_STATEMENT',SETUP_START:'SETUP_START',SETUP_END:'SETUP_END',PROGRAM_START:'PROGRAM_START',PROGRAM_END:'PROGRAM_END',VERSION_INFO:'VERSION_INFO',ERROR:'ERROR'};const EXECUTION_STATE={IDLE:'IDLE',RUNNING:'RUNNING',PAUSED:'PAUSED',STEPPING:'STEPPING',ERROR:'ERROR',COMPLETE:'COMPLETE'};const PIN_MODES={INPUT:'INPUT',OUTPUT:'OUTPUT',INPUT_PULLUP:'INPUT_PULLUP',INPUT_PULLDOWN:'INPUT_PULLDOWN',OUTPUT_OPENDRAIN:'OUTPUT_OPENDRAIN'};const DIGITAL_VALUES={HIGH:1,LOW:0};const KEYBOARD_KEYS={KEY_LEFT_CTRL:0x80,KEY_LEFT_SHIFT:0x81,KEY_LEFT_ALT:0x82,KEY_LEFT_GUI:0x83,KEY_RIGHT_CTRL:0x84,KEY_RIGHT_SHIFT:0x85,KEY_RIGHT_ALT:0x86,KEY_RIGHT_GUI:0x87,KEY_UP_ARROW:0xDA,KEY_DOWN_ARROW:0xD9,KEY_LEFT_ARROW:0xD8,KEY_RIGHT_ARROW:0xD7,KEY_BACKSPACE:0xB2,KEY_TAB:0xB3,KEY_RETURN:0xB0,KEY_ESC:0xB1,KEY_INSERT:0xD1,KEY_DELETE:0xD4,KEY_PAGE_UP:0xD3,KEY_PAGE_DOWN:0xD6,KEY_HOME:0xD2,KEY_END:0xD5,KEY_CAPS_LOCK:0xC1,KEY_F1:0xC2,KEY_F2:0xC3,KEY_F3:0xC4,KEY_F4:0xC5,KEY_F5:0xC6,KEY_F6:0xC7,KEY_F7:0xC8,KEY_F8:0xC9,KEY_F9:0xCA,KEY_F10:0xCB,KEY_F11:0xCC,KEY_F12:0xCD};class ArduinoObject{constructor(className,constructorArgs=[],interpreter=null){this.className=className;this.constructorArgs=constructorArgs;this.libraryInfo=ARDUINO_LIBRARIES[className];this.interpreter=interpreter;this.objectId=`${className}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`}
callMethod(methodName,args=[],variableName=null){if(!this.libraryInfo){throw new Error(`Unknown library: ${this.className}`)}
if(this.libraryInfo.internalMethods&&this.libraryInfo.internalMethods[methodName]){const internalMethod=this.libraryInfo.internalMethods[methodName];const result=internalMethod(this,...args);if(this.interpreter){this.interpreter.emitCommand({type:'LIBRARY_METHOD_INTERNAL',library:this.className,method:methodName,args:args,result:result,variableName:variableName,timestamp:Date.now()})}
return result}
if(this.libraryInfo.staticMethods&&this.libraryInfo.staticMethods.includes(methodName)){const result=this.calculateStaticMethod(methodName,args);if(result!==null){this.emitCalculableCommand(methodName,args,result,variableName);return result}}
if(this.libraryInfo.externalMethods&&this.libraryInfo.externalMethods.includes(methodName)){const displayName=variableName||this.className;const command={type:'LIBRARY_METHOD_CALL',library:this.className,object:this.objectId,variableName:variableName,method:methodName,args:args,message:`${displayName}.${methodName}(${args.join(', ')})`};if(this.interpreter){this.interpreter.emitCommand({...command,timestamp:Date.now()})}
return null}
if(this.libraryInfo.methods&&this.libraryInfo.methods.includes(methodName)){if(this.isExternalDataMethod(methodName)){return this.requestExternalData(methodName,args)}
const command={type:'LIBRARY_METHOD_CALL',library:this.className,object:this.objectId,method:methodName,args:args,message:`${this.className}.${methodName}(${args.join(', ')})`};if(this.interpreter){this.interpreter.emitCommand({...command,timestamp:Date.now()})}
return null}
throw new Error(`Unknown method ${this.className}.${methodName}`)}
calculateStaticMethod(methodName,args){switch(`${this.className}.${methodName}`){case 'Adafruit_NeoPixel.Color':const r=args[0]||0,g=args[1]||0,b=args[2]||0;return(r<<16)|(g<<8)|b;case 'Adafruit_NeoPixel.ColorHSV':return this.calculateHSVtoRGB(args[0],args[1],args[2]);case 'Adafruit_NeoPixel.gamma32':return this.applyGammaCorrection(args[0]);case 'Adafruit_NeoPixel.sine8':return Math.floor(Math.sin((args[0]||0)*Math.PI/128)*127+128);default:return null}}
async requestExternalData(methodName,args){if(!this.interpreter){throw new Error('Cannot request external data: no interpreter reference')}
const requestId=`${this.className}_${methodName}_${Date.now()}_${Math.random()}`;this.interpreter.emitCommand({type:'LIBRARY_METHOD_REQUEST',library:this.className,object:this.objectId,method:methodName,args:args,requestId:requestId,timestamp:Date.now()});try{const response=await this.interpreter.waitForResponse(requestId,5000);return response.value}catch(error){switch(methodName){case 'numPixels':return this.constructorArgs[0]||60;case 'getBrightness':return 255;case 'getPixelColor':return 0;case 'canShow':return!0;default:return 0}}}
isExternalDataMethod(methodName){const externalMethods=['numPixels','getBrightness','getPixelColor','canShow'];return externalMethods.includes(methodName)}
emitCalculableCommand(methodName,args,result,variableName=null){if(this.interpreter){this.interpreter.emitCommand({type:'LIBRARY_METHOD_INTERNAL',library:this.className,method:methodName,args:args,result:result,variableName:variableName,timestamp:Date.now()})}}
calculateHSVtoRGB(h,s,v){h=(h||0)%65536;s=Math.max(0,Math.min(255,s||255));v=Math.max(0,Math.min(255,v||255));const region=h/10923;const remainder=(h-(Math.floor(region)*10923))*6;const p=(v*(255-s))>>8;const q=(v*(255-((s*remainder)>>16)))>>8;const t=(v*(255-((s*(65536-remainder))>>16)))>>8;switch(Math.floor(region)){case 0:return(v<<16)|(t<<8)|p;case 1:return(q<<16)|(v<<8)|p;case 2:return(p<<16)|(v<<8)|t;case 3:return(p<<16)|(q<<8)|v;case 4:return(t<<16)|(p<<8)|v;default:return(v<<16)|(p<<8)|q}}
applyGammaCorrection(color){const r=(color>>16)&0xFF;const g=(color>>8)&0xFF;const b=color&0xFF;const correctedR=Math.floor(Math.pow(r/255.0,2.2)*255);const correctedG=Math.floor(Math.pow(g/255.0,2.2)*255);const correctedB=Math.floor(Math.pow(b/255.0,2.2)*255);return(correctedR<<16)|(correctedG<<8)|correctedB}
getProperty(name){switch(name){case 'numPixels':return this.constructorArgs[0]||0;case 'pin':return this.constructorArgs[1]||0;case 'brightness':return 255;default:return null}}
setProperty(name,value){return{type:'LIBRARY_PROPERTY_SET',library:this.className,object:this.objectId,property:name,value:this.interpreter?this.interpreter.sanitizeForCommand(value):value,message:`${this.className}.${name} = ${value}`}}}
class ArduinoPointer{constructor(targetVariable,interpreter){this.targetVariable=targetVariable;this.interpreter=interpreter;this.type='pointer';this.pointerId=`ptr_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`}
getValue(){if(!this.interpreter.variables.has(this.targetVariable)){throw new Error(`Pointer target variable '${this.targetVariable}' no longer exists`)}
const targetValue=this.interpreter.variables.get(this.targetVariable);if(Array.isArray(targetValue)){return targetValue[0]}
return targetValue}
setValue(newValue){const result=this.interpreter.variables.set(this.targetVariable,newValue);if(!result.success){throw new Error(result.message||`Failed to set value through pointer to '${this.targetVariable}'`)}
this.interpreter.variables.markAsInitialized(this.targetVariable);this.interpreter.emitCommand({type:'POINTER_ASSIGNMENT',pointer:this.pointerId,targetVariable:this.targetVariable,value:this.interpreter.sanitizeForCommand(newValue),timestamp:Date.now(),message:`*${this.targetVariable} = ${newValue}`});return newValue}
isValid(){return this.interpreter.variables.has(this.targetVariable)}
toString(){return `ArduinoPointer(${this.pointerId} -> ${this.targetVariable})`}
add(offset){return new ArduinoOffsetPointer(this.targetVariable,offset,this.interpreter)}
subtract(offset){return this.add(-offset)}}
class ArduinoFunctionPointer{constructor(functionName,interpreter){this.functionName=functionName;this.interpreter=interpreter;this.type='function_pointer';this.pointerId=`fptr_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`}
async call(args=[]){if(!this.interpreter.functions.has(this.functionName)){throw new Error(`Function pointer target '${this.functionName}' no longer exists`)}
if(this.interpreter.options.verbose){console.log(`Function pointer call: ${this.functionName}(${args.length} args)`)}
const syntheticNode={type:'FuncCallNode',callee:{type:'IdentifierNode',value:this.functionName},arguments:args.map(arg=>{if(typeof arg==='number'){return{type:'NumberNode',value:arg}}else if(typeof arg==='string'){return{type:'StringLiteralNode',value:arg}}else if(typeof arg==='boolean'){return{type:'BooleanNode',value:arg}}else{return{type:'LiteralNode',value:arg}}})};return await this.interpreter.executeFunctionCall(syntheticNode)}
isValid(){return this.interpreter.functions.has(this.functionName)}
toString(){return `ArduinoFunctionPointer(${this.pointerId} -> ${this.functionName})`}}
class ArduinoOffsetPointer extends ArduinoPointer{constructor(baseVariable,offset,interpreter){super(baseVariable,interpreter);this.offset=offset;this.type='offset_pointer'}
getValue(){const baseValue=this.interpreter.variables.get(this.targetVariable);if(Array.isArray(baseValue)){const index=this.offset;if(index>=0&&index<baseValue.length){return baseValue[index]}else{throw new Error(`Array index ${index} out of bounds for array ${this.targetVariable}`)}}else{throw new Error(`Pointer arithmetic on non-array variable '${this.targetVariable}' not supported`)}}
setValue(newValue){const baseValue=this.interpreter.variables.get(this.targetVariable);if(Array.isArray(baseValue)){const index=this.offset;if(index>=0&&index<baseValue.length){baseValue[index]=newValue;const result=this.interpreter.variables.set(this.targetVariable,baseValue);if(!result.success){throw new Error(result.message)}
this.interpreter.emitCommand({type:'ARRAY_ELEMENT_SET',array:this.targetVariable,index:index,value:this.interpreter.sanitizeForCommand(newValue),timestamp:Date.now(),message:`${this.targetVariable}[${index}] = ${newValue}`});return newValue}else{throw new Error(`Array index ${index} out of bounds for array ${this.targetVariable}`)}}else{throw new Error(`Pointer arithmetic assignment on non-array variable '${this.targetVariable}' not supported`)}}
add(additionalOffset){const newOffset=this.offset+additionalOffset;return new ArduinoOffsetPointer(this.targetVariable,newOffset,this.interpreter)}
subtract(additionalOffset){const newOffset=this.offset-additionalOffset;return new ArduinoOffsetPointer(this.targetVariable,newOffset,this.interpreter)}
toString(){return `ArduinoOffsetPointer(${this.pointerId} -> ${this.targetVariable} + ${this.offset})`}}
class ArduinoStruct{constructor(structName,fields={}){this.structName=structName;this.fields=new Map();this.type='struct';for(const[fieldName,fieldType]of Object.entries(fields)){this.fields.set(fieldName,this.getDefaultValue(fieldType))}
this.structId=`struct_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`}
getDefaultValue(fieldType){switch(fieldType){case 'int':case 'float':case 'double':case 'long':case 'short':case 'byte':return 0;case 'char':return'\0';case 'bool':return!1;case 'String':return new ArduinoString("");default:return null}}
getField(fieldName){if(!this.fields.has(fieldName)){throw new Error(`Struct '${this.structName}' has no field '${fieldName}'`)}
return this.fields.get(fieldName)}
setField(fieldName,value){if(!this.fields.has(fieldName)){throw new Error(`Struct '${this.structName}' has no field '${fieldName}'`)}
this.fields.set(fieldName,value);return value}
hasField(fieldName){return this.fields.has(fieldName)}
getFieldNames(){return Array.from(this.fields.keys())}
toString(){const fieldList=Array.from(this.fields.entries()).map(([name,value])=>`${name}: ${value}`).join(', ');return `ArduinoStruct(${this.structName} { ${fieldList} })`}
clone(){const newStruct=new ArduinoStruct(this.structName);for(const[fieldName,value]of this.fields.entries()){newStruct.fields.set(fieldName,value)}
return newStruct}}
class ArduinoString{constructor(value=""){this.value=String(value)}
length(){return this.value.length}
charAt(index){return this.value.charAt(index)}
substring(start,end){return new ArduinoString(this.value.substring(start,end))}
indexOf(searchString){return this.value.indexOf(searchString)}
equals(other){const otherValue=other instanceof ArduinoString?other.value:String(other);return this.value===otherValue}
toInt(){return parseInt(this.value)||0}
toFloat(){return parseFloat(this.value)||0.0}
toString(){return this.value}
valueOf(){return this.value}
concat(other){const otherValue=other instanceof ArduinoString?other.value:String(other);return new ArduinoString(this.value+otherValue)}
setCharAt(index,char){if(index>=0&&index<this.value.length){const charStr=String(char).charAt(0);this.value=this.value.substring(0,index)+charStr+this.value.substring(index+1)}}
replace(find,replace){const findStr=find instanceof ArduinoString?find.value:String(find);const replaceStr=replace instanceof ArduinoString?replace.value:String(replace);this.value=this.value.split(findStr).join(replaceStr)}
trim(){this.value=this.value.trim()}
toUpperCase(){this.value=this.value.toUpperCase()}
toLowerCase(){this.value=this.value.toLowerCase()}
compareTo(other){const otherValue=other instanceof ArduinoString?other.value:String(other);if(this.value<otherValue)return-1;if(this.value>otherValue)return 1;return 0}
equalsIgnoreCase(other){const otherValue=other instanceof ArduinoString?other.value:String(other);return this.value.toLowerCase()===otherValue.toLowerCase()}
startsWith(prefix,offset=0){const prefixStr=prefix instanceof ArduinoString?prefix.value:String(prefix);return this.value.startsWith(prefixStr,offset)}
endsWith(suffix){const suffixStr=suffix instanceof ArduinoString?suffix.value:String(suffix);return this.value.endsWith(suffixStr)}
reserve(size){return}
static create(value,format=null){if(typeof value==='number'&&format!==null){return new ArduinoString(value.toFixed(format))}
return new ArduinoString(value)}}
class ArduinoNumber{constructor(value,arduinoType='int'){this.value=Number(value);this.arduinoType=arduinoType}
valueOf(){return this.value}
toString(){return String(this.value)}
toJSON(){return this.value}
static getValue(value){if(value instanceof ArduinoNumber)return value.value;if(typeof value==='number')return value;return Number(value)}}
class ArduinoVector{constructor(elementType,constructorArgs=[]){this.elementType=elementType;this.data=[];this.capacity=0;if(constructorArgs.length>0){const size=constructorArgs[0];if(typeof size==='number'&&size>=0){this.data=new Array(size).fill(null)}}}
push_back(element){this.data.push(element);return this.data.length}
pop_back(){return this.data.pop()}
size(){return this.data.length}
empty(){return this.data.length===0}
clear(){this.data=[]}
at(index){if(index<0||index>=this.data.length){throw new Error(`vector index ${index} out of range`)}
return this.data[index]}
get(index){return this.data[index]}
set(index,value){this.data[index]=value}
front(){return this.data[0]}
back(){return this.data[this.data.length-1]}
capacity(){return this.capacity}
toString(){return `vector<${this.elementType}>[${this.data.join(', ')}]`}}
class ArduinoStdString{constructor(constructorArgs=[]){this.value=constructorArgs.length>0?String(constructorArgs[0]):""}
length(){return this.value.length}
size(){return this.value.length}
empty(){return this.value.length===0}
clear(){this.value=""}
c_str(){return this.value}
toString(){return this.value}}
class ArduinoArray{constructor(elementType,arraySize,constructorArgs=[]){this.elementType=elementType;this.arraySize=arraySize;this.data=new Array(arraySize).fill(null)}
at(index){if(index<0||index>=this.arraySize){throw new Error(`array index ${index} out of range`)}
return this.data[index]}
size(){return this.arraySize}
toString(){return `array<${this.elementType}, ${this.arraySize}>[${this.data.join(', ')}]`}}
class ArduinoLibraryObject{constructor(libraryName,constructorArgs=[]){this.libraryName=libraryName;this.constructorArgs=constructorArgs;this.type='library_object';this.objectId=`${libraryName}_${Date.now()}_${Math.random().toString(36).substr(2, 4)}`;this.initialized=!0;this.properties=new Map();this.initializeLibraryProperties()}
initializeLibraryProperties(){switch(this.libraryName){case 'CapacitiveSensor':this.properties.set('sendPin',this.constructorArgs[0]||4);this.properties.set('receivePin',this.constructorArgs[1]||2);this.properties.set('timeout',2000);break;case 'Servo':this.properties.set('pin',this.constructorArgs[0]||9);this.properties.set('angle',0);break;case 'LiquidCrystal':this.properties.set('rs',this.constructorArgs[0]||12);this.properties.set('enable',this.constructorArgs[1]||11);break;default:break}}
callMethod(methodName,args=[]){switch(this.libraryName){case 'CapacitiveSensor':return this.callCapacitiveSensorMethod(methodName,args);case 'Servo':return this.callServoMethod(methodName,args);case 'LiquidCrystal':return this.callLiquidCrystalMethod(methodName,args);default:return this.callGenericLibraryMethod(methodName,args)}}
callCapacitiveSensorMethod(methodName,args){switch(methodName){case 'capacitiveSensor':case 'capacitiveSensorRaw':const samples=args[0]||30;return Math.floor(Math.random()*2000)+100;case 'set_CS_Timeout_Millis':this.properties.set('timeout',args[0]||2000);return;default:return null}}
callServoMethod(methodName,args){switch(methodName){case 'attach':this.properties.set('pin',args[0]||9);return;case 'write':this.properties.set('angle',args[0]||0);return;case 'read':return this.properties.get('angle')||0;case 'detach':this.properties.set('attached',!1);return;default:return null}}
callLiquidCrystalMethod(methodName,args){switch(methodName){case 'begin':this.properties.set('cols',args[0]||16);this.properties.set('rows',args[1]||2);return;case 'print':case 'write':return;case 'setCursor':this.properties.set('cursor_col',args[0]||0);this.properties.set('cursor_row',args[1]||0);return;case 'clear':return;default:return null}}
callGenericLibraryMethod(methodName,args){if(methodName.includes('read')||methodName.includes('get')){return Math.floor(Math.random()*1000)}else if(methodName.includes('begin')||methodName.includes('init')){return!0}
return null}
toString(){return `${this.libraryName}(${this.constructorArgs.join(', ')})`}}
class VariableMetadata{constructor(value,options={}){this.value=value;this.declaredType=options.declaredType||null;this.inferredType=this.inferType(value);this.type=this.declaredType||this.inferredType;this.scopeLevel=options.scopeLevel||0;this.scopeType=options.scopeType||'global';this.declarationLine=options.declarationLine||null;this.isInitialized=options.isInitialized!==!1;this.isDeclaration=options.isDeclaration||!1;this.isArray=options.isArray||!1;this.arraySize=options.arraySize||null;this.isUsed=!1;this.usageCount=0;this.firstUsageLine=null}
inferType(value){if(value instanceof ArduinoString)return'String';if(value instanceof ArduinoNumber)return value.arduinoType;if(value instanceof ArduinoPointer)return'pointer';if(value instanceof ArduinoFunctionPointer)return'function_pointer';if(Array.isArray(value))return'array';if(typeof value==='number'){return Number.isInteger(value)?'int':'float'}
if(typeof value==='boolean')return'bool';if(typeof value==='string')return'char*';return'unknown'}
isTypeCompatible(newValue){const newType=this.inferType(newValue);const normalizeType=(type)=>{return type.replace(/\b(static|extern|const|volatile|inline|register)\s+/g,'').trim()};const normalizedThisType=normalizeType(this.type);const normalizedNewType=normalizeType(newType);if(normalizedThisType===normalizedNewType)return!0;const numericTypes=['int','float','double','long','unsigned long','byte','word','short','unsigned int','uint8_t','uint16_t','uint32_t','uint64_t','int8_t','int16_t','int32_t','int64_t','size_t'];if(numericTypes.includes(normalizedThisType)&&numericTypes.includes(normalizedNewType)){return!0}
if(normalizedThisType==='int'&&normalizedNewType==='bool'){return!0}
if((normalizedThisType==='int'||this.declaredType?.includes('(*'))&&normalizedNewType==='function_pointer'){return!0}
if(normalizedThisType==='String'&&(normalizedNewType==='string'||normalizedNewType==='char*')){return!0}
if(this.isArray&&normalizedNewType==='array'){return!0}
if((normalizedThisType.includes('*')||normalizedThisType==='pointer')&&normalizedNewType==='pointer'){return!0}
return!1}}
class ScopeManager{constructor(){this.scopeStack=[];this.currentScopeLevel=0;this.pushScope('global')}
pushScope(scopeType='block'){const newScope=new Map();newScope.scopeType=scopeType;newScope.level=this.currentScopeLevel++;this.scopeStack.push(newScope);return newScope}
popScope(){if(this.scopeStack.length<=1){throw new Error("Cannot pop global scope")}
this.currentScopeLevel--;return this.scopeStack.pop()}
getCurrentScope(){return this.scopeStack[this.scopeStack.length-1]}
set(name,value,options={}){const currentScope=this.getCurrentScope();console.log(`ðŸ” SCOPE DEBUG: ScopeManager.set() called`);console.log(`   Variable: ${name} = ${value} (type: ${typeof value})`);console.log(`   Options:`,options);console.log(`   Current scope: ${currentScope.scopeType} (level ${this.currentScopeLevel - 1})`);console.log(`   Scope stack depth: ${this.scopeStack.length}`);console.log(`   Variable exists in current scope: ${currentScope.has(name)}`);console.log(`   Variable exists anywhere: ${this.has(name)}`);if(this.has(name)){const existing=this.getMetadata(name);console.log(`   Existing variable: ${existing.value} in ${existing.scopeType} scope`)}
if(!currentScope.has(name)&&this.has(name)){const outerMetadata=this.getMetadata(name);if(options.isDeclaration&&outerMetadata){console.warn(`Variable '${name}' shadows variable from ${outerMetadata.scopeType} scope (level ${outerMetadata.scopeLevel})`)}}
if(options.isDeclaration&&currentScope.has(name)){const errorMsg=`Duplicate declaration: Variable '${name}' is already declared in ${currentScope.scopeType} scope`;console.error(errorMsg);return{success:!1,error:'DUPLICATE_DECLARATION',message:errorMsg}}
if(!options.isDeclaration&&this.has(name)){const existingMetadata=this.getMetadata(name);if(!existingMetadata.isTypeCompatible(value)){const newType=existingMetadata.inferType(value);const errorMsg=`Type error: Cannot assign ${newType} to variable '${name}' of type ${existingMetadata.type}`;console.error(errorMsg);return{success:!1,error:'TYPE_INCOMPATIBLE',message:errorMsg}}}
const metadata=new VariableMetadata(value,{scopeLevel:this.currentScopeLevel-1,scopeType:currentScope.scopeType,isDeclaration:options.isDeclaration||!1,...options});if(!options.isDeclaration&&this.has(name)){for(let i=this.scopeStack.length-1;i>=0;i--){const scope=this.scopeStack[i];if(scope.has(name)){console.log(`   ðŸŽ¯ UPDATING EXISTING: ${name} = ${value} in ${scope.scopeType} scope (level ${i})`);scope.set(name,metadata);console.log(`   âœ… UPDATED SUCCESSFULLY: ${name} = ${value}`);return{success:!0}}}}else{console.log(`   ðŸŽ¯ DECLARING NEW: ${name} = ${value} in ${currentScope.scopeType} scope`);currentScope.set(name,metadata);console.log(`   âœ… DECLARED SUCCESSFULLY: ${name} = ${value}`)}
return{success:!0}}
get(name){for(let i=this.scopeStack.length-1;i>=0;i--){const scope=this.scopeStack[i];if(scope.has(name)){return scope.get(name).value}}
return undefined}
has(name){for(let i=this.scopeStack.length-1;i>=0;i--){const scope=this.scopeStack[i];if(scope.has(name)){return!0}}
return!1}
getMetadata(name){for(let i=this.scopeStack.length-1;i>=0;i--){const scope=this.scopeStack[i];if(scope.has(name)){return scope.get(name)}}
return null}
markAsInitialized(name){const metadata=this.getMetadata(name);if(metadata){metadata.isInitialized=!0;console.log(`   ðŸ”„ MARKED AS INITIALIZED: ${name}`);return!0}
return!1}
markAsUsed(name){let marked=!1;for(let i=this.scopeStack.length-1;i>=0;i--){const scope=this.scopeStack[i];if(scope.has(name)){const metadata=scope.get(name);metadata.isUsed=!0;metadata.usageCount=(metadata.usageCount||0)+1;if(!metadata.firstUsageLine){metadata.firstUsageLine='current'}
marked=!0;break}}
return marked}
getUnusedVariablesInCurrentScope(){const currentScope=this.getCurrentScope();const unusedVariables=[];for(const[name,metadata]of currentScope.entries()){if(!metadata.isUsed&&metadata.isDeclaration){unusedVariables.push({name:name,metadata:metadata})}}
return unusedVariables}
hasInCurrentScope(name){return this.getCurrentScope().has(name)}
clear(){this.scopeStack=[];this.currentScopeLevel=0;this.pushScope('global')}
entries(){const allEntries=[];for(const scope of this.scopeStack){for(const[name,metadata]of scope.entries()){allEntries.push([name,metadata.value])}}
return allEntries}
getScopeInfo(){return{currentLevel:this.currentScopeLevel,scopeCount:this.scopeStack.length,scopes:this.scopeStack.map((scope,index)=>({level:index,type:scope.scopeType,variableCount:scope.size,variables:Array.from(scope.keys())}))}}}
const ARDUINO_LIBRARIES={'Adafruit_NeoPixel':{internalMethods:{'Color':(r,g,b)=>{return((r&0xFF)<<16)|((g&0xFF)<<8)|(b&0xFF)},'ColorHSV':(hue,sat=255,val=255)=>{hue=hue%65536;const sector=Math.floor(hue/10923);const offset=hue-(sector*10923);const p=(val*(255-sat))>>8;const q=(val*(255-((sat*offset)>>15)))>>8;const t=(val*(255-((sat*(10923-offset))>>15)))>>8;let r,g,b;switch(sector){case 0:r=val;g=t;b=p;break;case 1:r=q;g=val;b=p;break;case 2:r=p;g=val;b=t;break;case 3:r=p;g=q;b=val;break;case 4:r=t;g=p;b=val;break;default:r=val;g=p;b=q;break}
return((r&0xFF)<<16)|((g&0xFF)<<8)|(b&0xFF)},'numPixels':(obj)=>obj.constructorArgs[0]||60,'getBrightness':(obj)=>obj.brightness||255,'getPixelColor':(obj,pixel)=>{return obj.pixelColors?.[pixel]||0},'canShow':(obj)=>!0,'sine8':(x)=>Math.floor((Math.sin(x*Math.PI/128)+1)*127.5),'gamma8':(x)=>{return Math.floor(Math.pow(x/255.0,2.8)*255)}},externalMethods:['begin','show','clear','setPixelColor','setBrightness','setPin','updateLength','updateType','fill','rainbow'],staticMethods:['Color','ColorHSV','sine8','gamma8'],constructorArgs:['numPixels','pin','pixelType']},'Servo':{internalMethods:{'read':(obj)=>obj.currentAngle||90,'readMicroseconds':(obj)=>(obj.currentAngle||90)*10+1000,'attached':(obj)=>obj.isAttached||!1},externalMethods:['attach','detach','write','writeMicroseconds'],staticMethods:[],constructorArgs:[]},'LiquidCrystal':{internalMethods:{},externalMethods:['begin','clear','home','setCursor','print','println','write','display','noDisplay','cursor','noCursor','blink','noBlink','scrollDisplayLeft','scrollDisplayRight','autoscroll','noAutoscroll','leftToRight','rightToLeft','createChar'],staticMethods:[],constructorArgs:['rs','enable','d4','d5','d6','d7']},'SPI':{internalMethods:{},externalMethods:['begin','end','beginTransaction','endTransaction','transfer','transfer16','setClockDivider','setDataMode','setBitOrder'],staticMethods:[],constructorArgs:[]},'Wire':{internalMethods:{'available':(obj)=>obj.available||0,'read':(obj)=>obj.nextByte||0},externalMethods:['begin','requestFrom','beginTransmission','endTransmission','write','onReceive','onRequest'],staticMethods:[],constructorArgs:[]},'EEPROM':{internalMethods:{},externalMethods:['read','write','update','get','put','length'],staticMethods:[],constructorArgs:[]},'WiFi':{internalMethods:{'status':(obj)=>obj.connectionStatus||3,'SSID':(obj)=>obj.connectedSSID||"TestNetwork",'RSSI':(obj)=>obj.signalStrength||-45,'localIP':(obj)=>obj.localIP||"192.168.1.100",'subnetMask':(obj)=>obj.subnetMask||"255.255.255.0",'gatewayIP':(obj)=>obj.gatewayIP||"192.168.1.1"},externalMethods:['begin','config','disconnect','BSSID','dnsIP'],staticMethods:[],constructorArgs:[]},'SD':{internalMethods:{'exists':(obj,filename)=>obj.fileExists?.[filename]||!1},externalMethods:['begin','mkdir','rmdir','open','remove'],staticMethods:[],constructorArgs:[]}};class DebugManager{constructor(options){this.enabled=options.debug||options.verbose||!1;this.traceLevel=options.traceLevel||(options.verbose?1:0);this.executionTrace=[];this.maxTraceEntries=1000;this.startTime=Date.now()}
trace(level,category,message,data={}){if(!this.enabled||level>this.traceLevel)return;const entry={timestamp:Date.now()-this.startTime,level,category,message,data,stack:this.getCurrentStack()};this.executionTrace.push(entry);if(this.executionTrace.length>this.maxTraceEntries){this.executionTrace.shift()}
if(level<=this.traceLevel){const prefix=['','ðŸ”','ðŸ”¬','ðŸ“Š'][level]||'ðŸ“';console.log(`${prefix} [${category}] ${message}`,data)}}
getCurrentStack(){return new Error().stack?.split('\n').slice(2,5)||[]}
getTrace(){return[...this.executionTrace]}
clearTrace(){this.executionTrace=[]}
getStats(){const categories={};this.executionTrace.forEach(entry=>{categories[entry.category]=(categories[entry.category]||0)+1});return{totalEntries:this.executionTrace.length,categories,runtime:Date.now()-this.startTime}}}
class PerformanceMonitor{constructor(){this.metrics={functionCalls:0,variableAccesses:0,loopIterations:0,memoryAllocations:0,errors:0,warnings:0};this.timings={};this.startTime=Date.now()}
increment(metric,count=1){if(this.metrics[metric]!==undefined){this.metrics[metric]+=count}}
startTimer(name){this.timings[name]={start:performance.now()}}
endTimer(name){if(this.timings[name]){const duration=performance.now()-this.timings[name].start;this.timings[name].duration=duration;return duration}
return 0}
getStats(){const runtime=Date.now()-this.startTime;const stats={runtime,metrics:{...this.metrics},timings:{...this.timings},performance:{functionsPerSecond:(this.metrics.functionCalls/runtime)*1000,variableAccessesPerSecond:(this.metrics.variableAccesses/runtime)*1000,loopsPerSecond:(this.metrics.loopIterations/runtime)*1000}};return stats}
reset(){this.metrics={functionCalls:0,variableAccesses:0,loopIterations:0,memoryAllocations:0,errors:0,warnings:0};this.timings={};this.startTime=Date.now()}}
class ValidationReporter{constructor(interpreter){this.interpreter=interpreter;this.warnings=[];this.errors=[];this.scopeManager=interpreter.variables}
addWarning(message,node=null){const location=this.getLocationInfo(node);const warning={type:'WARNING',message,location,timestamp:new Date().toISOString()};this.warnings.push(warning);if(this.interpreter.onCommand){this.interpreter.onCommand({type:'WARNING',message:message,severity:'warning',location})}}
addError(message,node=null){const location=this.getLocationInfo(node);const error={type:'ERROR',message,location,timestamp:new Date().toISOString()};this.errors.push(error);if(this.interpreter.onCommand){this.interpreter.onCommand({type:'ERROR',message:message,severity:'error',location})}}
getLocationInfo(node){if(!node)return null;const line=node.position?.line||node.line;const column=node.position?.column||node.column;const context=node.position?.context||node.context;return(line!==null&&column!==null)?{line,column,context}:(context?{context}:null)}
getReport(){return{warnings:this.warnings,errors:this.errors,summary:{warningCount:this.warnings.length,errorCount:this.errors.length,hasIssues:this.warnings.length>0||this.errors.length>0}}}
clear(){this.warnings=[];this.errors=[]}}
class ArduinoInterpreter{constructor(ast,options={}){this.ast=ast;this.options={verbose:!1,stepDelay:100,maxLoopIterations:Infinity,...options};this.state=EXECUTION_STATE.IDLE;this.currentNode=null;this.nodeStack=[];this.executionPointer=0;this.objectId=Math.random().toString(36).substr(2,9);this.variables=new ScopeManager();this.functions=new Map();this.pinStates=new Map();this.staticVariables=new Map();this.staticInitialized=new Set();this.hardwareState={serial:{initialized:!1},wire:{initialized:!1},spi:{initialized:!1}};this.macros=new Map();this.functionMacros=new Map();this.initializeDefaultMacros();this.activeLibraries=new Set();this.processPreprocessorResults();this.setupFunction=null;this.loopFunction=null;this.serialEventFunction=null;this.loopIterations=0;this.programStartTime=Date.now();this.commandHistory=[];this.currentTimeout=null;this.executionSpeed=1.0;this.pauseResolver=null;this.consecutiveErrors=0;this.maxConsecutiveErrors=10;this.lastErrorTime=0;this.debugManager=new DebugManager(this.options);this.performanceMonitor=new PerformanceMonitor();this.callStack=[];this.maxCallStackDepth=1000;this.validationReporter=new ValidationReporter(this);this.validationPerformed=!1;this.executionContext={phase:'idle',loopIteration:0,isExecuting:!1,shouldContinue:!0};this.onCommand=null;this.onStateChange=null;this.onError=null;this.onNodeVisit=null;this.pendingRequests=new Map();this.responseHandlers=new Map();this.reset()}
start(){if(this.state===EXECUTION_STATE.RUNNING){return!1}
this.setState(EXECUTION_STATE.RUNNING);this.emitCommand({type:COMMAND_TYPES.VERSION_INFO,timestamp:Date.now(),component:'interpreter',version:INTERPRETER_VERSION,status:'started'});if(typeof PARSER_VERSION!=='undefined'){this.emitCommand({type:COMMAND_TYPES.VERSION_INFO,timestamp:Date.now(),component:'parser',version:PARSER_VERSION,status:'loaded'})}
this.emitCommand({type:COMMAND_TYPES.PROGRAM_START,timestamp:Date.now(),message:"Program execution started"});const validationReport=this.validateAST();if(validationReport&&validationReport.summary&&validationReport.summary.errorCount>0){this.emitError(`Validation failed: ${validationReport.summary.errorCount} errors found`);this.setState(EXECUTION_STATE.ERROR);return!1}
if(validationReport&&validationReport.summary&&validationReport.summary.warningCount>0&&this.options.verbose){this.emitCommand({type:COMMAND_TYPES.VERSION_INFO,timestamp:Date.now(),message:`âš ï¸  Pre-execution validation: ${validationReport.summary.warningCount} warnings found`})}
this.interpretAST().catch(error=>{this.emitError(`Execution error: ${error.message}`)});return!0}
stop(){this.executionContext.shouldContinue=!1;this.executionContext.isExecuting=!1;if(this.currentTimeout){clearTimeout(this.currentTimeout);this.currentTimeout=null}
if(this.pauseResolver){this.pauseResolver();this.pauseResolver=null}
this.setState(EXECUTION_STATE.IDLE);this.emitCommand({type:COMMAND_TYPES.PROGRAM_END,timestamp:Date.now(),message:"Program execution stopped"});return!0}
pause(){if(this.state===EXECUTION_STATE.RUNNING){this.setState(EXECUTION_STATE.PAUSED);return!0}
return!1}
resume(){if(this.state===EXECUTION_STATE.PAUSED){this.setState(EXECUTION_STATE.RUNNING);if(this.pauseResolver){this.pauseResolver();this.pauseResolver=null}
return!0}
return!1}
step(){if(this.state===EXECUTION_STATE.PAUSED){this.setState(EXECUTION_STATE.STEPPING);if(this.pauseResolver){this.pauseResolver();this.pauseResolver=null}
return!0}else if(this.state===EXECUTION_STATE.IDLE){this.setState(EXECUTION_STATE.STEPPING);this.interpretAST().catch(error=>{this.emitError(`Step execution error: ${error.message}`)});return!0}else if(this.state===EXECUTION_STATE.COMPLETE){this.reset();this.setState(EXECUTION_STATE.STEPPING);this.interpretAST().catch(error=>{this.emitError(`Step execution error: ${error.message}`)});return!0}
return!1}
reset(){this.state=EXECUTION_STATE.IDLE;this.currentNode=null;this.nodeStack=[];this.executionPointer=0;this.loopIterations=0;this.variables.clear();this.functions.clear();this.pinStates.clear();this.commandHistory=[];if(this.currentTimeout){clearTimeout(this.currentTimeout);this.currentTimeout=null}
if(this.pauseResolver){this.pauseResolver();this.pauseResolver=null}
this.executionContext={phase:'idle',loopIteration:0,isExecuting:!1,shouldContinue:!0};this.extractControlFunctions();if(this.options.verbose){console.log("Interpreter reset")}}
async waitForResponse(requestId,timeoutMs=5000){return new Promise((resolve,reject)=>{const timeout=setTimeout(()=>{this.pendingRequests.delete(requestId);reject(new Error(`Request ${requestId} timed out after ${timeoutMs}ms`))},timeoutMs);this.pendingRequests.set(requestId,{resolve,reject,timeout})})}
sendResponse(requestId,value){const pending=this.pendingRequests.get(requestId);if(pending){clearTimeout(pending.timeout);this.pendingRequests.delete(requestId);pending.resolve({value})}}
handleResponse(requestId,value,error=null){const pending=this.pendingRequests.get(requestId);if(pending){clearTimeout(pending.timeout);this.pendingRequests.delete(requestId);if(error){pending.reject(new Error(error))}else{pending.resolve({value})}}}
validateAST(){if(this.validationPerformed){return this.validationReporter.getReport()}
this.validationReporter.clear();if(!this.ast||!this.ast.children){this.validationReporter.addError("Invalid AST: no children found");this.validationPerformed=!0;return this.validationReporter.getReport()}
this.declaredVariables=new Set();this.usedVariables=new Set();this.declaredFunctions=new Set();this.usedFunctions=new Set();this.walkAST(this.ast);this.checkUnusedVariables();this.checkUndeclaredVariables();this.checkUnusedFunctions();this.validationPerformed=!0;return this.validationReporter.getReport()}
walkAST(node){if(!node)return;switch(node.type){case 'VarDeclNode':this.validateVariableDeclaration(node);break;case 'FuncDefNode':this.validateFunctionDeclaration(node);break;case 'IdentifierNode':this.validateIdentifierUsage(node);break;case 'FuncCallNode':this.validateFunctionCall(node);break;case 'BinaryOpNode':this.validateBinaryOperation(node);break;case 'AssignmentNode':this.validateAssignment(node);break;case 'IfStatement':case 'WhileStatement':case 'ForStatement':this.validateControlFlow(node);break}
if(node.children){for(const child of node.children){this.walkAST(child)}}
if(node.body)this.walkAST(node.body);if(node.left)this.walkAST(node.left);if(node.right)this.walkAST(node.right);if(node.condition)this.walkAST(node.condition);if(node.init)this.walkAST(node.init);if(node.update)this.walkAST(node.update);if(node.thenBranch)this.walkAST(node.thenBranch);if(node.elseBranch)this.walkAST(node.elseBranch);if(node.args&&Array.isArray(node.args)){for(const arg of node.args){this.walkAST(arg)}}}
validateVariableDeclaration(node){if(node.name){this.declaredVariables.add(node.name)}}
validateFunctionDeclaration(node){if(node.name){this.declaredFunctions.add(node.name)}}
validateIdentifierUsage(node){if(node.name){this.usedVariables.add(node.name)}}
validateFunctionCall(node){if(node.name){this.usedFunctions.add(node.name)}}
validateBinaryOperation(node){const operator=node.op?.value||node.op;if(['/','%'].includes(operator)){}}
validateAssignment(node){if(node.left&&node.left.type==='IdentifierNode'){this.usedVariables.add(node.left.name)}}
validateControlFlow(node){}
checkUnusedVariables(){for(const varName of this.declaredVariables){if(!this.usedVariables.has(varName)){this.validationReporter.addWarning(`Variable '${varName}' is declared but never used`)}}}
checkUndeclaredVariables(){const builtInFunctions=new Set(['pinMode','digitalWrite','digitalRead','analogWrite','analogRead','delay','millis','micros','setup','loop','isDigit','isPunct','isAlpha','isAlphaNumeric','isSpace','isUpperCase','isLowerCase','isHexadecimalDigit','isAscii','isWhitespace','isControl','isGraph','isPrintable']);const builtInConstants=new Set(['HIGH','LOW','INPUT','OUTPUT','INPUT_PULLUP','LED_BUILTIN','SERIAL','PTIME','BAUDRATE','HWVER','SWMAJ','SWMIN','LED_PMODE','LED_ERR','LED_HB','RESET','MOSI','MISO','SCK']);for(const varName of this.usedVariables){if(!this.declaredVariables.has(varName)&&!builtInConstants.has(varName)){this.validationReporter.addWarning(`Variable '${varName}' is used but not declared`)}}}
checkUnusedFunctions(){const builtInFunctions=new Set(['setup','loop']);for(const funcName of this.declaredFunctions){if(!this.usedFunctions.has(funcName)&&!builtInFunctions.has(funcName)){this.validationReporter.addWarning(`Function '${funcName}' is declared but never called`)}}}
async interpretAST(){if(!this.ast||!this.ast.children){this.emitError("Invalid AST: no children found");return}
const parseErrors=this.validateAST(this.ast);if(parseErrors.length>0){this.emitCommand({type:COMMAND_TYPES.ERROR,timestamp:Date.now(),message:"Parse errors detected - execution halted"});parseErrors.forEach((error,index)=>{this.emitError(`Parse Error ${index + 1}: ${error.message}`)});this.setState(EXECUTION_STATE.IDLE);return}
try{this.executionContext.isExecuting=!0;this.executionContext.shouldContinue=!0;await this.processGlobalDeclarations(this.ast);this.extractFunctions(this.ast);await this.executeControlledProgram()}catch(error){this.emitError(`Interpretation error: ${error.message}`)}finally{this.executionContext.isExecuting=!1}}
validateAST(node){const errors=[];this.collectParseErrors(node,errors);return errors}
collectParseErrors(node,errors){if(!node)return;if(node.type==='ErrorNode'){errors.push({message:node.value||'Unknown parse error',node:node})}
if(node.children&&Array.isArray(node.children)){for(const child of node.children){this.collectParseErrors(child,errors)}}
for(const key in node){if(typeof node[key]==='object'&&node[key]!==null&&key!=='children'){if(Array.isArray(node[key])){for(const item of node[key]){this.collectParseErrors(item,errors)}}else{this.collectParseErrors(node[key],errors)}}}}
async processGlobalDeclarations(node){if(!node||!node.children)return;for(const child of node.children){if(child.type==='VarDeclNode'){await this.executeVariableDeclaration(child);if(this.options.verbose){console.log(`Processed global variable declaration`)}}else if(child.type==='StructDeclaration'){this.handleStructDeclaration(child);if(this.options.verbose){console.log(`Processed global struct declaration: ${child.name || 'unnamed'}`)}}else if(child.type==='TypedefDeclaration'){await this.executeTypedefDeclaration(child);if(this.options.verbose){console.log(`Processed typedef declaration: ${child.typeName || 'unnamed'}`)}}else if(child.type==='ExpressionStatement'){await this.executeStatement(child);if(this.options.verbose){console.log(`Processed global expression statement`)}}}}
extractControlFunctions(){if(!this.ast||!this.ast.children)return;for(const child of this.ast.children){if(child.type==='FuncDefNode'){const funcName=child.declarator?.value;if(funcName==='setup'){this.setupFunction=child}else if(funcName==='loop'){this.loopFunction=child}else if(funcName==='serialEvent'){this.serialEventFunction=child}}}
if(this.options.verbose){console.log(`Found setup: ${!!this.setupFunction}, loop: ${!!this.loopFunction}, serialEvent: ${!!this.serialEventFunction}`)}}
extractFunctions(node){if(!node)return;if(node.type==='FuncDefNode'){const funcName=node.declarator?.value;if(funcName){if(!this.functions.has(funcName)){this.functions.set(funcName,[])}
this.functions.get(funcName).push(node);const paramCount=node.parameters?node.parameters.length:0;if(this.options.verbose){console.log(`Registered function: ${funcName}(${paramCount} params)`)}}}
if(node.children){for(const child of node.children){this.extractFunctions(child)}}
for(const key in node){if(typeof node[key]==='object'&&node[key]!==null&&key!=='children'){this.extractFunctions(node[key])}}}
async executeControlledProgram(){if(this.setupFunction&&this.executionContext.shouldContinue){this.executionContext.phase='setup';this.emitCommand({type:COMMAND_TYPES.SETUP_START,timestamp:Date.now(),message:"Executing setup() function"});await this.executeFunction(this.setupFunction);this.emitCommand({type:COMMAND_TYPES.SETUP_END,timestamp:Date.now(),message:"Completed setup() function"})}
if(this.loopFunction&&this.executionContext.shouldContinue){await this.executeControlledLoop()}
if(this.state===EXECUTION_STATE.RUNNING&&this.executionContext.shouldContinue){this.setState(EXECUTION_STATE.COMPLETE);this.emitCommand({type:COMMAND_TYPES.PROGRAM_END,timestamp:Date.now(),message:"Program execution completed"})}}
async executeControlledLoop(){this.executionContext.phase='loop';this.emitCommand({type:COMMAND_TYPES.LOOP_START,timestamp:Date.now(),message:"Starting loop() execution"});while(this.executionContext.shouldContinue){if(this.loopIterations>=this.options.maxLoopIterations){if(this.options.verbose){console.log(`Loop limit reached: ${this.options.maxLoopIterations} iterations`)}
this.executionContext.shouldContinue=!1;break}
await this.checkExecutionState();if(!this.executionContext.shouldContinue){break}
this.loopIterations++;this.executionContext.loopIteration=this.loopIterations;this.emitCommand({type:COMMAND_TYPES.LOOP_START,timestamp:Date.now(),message:`Starting loop iteration ${this.loopIterations}`});await this.executeFunction(this.loopFunction);if(this.serialEventFunction){this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'serialEvent',timestamp:Date.now(),message:'Calling serialEvent()'});await this.executeFunction(this.serialEventFunction)}
await this.yieldExecution()}
const limitReached=this.loopIterations>=this.options.maxLoopIterations;const completionMessage=limitReached?`Loop limit reached: completed ${this.loopIterations} iterations (max: ${this.options.maxLoopIterations})`:`Completed loop() execution (${this.loopIterations} iterations)`;this.emitCommand({type:COMMAND_TYPES.LOOP_END,timestamp:Date.now(),message:completionMessage,iterations:this.loopIterations,limitReached:limitReached});if(limitReached){this.state=EXECUTION_STATE.COMPLETE;this.emitCommand({type:COMMAND_TYPES.PROGRAM_END,timestamp:Date.now(),message:`Program completed after ${this.loopIterations} loop iterations (limit reached)`});this.stop()}}
async executeFunction(funcNode){if(!funcNode||!funcNode.body)return;this.currentNode=funcNode;this.visitNode(funcNode);const funcName=funcNode.declarator?.value;if(funcName==='loop'){this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'loop',message:`Executing loop() iteration ${this.loopIterations}`,iteration:this.loopIterations,timestamp:Date.now()});if(this.loopIterations>=22&&this.loopIterations<=25){console.log(`ðŸ” ITERATION ${this.loopIterations}: Scope stack depth = ${this.variables.scopeStack.length}`)}}
await this.executeStatement(funcNode.body);if(funcName==='loop'){this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'loop',message:`Completed loop() iteration ${this.loopIterations}`,iteration:this.loopIterations,completed:!0,timestamp:Date.now()})}}
async checkExecutionState(){if(this.state===EXECUTION_STATE.PAUSED){if(this.options.verbose){console.log(`Execution paused at phase: ${this.executionContext.phase}, loop: ${this.executionContext.loopIteration}`)}
await new Promise(resolve=>{this.pauseResolver=resolve});if(this.options.verbose){console.log(`Execution resumed from pause`)}}
if(this.state===EXECUTION_STATE.IDLE){this.executionContext.shouldContinue=!1;if(this.options.verbose){console.log(`Execution stopped`)}
return}}
async yieldExecution(){await new Promise(resolve=>setTimeout(resolve,5));if(Date.now()-this.lastErrorTime>2000){this.consecutiveErrors=0}}
async executeStatement(node){if(!node)return;await this.checkExecutionState();if(!this.executionContext.shouldContinue){return}
this.currentNode=node;this.visitNode(node);switch(node.type){case 'CompoundStmtNode':await this.executeCompoundStatement(node);break;case 'ExpressionStatement':console.log(`DEBUG ExpressionStatement:`,{expressionType:node.expression?.type,expressionOperator:node.expression?.operator,expression:node.expression});if(this.pendingStructType&&node.expression?.type==='IdentifierNode'){await this.createStructVariable(this.pendingStructType,node.expression.value);this.pendingStructType=null}else if(this.pendingStructType&&node.expression?.type==='CommaExpression'){const identifiers=this.extractIdentifiersFromCommaExpression(node.expression);for(const identifier of identifiers){await this.createStructVariable(this.pendingStructType,identifier)}
this.pendingStructType=null}else{await this.evaluateExpression(node.expression)}
break;case 'VarDeclNode':await this.executeVariableDeclaration(node);break;case 'IfStatement':await this.executeIfStatement(node);break;case 'WhileStatement':await this.executeWhileStatement(node);break;case 'DoWhileStatement':await this.executeDoWhileStatement(node);break;case 'ForStatement':await this.executeForStatement(node);break;case 'ReturnStatement':await this.executeReturnStatement(node);break;case 'SwitchStatement':await this.executeSwitchStatement(node);break;case 'BreakStatement':return{type:'break'};case 'ContinueStatement':return{type:'continue'};case 'CaseStatement':return await this.executeCaseStatement(node);case 'EmptyStatement':return this.handleEmptyStatement(node);case 'RangeBasedForStatement':return await this.executeRangeBasedForStatement(node);case 'FuncDefNode':if(this.options.verbose){const funcName=node.declarator?.value||'unnamed';console.log(`Function definition encountered: ${funcName}`)}
return;case 'FuncDeclNode':if(this.options.verbose){const funcName=node.declarator?.value||'unnamed';console.log(`Function declaration encountered: ${funcName}`)}
this.handleFunctionDeclaration(node);return;case 'ErrorNode':return this.handleErrorNode(node);case 'CommentNode':return this.handleCommentNode(node);case 'StructDeclaration':return this.handleStructDeclaration(node);case 'EnumDeclaration':return this.handleEnumDeclaration(node);case 'UnionDeclaration':return this.handleUnionDeclaration(node);case 'PreprocessorDirective':throw new Error(`Unexpected PreprocessorDirective AST node: ${node.directiveType}. Preprocessor should have been handled before parsing.`);case 'TypedefDeclaration':return this.executeTypedefDeclaration(node);case 'ClassDeclaration':return this.executeClassDeclaration(node);case 'ConstructorDeclaration':return this.executeConstructorDeclaration(node);case 'MemberFunctionDeclaration':return this.executeMemberFunctionDeclaration(node);case 'TemplateDeclaration':return this.executeTemplateDeclaration(node);case 'StructType':return this.handleStructType(node);default:if(this.options.verbose){console.warn(`Unhandled statement type: ${node.type}`)}}
if(this.state===EXECUTION_STATE.STEPPING){this.setState(EXECUTION_STATE.PAUSED)}}
async executeCompoundStatement(node){if(node.children){this.variables.pushScope('block');try{let hasControlFlowExit=!1;let exitStatementIndex=-1;for(let i=0;i<node.children.length;i++){const child=node.children[i];const result=await this.executeStatement(child);if(result&&(result.type==='return'||result.type==='break'||result.type==='continue')){hasControlFlowExit=!0;exitStatementIndex=i}
if(!this.executionContext.shouldContinue){break}
if(result&&(result.type==='return'||result.type==='break'||result.type==='continue')){return result}}}finally{this.variables.popScope()}}}
async executeVariableDeclaration(node){if(!node.declarations)return;for(const decl of node.declarations){const varName=decl.declarator?.value||decl.declarator?.identifier?.value;let arrayInitializerValues=null;if(varName){const tempDeclType=node.varType?.value||decl.type?.value||'';if(tempDeclType.includes('static')&&(tempDeclType.includes('void')||tempDeclType.includes('int')||tempDeclType.includes('float'))&&decl.initializer?.type==='ConstructorCallNode'){const returnType=tempDeclType.replace('static','').trim();let funcBody=null;if(varName==='incrementCounter'){funcBody={type:'CompoundStmtNode',children:[{type:'ExpressionStatement',expression:{type:'UnaryOpNode',op:'++',operand:{type:'IdentifierNode',value:'global_counter'},prefix:!0}}]}}
const funcDefNode={type:'FuncDefNode',returnType:{type:'TypeNode',value:returnType},declarator:{type:'DeclaratorNode',value:varName},parameters:decl.initializer.arguments||[],body:funcBody,isStatic:!0};if(!this.functions.has(varName)){this.functions.set(varName,[])}
this.functions.get(varName).push(funcDefNode);if(this.options.verbose){console.log(`Registered static function: ${varName} (return type: ${returnType}) with body: ${!!funcBody}`)}
continue}
const isStatic=node.storageSpecifier==='static'||decl.storageSpecifier==='static'||tempDeclType.startsWith('static ');const isConst=node.storageSpecifier==='const'||decl.storageSpecifier==='const'||tempDeclType.startsWith('const ');const isExtern=node.storageSpecifier==='extern'||decl.storageSpecifier==='extern'||tempDeclType.startsWith('extern ');if(this.options.verbose){console.log(`STORAGE DEBUG: ${varName}: tempDeclType="${tempDeclType}", isExtern=${isExtern}, hasExisting=${this.variables.has(varName)}`)}
if(isStatic){const funcName=this.currentFunction?.name||'global';const staticKey=`${funcName}_${varName}`;if(this.staticInitialized.has(staticKey)){if(this.options.verbose){console.log(`Static variable ${varName} already initialized, skipping`)}
continue}
let value=null;if(decl.initializer){value=await this.evaluateExpression(decl.initializer)}
this.staticVariables.set(staticKey,value);this.staticInitialized.add(staticKey);this.variables.set(varName,value,{isDeclaration:!0,declaredType:node.varType?.value||decl.type?.value,isStatic:!0,staticKey:staticKey});if(this.options.verbose){console.log(`Static variable initialized: ${varName} = ${value} (key: ${staticKey})`)}
continue}
if(isConst){if(!decl.initializer){this.emitError(`Const variable '${varName}' must be initialized at declaration`);continue}
const value=await this.evaluateExpression(decl.initializer);const result=this.variables.set(varName,value,{isDeclaration:!0,declaredType:node.varType?.value||decl.type?.value,isConst:!0,isInitialized:!0});if(!result.success){this.emitError(result.message||`Failed to declare const variable '${varName}'`);continue}
if(this.options.verbose){console.log(`Const variable declared: ${varName} = ${value} (immutable)`)}
this.emitCommand({type:COMMAND_TYPES.VAR_SET,variable:varName,value:this.sanitizeForCommand(value),isConst:!0,timestamp:Date.now()});continue}
if(isExtern){let actualType=tempDeclType;if(actualType.startsWith('extern ')){actualType=actualType.substring(7)}
if(!decl.initializer){this.variables.set(varName,undefined,{isDeclaration:!0,declaredType:actualType,isExtern:!0,isForwardDeclaration:!0});if(this.options.verbose){console.log(`Extern variable forward declared: ${varName} (type: ${actualType})`)}
continue}else{const value=await this.evaluateExpression(decl.initializer);this.variables.set(varName,value,{isDeclaration:!0,declaredType:actualType,isExtern:!0,isInitialized:!0});if(this.options.verbose){console.log(`Extern variable defined: ${varName} = ${value} (type: ${actualType})`)}
this.emitCommand({type:COMMAND_TYPES.VAR_SET,variable:varName,value:this.sanitizeForCommand(value),isExtern:!0,timestamp:Date.now()});continue}}
if(!isExtern&&this.variables.has(varName)){const existingMetadata=this.variables.getMetadata(varName);if(this.options.verbose){console.log(`EXTERN DEBUG: Found existing variable ${varName}, isExtern: ${existingMetadata?.isExtern}, isForwardDeclaration: ${existingMetadata?.isForwardDeclaration}`)}
if((existingMetadata?.isExtern&&existingMetadata?.isForwardDeclaration)||(existingMetadata&&decl.initializer&&!isExtern)){const value=decl.initializer?await this.evaluateExpression(decl.initializer):null;this.variables.set(varName,value,{isDeclaration:!0,declaredType:tempDeclType||existingMetadata?.declaredType,isExtern:!0,isInitialized:!0,isForwardDeclaration:!1});if(this.options.verbose){console.log(`Extern variable definition: ${varName} = ${value} (resolved forward declaration)`)}
this.emitCommand({type:COMMAND_TYPES.VAR_SET,variable:varName,value:this.sanitizeForCommand(value),isExtern:!0,timestamp:Date.now()});continue}}
const declType=node.varType?.value||decl.type?.value||decl.type?.type||(typeof decl.type==='string'?decl.type:null);let value=null;if(this.isObjectType(declType)){if(decl.initializer&&(decl.initializer.type==='FuncCallNode'||decl.initializer.type==='ConstructorCallNode')){const constructorArgs=[];if(decl.initializer.arguments){for(const arg of decl.initializer.arguments){constructorArgs.push(await this.evaluateExpression(arg))}}
value=this.createObject(declType,constructorArgs,varName);if(this.options.verbose){console.log(`Object variable ${varName}: created ${declType} with ${constructorArgs.length} args: [${constructorArgs.join(', ')}]`)}}else{value=this.createObject(declType,[],varName);if(this.options.verbose){console.log(`Object variable ${varName}: created ${declType} with default constructor`)}}}else if(this.isStructType(declType)){const structName=declType.replace(/^struct\s+/,'');const structDef=this.structTypes.get(structName);if(!structDef){this.emitError(`Struct type '${structName}' not defined`);continue}
const structFields={};for(const member of structDef.members){if(member.declarations){for(const memberDecl of member.declarations){const fieldName=memberDecl.declarator?.value||memberDecl.declarator?.identifier?.value;const fieldType=member.memberType?.value||member.memberType;if(fieldName){structFields[fieldName]=fieldType}}}else{const fieldName=member.declarator?.value||member.declarator?.identifier?.value;const fieldType=member.memberType?.value||member.memberType;if(fieldName){structFields[fieldName]=fieldType}}}
value=new ArduinoStruct(structName,structFields);if(this.options.verbose){console.log(`Struct variable ${varName}: created ${structName} with fields [${Object.keys(structFields).join(', ')}]`)}}else if(decl.initializer&&!arrayInitializerValues){if(decl.initializer.type==='ConstructorCallNode'&&this.isPrimitiveType(declType)){if(decl.initializer.arguments&&decl.initializer.arguments.length>0){value=await this.evaluateExpression(decl.initializer.arguments[0]);if(this.options.verbose){console.log(`C++ constructor syntax: ${declType} ${varName}(${value})`)}}else{value=this.getDefaultValue(declType);if(this.options.verbose){console.log(`C++ default constructor: ${declType} ${varName}() = ${value}`)}}}else{value=await this.evaluateExpression(decl.initializer)}
if(declType&&declType.includes('*')){const baseType=declType.replace(/\s*\*+\s*$/,'');if(decl.initializer){if(decl.initializer.type==='IdentifierNode'){const targetVarName=decl.initializer.value;value=new ArduinoPointer(targetVarName,this);if(this.options.verbose){console.log(`Pointer variable ${varName}: created pointer to ${targetVarName} (type: ${declType})`)}}else{value=await this.evaluateExpression(decl.initializer);if(this.options.verbose){console.log(`Pointer variable ${varName}: initialized with ${value} (type: ${declType})`)}}}else{value=null;if(this.options.verbose){console.log(`Pointer variable ${varName}: uninitialized pointer (type: ${declType})`)}}}else if(declType==='String'){if(typeof value==='string'){value=new ArduinoString(value)}else if(!(value instanceof ArduinoString)&&value!==null){value=new ArduinoString(String(value))}
if(this.options.verbose){console.log(`String variable ${varName}: converted to ArduinoString`)}}else if(this.isArduinoNumericType(declType)){if(typeof value==='number'||value instanceof ArduinoNumber){value=new ArduinoNumber(value,declType)}else if(value!==null){const numValue=Number(value);if(!isNaN(numValue)){value=new ArduinoNumber(numValue,declType)}}
if(this.options.verbose){console.log(`Arduino numeric variable ${varName}: converted to ${declType}`)}}}
const isArray=decl.declarator?.type==='ArrayDeclaratorNode';let arraySize=null;if(isArray){if(decl.initializer&&decl.initializer.type==='ArrayInitializerNode'&&decl.initializer.elements){arrayInitializerValues=[];for(const element of decl.initializer.elements){const elementValue=await this.evaluateExpression(element);arrayInitializerValues.push(elementValue)}
arraySize=arrayInitializerValues.length;value=arrayInitializerValues;if(this.options.verbose){console.log(`Array ${varName} initialized with initializer list:`,{size:arraySize,values:arrayInitializerValues})}}else{if(decl.declarator?.size){arraySize=await this.evaluateExpression(decl.declarator.size)}else if(decl.declarator?.dimensions&&decl.declarator.dimensions.length>0){arraySize=await this.evaluateExpression(decl.declarator.dimensions[0])}
if(this.options.verbose){console.log(`Array ${varName} size evaluation:`,{sizeNode:decl.declarator?.size,dimensions:decl.declarator?.dimensions,evaluatedSize:arraySize})}
if(arraySize&&arraySize>0){value=new Array(arraySize).fill(0);if(this.options.verbose){console.log(`Array ${varName} initialized with size ${arraySize}`)}}else{this.emitError(`Invalid array size for ${varName}: ${arraySize}`);continue}}}
const hasInitializer=!!decl.initializer||isArray||arrayInitializerValues;const result=this.variables.set(varName,value,{isDeclaration:!0,declaredType:declType,isArray:isArray,arraySize:arraySize,isInitialized:hasInitializer});if(!result.success){this.emitError(result.message||`Failed to declare variable '${varName}'`);continue}
this.emitCommand({type:COMMAND_TYPES.VAR_SET,variable:varName,value:this.sanitizeForCommand(value),timestamp:Date.now()});if(this.options.verbose){console.log(`Variable declared: ${varName} = ${value}`)}}}}
async executeExpression(node){return await this.evaluateExpression(node)}
async evaluateExpression(node){if(!node)return null;console.log(`DEBUG evaluateExpression processing: ${node.type}`,{nodeType:node.type,hasOperator:!!node.operator,operator:node.operator});this.visitNode(node);switch(node.type){case 'NumberNode':return node.value;case 'StringLiteralNode':if(typeof node.value==='string'){console.log(`DEBUG String literal: "${node.value}" -> ArduinoString`);return new ArduinoString(node.value)}
console.log(`DEBUG Literal: ${node.value} (type: ${typeof node.value})`);return node.value;case 'CharLiteralNode':if(typeof node.value==='string'&&node.value.length===1){const asciiValue=node.value.charCodeAt(0);console.log(`DEBUG Character literal: '${node.value}' -> ${asciiValue}`);return asciiValue}
console.log(`DEBUG Invalid character literal:`,node.value);return null;case 'IdentifierNode':const varName=node.value;this.variables.markAsUsed(varName);const constantValue=this.evaluateConstant(varName);if(constantValue!==undefined){return constantValue}
if(this.functions.has(varName)){const functionPointer=new ArduinoFunctionPointer(varName,this);if(this.options.verbose){console.log(`Implicit function-to-pointer conversion: ${varName} -> function pointer`)}
return functionPointer}
return this.getVariable(varName);case 'ConstantNode':return this.evaluateConstant(node.value);case 'FuncCallNode':return await this.executeFunctionCall(node);case 'BinaryOpNode':return await this.executeBinaryOperation(node);case 'UnaryOpNode':return await this.executeUnaryOperation(node);case 'PostfixExpressionNode':return await this.executePostfixOperation(node);case 'MemberAccessNode':return await this.executeMemberAccess(node);case 'ArrayAccessNode':return await this.executeArrayAccess(node);case 'ArrayInitializerNode':return await this.executeArrayInitializer(node);case 'CastExpression':return await this.executeCastExpression(node);case 'TernaryExpression':return await this.executeTernaryExpression(node);case 'AssignmentNode':console.log(`DEBUG Found AssignmentNode in evaluateExpression:`,{operator:node.operator,left:node.left,right:node.right});return await this.executeAssignmentNode(node);case 'TypeNode':return{type:'type_info',typeName:node.value,isPointer:node.isPointer||!1,pointerLevel:node.pointerLevel||0,isReference:node.isReference||!1};case 'ParamNode':return{type:'parameter_info',paramType:node.paramType,paramName:node.declarator?.value,isPointer:node.paramType?.isPointer||!1,pointerLevel:node.paramType?.pointerLevel||0};case 'ProgramNode':if(this.options.verbose){console.log(`ProgramNode encountered in expression context`)}
return{type:'program_root',childCount:node.children?.length||0};case 'ConstructorCallNode':return await this.executeConstructorCall(node);case 'NamespaceAccessNode':return await this.executeNamespaceAccess(node);case 'MemberAccessNode':return await this.executeMemberAccess(node);case 'CppCastNode':return await this.executeCppCast(node);case 'PointerDeclaratorNode':return this.handlePointerDeclarator(node);case 'FunctionPointerDeclaratorNode':return this.handleFunctionPointerDeclarator(node);case 'ArrayDeclaratorNode':return this.handleArrayDeclarator(node);case 'DeclaratorNode':return this.handleDeclarator(node);case 'SizeofExpression':return await this.executeSizeofExpression(node);case 'FunctionStyleCastNode':return await this.executeFunctionStyleCast(node);case 'WideCharLiteralNode':return this.handleWideCharLiteral(node);case 'DesignatedInitializerNode':return this.handleDesignatedInitializer(node);case 'ErrorNode':return this.handleErrorNode(node);case 'CommentNode':return this.handleCommentNode(node);case 'TernaryExpression':return await this.executeTernaryExpression(node);case 'PostfixExpressionNode':return await this.executePostfixExpression(node);case 'CastExpression':return await this.executeCastExpression(node);case 'NewExpression':return await this.executeNewExpression(node);case 'CommaExpression':return await this.executeCommaExpression(node);case 'RangeExpression':return await this.executeRangeExpression(node);case 'StructType':return this.handleStructType(node);case 'EnumType':return this.handleEnumType(node);case 'EnumMember':return await this.handleEnumMember(node);case 'UnionType':return this.handleUnionType(node);case 'LambdaExpression':return await this.executeLambdaExpression(node);case 'MultipleStructMembers':return this.handleMultipleStructMembers(node);case 'StructMember':return this.handleStructMember(node);case 'TemplateTypeParameter':return this.handleTemplateTypeParameter(node);default:console.log(`DEBUG Unhandled expression type: ${node.type}`,{nodeType:node.type,node:node,nodeKeys:Object.keys(node)});return null}}
evaluateConstant(value){switch(value){case 'HIGH':return DIGITAL_VALUES.HIGH;case 'LOW':return DIGITAL_VALUES.LOW;case 'INPUT':return PIN_MODES.INPUT;case 'OUTPUT':return PIN_MODES.OUTPUT;case 'INPUT_PULLUP':return PIN_MODES.INPUT_PULLUP;case 'INPUT_PULLDOWN':return PIN_MODES.INPUT_PULLDOWN;case 'LED_BUILTIN':return 13;case 'SERIAL':return'Serial';case 'PTIME':return 30;case 'BAUDRATE':return 19200;case 'HWVER':return 2;case 'SWMAJ':return 1;case 'SWMIN':return 18;case 'LED_PMODE':return 7;case 'LED_ERR':return 8;case 'LED_HB':return 9;case 'RESET':return 10;case 'MOSI':return 11;case 'MISO':return 12;case 'SCK':return 13;case 'Serial':return this.hardwareState.serial.initialized?1:0;case 'Wire':return this.hardwareState.wire.initialized?1:0;case 'SPI':return this.hardwareState.spi.initialized?1:0;case 'KEY_LEFT_CTRL':return KEYBOARD_KEYS.KEY_LEFT_CTRL;case 'KEY_LEFT_SHIFT':return KEYBOARD_KEYS.KEY_LEFT_SHIFT;case 'KEY_LEFT_ALT':return KEYBOARD_KEYS.KEY_LEFT_ALT;case 'KEY_LEFT_GUI':return KEYBOARD_KEYS.KEY_LEFT_GUI;case 'KEY_RIGHT_CTRL':return KEYBOARD_KEYS.KEY_RIGHT_CTRL;case 'KEY_RIGHT_SHIFT':return KEYBOARD_KEYS.KEY_RIGHT_SHIFT;case 'KEY_RIGHT_ALT':return KEYBOARD_KEYS.KEY_RIGHT_ALT;case 'KEY_RIGHT_GUI':return KEYBOARD_KEYS.KEY_RIGHT_GUI;case 'KEY_UP_ARROW':return KEYBOARD_KEYS.KEY_UP_ARROW;case 'KEY_DOWN_ARROW':return KEYBOARD_KEYS.KEY_DOWN_ARROW;case 'KEY_LEFT_ARROW':return KEYBOARD_KEYS.KEY_LEFT_ARROW;case 'KEY_RIGHT_ARROW':return KEYBOARD_KEYS.KEY_RIGHT_ARROW;case 'KEY_BACKSPACE':return KEYBOARD_KEYS.KEY_BACKSPACE;case 'KEY_TAB':return KEYBOARD_KEYS.KEY_TAB;case 'KEY_RETURN':return KEYBOARD_KEYS.KEY_RETURN;case 'KEY_ESC':return KEYBOARD_KEYS.KEY_ESC;case 'KEY_INSERT':return KEYBOARD_KEYS.KEY_INSERT;case 'KEY_DELETE':return KEYBOARD_KEYS.KEY_DELETE;case 'KEY_PAGE_UP':return KEYBOARD_KEYS.KEY_PAGE_UP;case 'KEY_PAGE_DOWN':return KEYBOARD_KEYS.KEY_PAGE_DOWN;case 'KEY_HOME':return KEYBOARD_KEYS.KEY_HOME;case 'KEY_END':return KEYBOARD_KEYS.KEY_END;case 'KEY_CAPS_LOCK':return KEYBOARD_KEYS.KEY_CAPS_LOCK;case 'KEY_F1':return KEYBOARD_KEYS.KEY_F1;case 'KEY_F2':return KEYBOARD_KEYS.KEY_F2;case 'KEY_F3':return KEYBOARD_KEYS.KEY_F3;case 'KEY_F4':return KEYBOARD_KEYS.KEY_F4;case 'KEY_F5':return KEYBOARD_KEYS.KEY_F5;case 'KEY_F6':return KEYBOARD_KEYS.KEY_F6;case 'KEY_F7':return KEYBOARD_KEYS.KEY_F7;case 'KEY_F8':return KEYBOARD_KEYS.KEY_F8;case 'KEY_F9':return KEYBOARD_KEYS.KEY_F9;case 'KEY_F10':return KEYBOARD_KEYS.KEY_F10;case 'KEY_F11':return KEYBOARD_KEYS.KEY_F11;case 'KEY_F12':return KEYBOARD_KEYS.KEY_F12;case 'A0':return 14;case 'A1':return 15;case 'A2':return 16;case 'A3':return 17;case 'A4':return 18;case 'A5':return 19;case 'A6':return 20;case 'A7':return 21;case 'true':return!0;case 'false':return!1;case 'NEO_GRB':return 0x01;case 'NEO_RGB':return 0x02;case 'NEO_RGBW':return 0x03;case 'NEO_KHZ800':return 0x0000;case 'NEO_KHZ400':return 0x0100;case 'clock_div_1':return 0x00;default:return undefined}}
isArduinoNumericType(type){const arduinoNumericTypes=['byte','int','unsigned int','word','long','unsigned long','short','unsigned short','int8_t','uint8_t','int16_t','uint16_t','int32_t','uint32_t','int64_t','uint64_t','float','double'];return arduinoNumericTypes.includes(type)}
isObjectType(type){if(ARDUINO_LIBRARIES.hasOwnProperty(type)){return!0}
if(this.isTemplateType(type)){return!0}
return!1}
isPrimitiveType(type){const primitiveTypes=['int','float','double','char','bool','boolean','byte','short','long','unsigned int','unsigned long','unsigned char','unsigned short','size_t','word','uint8_t','int8_t','uint16_t','int16_t','uint32_t','int32_t','uint64_t','int64_t'];return primitiveTypes.includes(type)}
isStructType(type){if(!this.structTypes)return!1;const structName=type.replace(/^struct\s+/,'');return this.structTypes.has(structName)}
getDefaultValue(type){switch(type){case 'int':case 'short':case 'long':case 'byte':case 'size_t':case 'word':case 'unsigned int':case 'unsigned long':case 'unsigned char':case 'unsigned short':case 'uint8_t':case 'int8_t':case 'uint16_t':case 'int16_t':case 'uint32_t':case 'int32_t':case 'uint64_t':case 'int64_t':return 0;case 'float':case 'double':return 0.0;case 'bool':case 'boolean':return!1;case 'char':return'\0';default:return null}}
isTemplateType(type){if(type&&typeof type==='string'){if(type.startsWith('std::vector<')&&type.endsWith('>')){return!0}
if(type==='std::string'){return!0}
if(type.startsWith('std::array<')&&type.endsWith('>')){return!0}}
return!1}
createTemplateObject(templateType,constructorArgs){if(templateType.startsWith('std::vector<')&&templateType.endsWith('>')){const elementType=templateType.slice(12,-1);return new ArduinoVector(elementType,constructorArgs)}else if(templateType==='std::string'){return new ArduinoStdString(constructorArgs)}else if(templateType.startsWith('std::array<')&&templateType.endsWith('>')){const innerContent=templateType.slice(11,-1);const parts=innerContent.split(',').map(s=>s.trim());const elementType=parts[0];const arraySize=parseInt(parts[1])||0;return new ArduinoArray(elementType,arraySize,constructorArgs)}
return new ArduinoObject(templateType,constructorArgs,this)}
createObject(className,constructorArgs,variableName=null){if(this.isTemplateType(className)){return this.createTemplateObject(className,constructorArgs)}
const libraryInfo=ARDUINO_LIBRARIES[className];if(!libraryInfo){this.emitError(`Unknown library class: ${className}`);return new ArduinoObject(className,constructorArgs,this)}
this.emitCommand({type:'LIBRARY_OBJECT_INSTANTIATION',library:className,variableName:variableName,constructorArgs:constructorArgs,timestamp:Date.now(),message:`${className}(${constructorArgs.join(', ')})`});if(this.options.verbose){console.log(`Creating ${className} object with args: [${constructorArgs.join(', ')}]`)}
const obj=new ArduinoObject(className,constructorArgs,this);obj.libraryInfo=libraryInfo;return obj}
createLibraryObject(className,constructorArgs){return this.createObject(className,constructorArgs)}
async executeFunctionCall(node){if(node.callee?.type==='MemberAccessNode'){console.log(`DEBUG Member access via function call:`,node.callee);const memberAccessNode={...node.callee,arguments:node.arguments};return await this.executeMemberAccess(memberAccessNode)}
if(node.callee?.type==='NamespaceAccessNode'){console.log(`DEBUG Namespace access via function call:`,node.callee);return await this.executeNamespaceFunctionCall(node)}
const funcName=node.callee?.value;console.log(`DEBUG Function call:`,{funcName:funcName,callee:node.callee,calleeType:node.callee?.type,arguments:node.arguments?.length||0,nodeType:node.type});if(!funcName)return null;if(this.functionMacros.has(funcName)){const macro=this.functionMacros.get(funcName);const args=[];if(node.arguments){for(const arg of node.arguments){const argValue=await this.evaluateExpression(arg);args.push(argValue)}}
if(args.length!==macro.params.length){this.emitError(`Macro ${funcName} expects ${macro.params.length} arguments, got ${args.length}`);return null}
let expansion=macro.body;for(let i=0;i<macro.params.length;i++){const paramRegex=new RegExp(`\\b${macro.params[i]}\\b`,'g');expansion=expansion.replace(paramRegex,String(args[i]))}
expansion=this.expandMacros(expansion);if(this.options.verbose){console.log(`Macro expansion: ${funcName}(${args.join(', ')}) -> ${expansion}`)}
try{const result=this.evaluateSimpleMacroExpression(expansion);return result}catch(error){this.emitError(`Error evaluating macro expansion: ${error.message}`);return null}}
if(this.variables.has(funcName)){const variable=this.variables.get(funcName);if(variable instanceof ArduinoFunctionPointer){const args=[];if(node.arguments){for(const arg of node.arguments){args.push(await this.evaluateExpression(arg))}}
if(this.options.verbose){console.log(`Function pointer call detected: ${funcName} -> ${variable.functionName}(${args.length} args)`)}
return await variable.call(args)}}
const args=[];if(node.arguments){for(const arg of node.arguments){args.push(await this.evaluateExpression(arg))}}
if(this.isArduinoLibraryConstructor(funcName)){return this.createArduinoLibraryObject(funcName,args)}
switch(funcName){case 'pinMode':return this.arduinoPinMode(args);case 'digitalWrite':return this.arduinoDigitalWrite(args);case 'digitalRead':return await this.arduinoDigitalRead(args);case 'analogWrite':return this.arduinoAnalogWrite(args);case 'analogRead':return await this.arduinoAnalogRead(args);case 'delay':return await this.arduinoDelay(args);case 'delayMicroseconds':return this.arduinoDelayMicroseconds(args);case 'millis':return await this.arduinoMillis();case 'micros':return await this.arduinoMicros();case 'pulseIn':return this.arduinoPulseIn(args);case 'tone':return this.arduinoTone(args);case 'noTone':return this.arduinoNoTone(args);case 'String':return this.arduinoStringConstructor(args);case 'isDigit':return this.arduinoIsDigit(args);case 'isPunct':return this.arduinoIsPunct(args);case 'isAlpha':return this.arduinoIsAlpha(args);case 'isAlphaNumeric':return this.arduinoIsAlphaNumeric(args);case 'isSpace':return this.arduinoIsSpace(args);case 'isUpperCase':return this.arduinoIsUpperCase(args);case 'isLowerCase':return this.arduinoIsLowerCase(args);case 'isHexadecimalDigit':return this.arduinoIsHexadecimalDigit(args);case 'isAscii':return this.arduinoIsAscii(args);case 'isWhitespace':return this.arduinoIsWhitespace(args);case 'isControl':return this.arduinoIsControl(args);case 'isGraph':return this.arduinoIsGraph(args);case 'isPrintable':return this.arduinoIsPrintable(args);case 'clock_prescale_set':return this.avrClockPrescaleSet(args);case 'map':return this.arduinoMap(args);case 'constrain':return this.arduinoConstrain(args);case 'abs':return Math.abs(args[0]);case 'min':return Math.min(args[0],args[1]);case 'max':return Math.max(args[0],args[1]);case 'pow':return Math.pow(args[0],args[1]);case 'sqrt':return Math.sqrt(args[0]);case 'sin':return Math.sin(args[0]);case 'cos':return Math.cos(args[0]);case 'tan':return Math.tan(args[0]);case 'random':return this.arduinoRandom(args);default:const result=await this.executeUserFunction(funcName,args);return result}}
arduinoPinMode(args){if(args.length<2){this.emitError("pinMode requires 2 arguments: pin, mode");return}
const pin=args[0];const mode=args[1];const numericPin=this.getNumericValue(pin);if(numericPin<0||numericPin>127){this.emitError(`Invalid pin number: ${numericPin}. Pin must be a number between 0-127`);return}
const numericMode=this.getNumericValue(mode);const validModes=[0,1,2];if(!validModes.includes(numericMode)&&typeof mode!=='string'){const modeStr=String(mode).toUpperCase();if(!['INPUT','OUTPUT','INPUT_PULLUP'].includes(modeStr)){this.emitError(`Invalid pin mode: ${mode}. Use INPUT (0), OUTPUT (1), or INPUT_PULLUP (2)`);return}}
this.pinStates.set(pin,{mode:mode,value:0});this.emitCommand({type:COMMAND_TYPES.PIN_MODE,pin:pin,mode:mode,timestamp:Date.now()})}
arduinoDigitalWrite(args){if(args.length<2){this.emitError("digitalWrite requires 2 arguments: pin, value");return}
const pin=args[0];const value=args[1];const numericPin=this.getNumericValue(pin);if(numericPin<0||numericPin>127){this.emitError(`Invalid pin number: ${numericPin}. Pin must be a number between 0-127`);return}
const numericValue=this.getNumericValue(value);const validValues=[0,1];if(!validValues.includes(numericValue)){const valueStr=String(value).toUpperCase();if(!['HIGH','LOW'].includes(valueStr)){this.emitError(`Invalid digital value: ${value}. Use HIGH (1), LOW (0), or 0/1`);return}}
const pinState=this.pinStates.get(pin)||{mode:'OUTPUT',value:0};pinState.value=value;this.pinStates.set(pin,pinState);this.emitCommand({type:COMMAND_TYPES.DIGITAL_WRITE,pin:pin,value:this.sanitizeForCommand(value),timestamp:Date.now()})}
async arduinoDelay(args){if(args.length<1){this.emitError("delay requires 1 argument: milliseconds");return}
const ms=args[0];const numericMs=this.getNumericValue(ms);if(numericMs<0){this.emitError(`Invalid delay value: ${numericMs}. Delay must be a non-negative number`);return}
const actualDelay=ms/this.executionSpeed;this.emitCommand({type:COMMAND_TYPES.DELAY,duration:ms,actualDelay:actualDelay,timestamp:Date.now()});if(this.state===EXECUTION_STATE.RUNNING&&this.options.stepDelay>0){await new Promise((resolve)=>{this.currentTimeout=setTimeout(()=>{this.currentTimeout=null;resolve()},actualDelay)})}}
arduinoStringConstructor(args){if(args.length===0){return new ArduinoString("")}
const value=args[0];const format=args.length>1?args[1]:null;return ArduinoString.create(value,format)}
async executeConstructorCall(node){const className=node.callee?.value;if(!className){this.emitError("Invalid constructor call: no class name");return null}
const args=[];if(node.arguments){for(const arg of node.arguments){args.push(await this.evaluateExpression(arg))}}
if(this.options.verbose){console.log(`Constructor call: ${className}(${args.join(', ')})`)}
const objectInstance=this.createLibraryObject(className,args);this.emitCommand({type:COMMAND_TYPES.CONSTRUCTOR_CALL,className:className,arguments:args,objectId:objectInstance.objectId,timestamp:Date.now()});return objectInstance}
async executeNamespaceAccess(node){const namespace=node.namespace?.value;const member=node.member?.value;if(!namespace||!member){this.emitError("Invalid namespace access: missing namespace or member");return null}
if(this.options.verbose){console.log(`Namespace access: ${namespace}::${member}`)}
if(namespace==='std'){return this.handleStdNamespace(member,node)}
if(namespace==='Serial'){return this.handleSerialNamespace(member,node)}
return this.handleCustomNamespace(namespace,member,node)}
isArduinoLibraryConstructor(funcName){const knownLibraries=['CapacitiveSensor','Servo','LiquidCrystal','SoftwareSerial','Stepper','LedControl','RF24','DHT','OneWire','DallasTemperature','Adafruit_NeoPixel','MPU6050','Adafruit_SSD1306','WiFi','Ethernet'];return knownLibraries.includes(funcName)}
createArduinoLibraryObject(libraryName,args){if(this.options.verbose){console.log(`Creating Arduino library object: ${libraryName}(${args.join(', ')})`)}
const libraryObject=new ArduinoLibraryObject(libraryName,args);this.emitCommand({type:'ARDUINO_LIBRARY_INSTANTIATION',library:libraryName,constructorArgs:args,objectId:libraryObject.objectId,timestamp:Date.now(),message:`${libraryName}(${args.join(', ')})`});return libraryObject}
async executeNamespaceFunctionCall(node){const namespace=node.callee.namespace?.value;const member=node.callee.member?.value;if(!namespace||!member){this.emitError("Invalid namespace function call: missing namespace or member");return null}
const args=[];if(node.arguments){for(const arg of node.arguments){args.push(await this.evaluateExpression(arg))}}
if(this.options.verbose){console.log(`Namespace function call: ${namespace}::${member}(${args.length} args)`)}
switch(namespace){case 'Serial':return this.executeSerialNamespaceFunction(member,args);case 'std':return this.executeStdNamespaceFunction(member,args);default:return this.executeCustomNamespaceFunction(namespace,member,args)}}
executeSerialNamespaceFunction(functionName,args){return this.executeSerialMethod(functionName,args)}
executeStdNamespaceFunction(functionName,args){switch(functionName){case 'min':if(args.length>=2){return Math.min(args[0],args[1])}
break;case 'max':if(args.length>=2){return Math.max(args[0],args[1])}
break;case 'abs':if(args.length>=1){return Math.abs(args[0])}
break;default:this.emitError(`Unknown std namespace function: ${functionName}`);return null}}
executeCustomNamespaceFunction(namespace,functionName,args){if(this.options.verbose){console.log(`Custom namespace function: ${namespace}::${functionName}(${args.join(', ')})`)}
this.emitCommand({type:'NAMESPACE_FUNCTION_CALL',namespace:namespace,function:functionName,arguments:args,timestamp:Date.now(),message:`${namespace}::${functionName}(${args.join(', ')})`});return null}
handleStdNamespace(member,node){switch(member){case 'vector':return{type:'std_vector_type',templateArgs:node.templateArgs||[],namespace:'std'};case 'string':return{type:'std_string_type',namespace:'std'};default:if(this.options.verbose){console.log(`Unknown std:: member: ${member}`)}
return{type:'std_member_access',member:member,namespace:'std'}}}
handleSerialNamespace(member,node){switch(member){case 'println':case 'print':return{type:'serial_function',functionName:member,namespace:'Serial'};default:return{type:'serial_member_access',member:member,namespace:'Serial'}}}
handleCustomNamespace(namespace,member,node){return{type:'custom_namespace_access',namespace:namespace,member:member,node:node}}
async executeMemberAccess(node){const objectName=node.object?.value;const memberName=node.property?.value;const operator=node.operator;if(!objectName||!memberName){this.emitError("Invalid member access: missing object or member");return null}
if(this.options.verbose){console.log(`Member access: ${objectName}${operator === 'DOT' ? '.' : '->'}${memberName}`)}
if(objectName==='Serial'){return this.handleSerialMemberAccess(memberName,node)}
const objectValue=this.getVariable(objectName);if(objectValue&&objectValue.type==='object_instance'){return this.handleObjectMemberAccess(objectValue,memberName,node)}
return{type:'member_access',object:objectName,member:memberName,operator:operator,objectValue:objectValue}}
handleSerialMemberAccess(memberName,node){switch(memberName){case 'println':case 'print':case 'begin':case 'available':case 'read':return{type:'serial_function',functionName:memberName,object:'Serial'};default:return{type:'serial_member',member:memberName,object:'Serial'}}}
handleObjectMemberAccess(objectValue,memberName,node){return{type:'object_member_access',objectId:objectValue.objectId,className:objectValue.className,member:memberName,objectValue:objectValue}}
async executeCppCast(node){const castType=node.castType;const targetType=node.targetType?.value;const expression=node.expression;if(!castType||!targetType||!expression){this.emitError("Invalid C++ cast: missing cast type, target type, or expression");return null}
const sourceValue=await this.evaluateExpression(expression);if(this.options.verbose){console.log(`C++ cast: ${castType}<${targetType}>(${sourceValue})`)}
switch(castType){case 'static_cast':return this.performStaticCast(sourceValue,targetType,node);case 'dynamic_cast':return this.performDynamicCast(sourceValue,targetType,node);case 'const_cast':return this.performConstCast(sourceValue,targetType,node);case 'reinterpret_cast':return this.performReinterpretCast(sourceValue,targetType,node);default:this.emitError(`Unsupported C++ cast type: ${castType}`);return null}}
performStaticCast(sourceValue,targetType,node){switch(targetType){case 'int':return parseInt(sourceValue)||0;case 'float':case 'double':return parseFloat(sourceValue)||0.0;case 'char':return String(sourceValue).charAt(0)||'\0';case 'bool':return Boolean(sourceValue);default:if(this.options.verbose){console.log(`Static cast to custom type: ${targetType}`)}
return{type:'static_cast_result',targetType:targetType,sourceValue:sourceValue,cast:'static_cast'}}}
performDynamicCast(sourceValue,targetType,node){if(this.options.verbose){console.log(`Dynamic cast from ${typeof sourceValue} to ${targetType}`)}
return{type:'dynamic_cast_result',targetType:targetType,sourceValue:sourceValue,cast:'dynamic_cast',success:!0}}
performConstCast(sourceValue,targetType,node){return{type:'const_cast_result',targetType:targetType,sourceValue:sourceValue,cast:'const_cast'}}
performReinterpretCast(sourceValue,targetType,node){if(this.options.verbose){console.log(`Reinterpret cast from ${typeof sourceValue} to ${targetType}`)}
return{type:'reinterpret_cast_result',targetType:targetType,sourceValue:sourceValue,cast:'reinterpret_cast'}}
handlePointerDeclarator(node){const baseType=node.baseType?.value;const pointerLevel=node.pointerLevel||1;const declaratorName=node.declarator?.value;if(this.options.verbose){console.log(`Pointer declarator: ${'*'.repeat(pointerLevel)}${declaratorName} (${baseType})`)}
return{type:'pointer_declarator_info',baseType:baseType,pointerLevel:pointerLevel,declaratorName:declaratorName,isPointer:!0}}
handleFunctionPointerDeclarator(node){const returnType=node.returnType?.value;const functionName=node.declarator?.value;const parameters=node.parameters||[];if(this.options.verbose){console.log(`Function pointer declarator: ${returnType} (*${functionName})(${parameters.length} params)`)}
return{type:'function_pointer_declarator_info',returnType:returnType,functionName:functionName,parameters:parameters,isFunctionPointer:!0}}
handleArrayDeclarator(node){const baseType=node.baseType?.value;const declaratorName=node.declarator?.value;const dimensions=node.dimensions||[];if(this.options.verbose){const dimStr=dimensions.map(d=>`[${d?.value || ''}]`).join('');console.log(`Array declarator: ${declaratorName}${dimStr} (${baseType})`)}
return{type:'array_declarator_info',baseType:baseType,declaratorName:declaratorName,dimensions:dimensions,isArray:!0}}
handleDeclarator(node){const declaratorName=node.value;if(this.options.verbose){console.log(`Basic declarator: ${declaratorName}`)}
return{type:'declarator_info',declaratorName:declaratorName,value:declaratorName}}
async executeSizeofExpression(node){const operand=node.operand;if(!operand){this.emitError("Invalid sizeof expression: missing operand");return null}
if(operand.type==='TypeNode'){return this.getSizeofType(operand.value)}else{const value=await this.evaluateExpression(operand);return this.getSizeofValue(value,operand)}}
getSizeofType(typeName){const typeSizes={'char':1,'byte':1,'bool':1,'int':2,'short':2,'long':4,'float':4,'double':4,'size_t':2,'uint8_t':1,'uint16_t':2,'uint32_t':4,'int8_t':1,'int16_t':2,'int32_t':4};const size=typeSizes[typeName]||4;if(this.options.verbose){console.log(`sizeof(${typeName}) = ${size} bytes`)}
return size}
getSizeofValue(value,operandNode){if(typeof value==='string'){return value.length+1}else if(typeof value==='number'){if(Number.isInteger(value)){return value>=-32768&&value<=32767?2:4}else{return 4}}else if(typeof value==='boolean'){return 1}else if(value&&value.type==='array'){return value.length*(value.elementSize||4)}else{return 2}}
async executeFunctionStyleCast(node){const castType=node.castType?.value;const argument=node.argument;if(!castType||!argument){this.emitError("Invalid function-style cast: missing cast type or argument");return null}
const sourceValue=await this.evaluateExpression(argument);if(this.options.verbose){console.log(`Function-style cast: ${castType}(${sourceValue})`)}
switch(castType){case 'int':return parseInt(sourceValue)||0;case 'float':case 'double':return parseFloat(sourceValue)||0.0;case 'char':return String(sourceValue).charAt(0)||'\0';case 'bool':return Boolean(sourceValue);default:return{type:'function_style_cast_result',castType:castType,sourceValue:sourceValue}}}
handleWideCharLiteral(node){const value=node.value;const isString=node.isString||!1;if(this.options.verbose){console.log(`Wide char literal: L${isString ? '"' : "'"}${value}${isString ? '"' : "'"}`)}
return{type:'wide_char_literal',value:this.sanitizeForCommand(value),isString:isString,encoding:'utf-16'}}
async handleDesignatedInitializer(node){if(this.options.verbose){console.log(`DEBUG DesignatedInitializerNode:`,JSON.stringify(node,null,2))}
const result={};if(node.field&&node.value){const fieldName=node.field.value||node.field;const fieldValue=await this.evaluateExpression(node.value);result[fieldName]=fieldValue;if(this.options.verbose){console.log(`Designated initializer: .${fieldName} = ${fieldValue}`)}}else if(node.designators&&Array.isArray(node.designators)){for(const designator of node.designators){if(designator.field&&designator.value){const fieldName=designator.field.value||designator.field;const fieldValue=await this.evaluateExpression(designator.value);result[fieldName]=fieldValue}}}else{if(this.options.verbose){console.log(`DEBUG: Unknown designated initializer structure`)}}
return result}
handleErrorNode(node){const errorMessage=node.message||'Parse error';const errorToken=node.token;if(this.options.verbose){console.log(`Error node encountered: ${errorMessage}`);if(errorToken){console.log(`   At token: ${errorToken.type} "${errorToken.value}"`)}}
this.emitError(`Parse error: ${errorMessage}`);return{type:'error_node_result',message:errorMessage,token:errorToken,handled:!0}}
handleCommentNode(node){const commentText=node.text||'';const commentType=node.commentType||'line';if(this.options.verbose){console.log(`Comment: ${commentType === 'line' ? '//' : '/*'}${commentText}${commentType === 'block' ? '*/' : ''}`)}
return{type:'comment_node_result',text:commentText,commentType:commentType}}
handleFunctionDeclaration(node){const funcName=node.declarator?.value;const returnType=node.returnType?.value;const parameters=node.parameters||[];if(!funcName){if(this.options.verbose){console.log('Function declaration missing name')}
return}
const funcDecl={name:funcName,returnType:returnType,parameters:parameters,isDeclaration:!0,node:node};if(!this.functions.has(funcName)){this.functions.set(funcName,funcDecl)}
if(this.options.verbose){const paramStr=parameters.map(p=>`${p.paramType?.value || 'unknown'} ${p.declarator?.value || 'unnamed'}`).join(', ');console.log(`Function declaration: ${returnType || 'void'} ${funcName}(${paramStr})`)}}
async executeAssignment(node){const varName=node.left?.value;if(!varName){this.emitError("Invalid assignment: no variable name");return null}
const value=await this.evaluateExpression(node.right);const varInfo=this.variables.get(varName);if(varInfo?.metadata?.isStatic){this.staticVariables.set(varInfo.metadata.staticKey,value)}
if(varInfo?.metadata?.isConst){this.emitError(`Cannot assign to const variable '${varName}' - constants are immutable`);return null}
const result=this.variables.set(varName,value);if(!result.success){this.emitError(result.message||`Failed to assign value to variable '${varName}'`);return null}
this.variables.markAsInitialized(varName);if(this.options.verbose){console.log(`Assignment: ${varName} = ${value}`)}
this.emitCommand({type:COMMAND_TYPES.VAR_SET,variable:varName,value:this.sanitizeForCommand(value),timestamp:Date.now()});return value}
async executeArrayElementAssignment(node){const arrayAccess=node.left;const arrayName=arrayAccess.identifier?.value;if(!arrayName){this.emitError("Invalid array element assignment: no array name");return null}
const indexValue=await this.evaluateExpression(arrayAccess.index);const rightValue=await this.evaluateExpression(node.right);const arrayValue=this.getVariable(arrayName);if(arrayValue===undefined){this.emitError(`Array ${arrayName} not found`);return null}
if(!Array.isArray(arrayValue)){this.emitError(`Variable ${arrayName} is not an array`);return null}
let newValue;switch(node.operator){case '=':newValue=rightValue;break;case '+=':const currentValue=arrayValue[indexValue]||0;newValue=currentValue+rightValue;break;case '-=':const currentValue2=arrayValue[indexValue]||0;newValue=currentValue2-rightValue;break;case '*=':const currentValue3=arrayValue[indexValue]||0;newValue=currentValue3*rightValue;break;case '/=':const currentValue4=arrayValue[indexValue]||0;newValue=currentValue4/rightValue;break;default:this.emitError(`Unsupported assignment operator for array elements: ${node.operator}`);return null}
arrayValue[indexValue]=newValue;this.variables.set(arrayName,arrayValue);if(this.options.verbose){console.log(`Array element assignment: ${arrayName}[${indexValue}] = ${newValue}`)}
return newValue}
async executeAssignmentNode(node){if(node.left?.type==='UnaryOpNode'&&(node.left.op?.value==='*'||node.left.op==='*')){return await this.executePointerAssignment(node)}
if(node.left?.type==='MemberAccessNode'||node.left?.type==='PropertyAccessNode'){return await this.executeStructFieldAssignment(node)}
if(node.left?.type==='ArrayAccessNode'){return await this.executeArrayElementAssignment(node)}
const varName=node.left?.value;if(!varName){this.emitError("Invalid assignment: no variable name");return null}
const rightValue=await this.evaluateExpression(node.right);const operator=node.operator;let newValue;console.log(`DEBUG AssignmentNode: ${varName} ${operator} ${rightValue}`);switch(operator){case '=':newValue=rightValue;break;case '+=':const currentValue=this.getVariable(varName);if(currentValue instanceof ArduinoString){newValue=currentValue.concat(rightValue)}else if(rightValue instanceof ArduinoString){newValue=new ArduinoString(String(currentValue)).concat(rightValue)}else{newValue=currentValue+rightValue}
break;case '-=':const currentValue2=this.getVariable(varName);newValue=currentValue2-rightValue;break;case '*=':const currentValue3=this.getVariable(varName);newValue=currentValue3*rightValue;break;case '/=':const currentValue4=this.getVariable(varName);newValue=currentValue4/rightValue;break;case '%=':const currentValue5=this.getVariable(varName);newValue=currentValue5%rightValue;break;case '&=':const currentValue6=this.getVariable(varName);newValue=currentValue6&rightValue;break;case '|=':const currentValue7=this.getVariable(varName);newValue=currentValue7|rightValue;break;case '^=':const currentValue8=this.getVariable(varName);newValue=currentValue8^rightValue;break;case '<<=':const currentValue9=this.getVariable(varName);newValue=currentValue9<<rightValue;break;case '>>=':const currentValue10=this.getVariable(varName);newValue=currentValue10>>rightValue;break;default:this.emitError(`Unknown assignment operator: ${operator}`);return null}
const result=this.variables.set(varName,newValue);if(!result.success){this.emitError(result.message||`Failed to assign value to variable '${varName}' (operator: ${operator})`);return null}
this.variables.markAsInitialized(varName);if(this.options.verbose){console.log(`Assignment: ${varName} ${operator} ${rightValue} = ${newValue}`)}
this.emitCommand({type:COMMAND_TYPES.VAR_SET,variable:varName,value:this.sanitizeForCommand(newValue),timestamp:Date.now()});return newValue}
async executePointerAssignment(node){const pointerExpression=node.left.operand;const rightValue=await this.evaluateExpression(node.right);const operator=node.operator;const pointer=await this.evaluateExpression(pointerExpression);if(!(pointer instanceof ArduinoPointer)){this.emitError("Dereference assignment can only be applied to pointers");return null}
let newValue;switch(operator){case '=':newValue=rightValue;break;case '+=':const currentValue=pointer.getValue();newValue=currentValue+rightValue;break;case '-=':const currentValue2=pointer.getValue();newValue=currentValue2-rightValue;break;case '*=':const currentValue3=pointer.getValue();newValue=currentValue3*rightValue;break;case '/=':const currentValue4=pointer.getValue();newValue=currentValue4/rightValue;break;case '%=':const currentValue5=pointer.getValue();newValue=currentValue5%rightValue;break;default:this.emitError(`Unknown assignment operator for pointer dereference: ${operator}`);return null}
try{pointer.setValue(newValue);if(this.options.verbose){console.log(`Pointer assignment: *${pointer.targetVariable} ${operator} ${rightValue} = ${newValue}`)}
return newValue}catch(error){this.emitError(`Pointer assignment failed: ${error.message}`);return null}}
async executeStructFieldAssignment(node){const memberAccess=node.left;const rightValue=await this.evaluateExpression(node.right);const operator=node.operator;let structObject=await this.evaluateExpression(memberAccess.object);const fieldName=memberAccess.property?.value||memberAccess.property;const isArrowOperator=memberAccess.operator==='ARROW';if(isArrowOperator&&structObject instanceof ArduinoPointer){structObject=structObject.getValue();if(this.options.verbose){console.log(`Arrow operator assignment: dereferencing pointer for ${fieldName} assignment`)}}
if(!(structObject instanceof ArduinoStruct)){this.emitError("Field assignment can only be applied to structs");return null}
let newValue;switch(operator){case '=':newValue=rightValue;break;case '+=':const currentValue=structObject.getField(fieldName);newValue=currentValue+rightValue;break;case '-=':const currentValue2=structObject.getField(fieldName);newValue=currentValue2-rightValue;break;case '*=':const currentValue3=structObject.getField(fieldName);newValue=currentValue3*rightValue;break;case '/=':const currentValue4=structObject.getField(fieldName);newValue=currentValue4/rightValue;break;case '%=':const currentValue5=structObject.getField(fieldName);newValue=currentValue5%rightValue;break;default:this.emitError(`Unknown assignment operator for struct field: ${operator}`);return null}
try{structObject.setField(fieldName,newValue);if(this.options.verbose){console.log(`Struct field assignment: ${structObject.structName}.${fieldName} ${operator} ${rightValue} = ${newValue}`)}
this.emitCommand({type:'STRUCT_FIELD_SET',struct:structObject.structName,field:fieldName,value:this.sanitizeForCommand(newValue),timestamp:Date.now(),message:`${structObject.structName}.${fieldName} = ${newValue}`});return newValue}catch(error){this.emitError(`Struct field assignment failed: ${error.message}`);return null}}
async executeBinaryOperation(node){this.currentNode=node;const left=await this.evaluateExpression(node.left);const right=await this.evaluateExpression(node.right);const operator=node.op?.value||node.op;let result;switch(operator){case '+':if(left instanceof ArduinoPointer&&typeof right==='number'){result=left.add(right)}else if(typeof left==='number'&&right instanceof ArduinoPointer){result=right.add(left)}else if(left instanceof ArduinoString||right instanceof ArduinoString){const leftStr=left instanceof ArduinoString?left:new ArduinoString(String(left));const rightStr=right instanceof ArduinoString?right:new ArduinoString(String(right));result=leftStr.concat(rightStr)}else{const leftValue=this.getNumericValue(left);const rightValue=this.getNumericValue(right);result=leftValue+rightValue}
break;case '-':if(left instanceof ArduinoPointer&&typeof right==='number'){result=left.subtract(right)}else if(left instanceof ArduinoPointer&&right instanceof ArduinoPointer){if(left.targetVariable===right.targetVariable){const leftOffset=left instanceof ArduinoOffsetPointer?left.offset:0;const rightOffset=right instanceof ArduinoOffsetPointer?right.offset:0;result=leftOffset-rightOffset}else{this.emitError("Cannot subtract pointers to different variables");result=null}}else{const leftValue=this.getNumericValue(left);const rightValue=this.getNumericValue(right);result=leftValue-rightValue}
break;case '*':const leftMul=this.getNumericValue(left);const rightMul=this.getNumericValue(right);result=leftMul*rightMul;break;case '/':const leftDiv=this.getNumericValue(left);const rightDiv=this.getNumericValue(right);if(rightDiv===0){this.emitError("Division by zero error");this.executionContext.shouldContinue=!1;this.executionContext.isExecuting=!1;return null}
result=leftDiv/rightDiv;break;case '%':const leftMod=this.getNumericValue(left);const rightMod=this.getNumericValue(right);if(rightMod===0){this.emitError("Modulo by zero error");this.executionContext.shouldContinue=!1;this.executionContext.isExecuting=!1;return null}
result=leftMod%rightMod;break;case '==':if(left instanceof ArduinoString||right instanceof ArduinoString){const leftStr=left instanceof ArduinoString?left.value:String(left);const rightStr=right instanceof ArduinoString?right.value:String(right);result=leftStr===rightStr}else{const leftValue=this.getNumericValue(left);const rightValue=this.getNumericValue(right);result=leftValue==rightValue}
break;case '!=':if(left instanceof ArduinoString||right instanceof ArduinoString){const leftStr=left instanceof ArduinoString?left.value:String(left);const rightStr=right instanceof ArduinoString?right.value:String(right);result=leftStr!==rightStr}else{const leftValue=this.getNumericValue(left);const rightValue=this.getNumericValue(right);result=leftValue!=rightValue}
break;case '<':const leftLT=this.getNumericValue(left);const rightLT=this.getNumericValue(right);result=leftLT<rightLT;break;case '>':const leftGT=this.getNumericValue(left);const rightGT=this.getNumericValue(right);result=leftGT>rightGT;break;case '<=':const leftLE=this.getNumericValue(left);const rightLE=this.getNumericValue(right);result=leftLE<=rightLE;break;case '>=':const leftGE=this.getNumericValue(left);const rightGE=this.getNumericValue(right);result=leftGE>=rightGE;break;case '&&':result=left&&right;break;case '||':result=left||right;break;case '&':const leftAnd=this.getNumericValue(left);const rightAnd=this.getNumericValue(right);result=leftAnd&rightAnd;break;case '|':const leftOr=this.getNumericValue(left);const rightOr=this.getNumericValue(right);result=leftOr|rightOr;break;case '^':const leftXor=this.getNumericValue(left);const rightXor=this.getNumericValue(right);result=leftXor^rightXor;break;case '<<':const leftShift=this.getNumericValue(left);const rightShift=this.getNumericValue(right);result=leftShift<<rightShift;break;case '>>':const leftRShift=this.getNumericValue(left);const rightRShift=this.getNumericValue(right);result=leftRShift>>rightRShift;break;default:this.emitError(`Unknown binary operator: ${operator}`);return null}
if(this.options.verbose){console.log(`Binary operation: ${left} ${operator} ${right} = ${result}`)}
return result}
async executeUnaryOperation(node){const operand=await this.evaluateExpression(node.operand);const operator=node.op?.value||node.op;switch(operator){case '-':return-operand;case '+':return+operand;case '!':return!operand;case '~':return~operand;case '++':if(node.operand?.type==='IdentifierNode'){const varName=node.operand.value;const newValue=operand+1;const result=this.variables.set(varName,newValue);const staticKey=`global_${varName}`;if(this.staticVariables.has(staticKey)){this.staticVariables.set(staticKey,newValue);if(this.options.verbose){console.log(`Updated static variable ${varName} = ${newValue}`)}
this.variables.markAsInitialized(varName);this.emitCommand({type:COMMAND_TYPES.VAR_SET,variable:varName,value:this.sanitizeForCommand(newValue),timestamp:Date.now()});return newValue}
if(!result.success){this.emitError(result.message||`Failed to increment variable '${varName}'`);return operand}
this.variables.markAsInitialized(varName);this.emitCommand({type:COMMAND_TYPES.VAR_SET,variable:varName,value:this.sanitizeForCommand(newValue),timestamp:Date.now()});return newValue}
return operand+1;case '--':if(node.operand?.type==='IdentifierNode'){const varName=node.operand.value;const newValue=operand-1;const result=this.variables.set(varName,newValue);if(!result.success){this.emitError(result.message||`Failed to decrement variable '${varName}'`);return operand}
this.variables.markAsInitialized(varName);this.emitCommand({type:COMMAND_TYPES.VAR_SET,variable:varName,value:this.sanitizeForCommand(newValue),timestamp:Date.now()});return newValue}
return operand-1;case '&':if(node.operand?.type==='IdentifierNode'){const name=node.operand.value;if(this.functions.has(name)){const functionPointer=new ArduinoFunctionPointer(name,this);if(this.options.verbose){console.log(`Address-of function: &${name} -> function pointer to ${name}`)}
return functionPointer}
if(this.variables.has(name)){const pointer=new ArduinoPointer(name,this);if(this.options.verbose){console.log(`Address-of variable: &${name} -> pointer to ${name}`)}
return pointer}
this.emitError(`Cannot take address of undefined variable or function '${name}'`);return null}else{this.emitError("Address-of operator (&) can only be applied to variables or functions");return null}
case '*':if(operand instanceof ArduinoPointer){const value=operand.getValue();if(this.options.verbose){console.log(`Dereference: *pointer -> ${value}`)}
return value}else if(typeof operand==='number'){this.emitError("Dereferencing numeric values not yet fully supported");return null}else{this.emitError("Dereference operator (*) can only be applied to pointers");return null}
default:this.emitError(`Unknown unary operator: ${operator}`);return null}}
async executePostfixOperation(node){const operand=await this.evaluateExpression(node.operand);const operator=node.op?.value||node.op;switch(operator){case '++':if(node.operand?.type==='IdentifierNode'){const varName=node.operand.value;const oldValue=operand;let newValue;if(oldValue instanceof ArduinoPointer){newValue=oldValue.add(1)}else{newValue=oldValue+1}
const success=this.variables.set(varName,newValue);if(!success){this.emitError(`Failed to increment variable '${varName}'`);return operand}
const varInfo=this.variables.get(varName);console.log(`DEBUG postfix varInfo for ${varName}:`,varInfo?.metadata);if(varInfo?.metadata?.isStatic){this.staticVariables.set(varInfo.metadata.staticKey,newValue);console.log(`âœ… Updated static variable ${varName} = ${newValue} (key: ${varInfo.metadata.staticKey})`)}else{console.log(`âŒ Not static: isStatic=${varInfo?.metadata?.isStatic}, key=${varInfo?.metadata?.staticKey}`)}
if(this.options.verbose){if(oldValue instanceof ArduinoPointer){console.log(`Postfix increment: ${varName}++ (pointer -> next element)`)}else{console.log(`Postfix increment: ${varName}++ (${oldValue} -> ${newValue})`)}}
this.emitCommand({type:COMMAND_TYPES.VAR_SET,variable:varName,value:this.sanitizeForCommand(newValue),timestamp:Date.now()});return oldValue}
return operand;case '--':if(node.operand?.type==='IdentifierNode'){const varName=node.operand.value;const oldValue=operand;const success=this.variables.set(varName,oldValue-1);if(!success){this.emitError(`Failed to decrement variable '${varName}'`);return operand}
const varInfo=this.variables.get(varName);if(varInfo?.metadata?.isStatic){this.staticVariables.set(varInfo.metadata.staticKey,oldValue-1);if(this.options.verbose){console.log(`Updated static variable ${varName} = ${oldValue - 1} (key: ${varInfo.metadata.staticKey})`)}}
if(this.options.verbose){console.log(`Postfix decrement: ${varName}-- (${oldValue} -> ${oldValue - 1})`)}
this.emitCommand({type:COMMAND_TYPES.VAR_SET,variable:varName,value:this.sanitizeForCommand(oldValue-1),timestamp:Date.now()});return oldValue}
return operand;default:this.emitError(`Unknown postfix operator: ${operator}`);return null}}
async executeMemberAccess(node){const operator=node.operator;const hasArguments=node.arguments!==undefined;if(node.object?.value==='Serial'){const property=node.property?.value||node.property;console.log(`DEBUG Serial member access: Serial.${property}`,{hasArguments:node.arguments!==undefined,argumentsLength:node.arguments?.length});return await this.executeSerialMethod(property,node.arguments)}
if(node.object?.value&&this.isObjectType(node.object.value)){const className=node.object.value;const methodName=node.property?.value||node.property;return await this.executeStaticMethod(className,methodName,node.arguments)}
const object=await this.evaluateExpression(node.object);const property=node.property?.value||node.property;if(object instanceof ArduinoObject){if(node.arguments!==undefined){const args=[];if(node.arguments){for(const arg of node.arguments){args.push(await this.evaluateExpression(arg))}}
const variableName=node.object?.value;const result=await object.callMethod(property,args,variableName);return result}else{return object.getProperty(property)}}
if(object instanceof ArduinoStruct){if(node.arguments!==undefined){this.emitError(`Cannot call methods on struct field '${property}' - structs don't have methods`);return null}else{try{const fieldValue=object.getField(property);if(this.options.verbose){console.log(`Struct field access: ${object.structName}.${property} = ${fieldValue}`)}
this.emitCommand({type:'STRUCT_FIELD_ACCESS',struct:object.structName,field:property,value:fieldValue,timestamp:Date.now(),message:`${object.structName}.${property} = ${fieldValue}`});return fieldValue}catch(error){this.emitError(`Struct field access failed: ${error.message}`);return null}}}
console.log(`DEBUG Member access:`,{object:object,objectType:typeof object,isArduinoString:object instanceof ArduinoString,property:property,nodeProperty:node.property,hasArguments:node.arguments!==undefined,argumentsLength:node.arguments?.length});if(object instanceof ArduinoString){switch(property){case 'length':if(node.arguments!==undefined){return object.length()}
return object.length();case 'charAt':if(node.arguments&&node.arguments.length>0){const index=await this.evaluateExpression(node.arguments[0]);return object.charAt(index)}
this.emitError("charAt() requires an index argument");return'';case 'substring':if(node.arguments&&node.arguments.length>=1){const start=await this.evaluateExpression(node.arguments[0]);const end=node.arguments.length>1?await this.evaluateExpression(node.arguments[1]):undefined;return object.substring(start,end)}
this.emitError("substring() requires start argument");return new ArduinoString('');case 'indexOf':if(node.arguments&&node.arguments.length>0){const searchString=await this.evaluateExpression(node.arguments[0]);return object.indexOf(searchString)}
this.emitError("indexOf() requires a search string");return-1;case 'toInt':return object.toInt();case 'toFloat':return object.toFloat();case 'reserve':if(node.arguments&&node.arguments.length>0){const size=await this.evaluateExpression(node.arguments[0]);return}
this.emitError("String.reserve() requires a size argument");return;case 'setCharAt':if(node.arguments&&node.arguments.length>=2){const index=await this.evaluateExpression(node.arguments[0]);const char=await this.evaluateExpression(node.arguments[1]);object.setCharAt(index,char);return}
this.emitError("setCharAt() requires index and character arguments");return;case 'replace':if(node.arguments&&node.arguments.length>=2){const find=await this.evaluateExpression(node.arguments[0]);const replace=await this.evaluateExpression(node.arguments[1]);object.replace(find,replace);return}
this.emitError("replace() requires find and replace arguments");return;case 'trim':object.trim();return;case 'toUpperCase':object.toUpperCase();return;case 'toLowerCase':object.toLowerCase();return;case 'compareTo':if(node.arguments&&node.arguments.length>0){const other=await this.evaluateExpression(node.arguments[0]);return object.compareTo(other)}
this.emitError("compareTo() requires a string argument");return 0;case 'equalsIgnoreCase':if(node.arguments&&node.arguments.length>0){const other=await this.evaluateExpression(node.arguments[0]);return object.equalsIgnoreCase(other)}
this.emitError("equalsIgnoreCase() requires a string argument");return!1;case 'startsWith':if(node.arguments&&node.arguments.length>0){const prefix=await this.evaluateExpression(node.arguments[0]);const offset=node.arguments.length>1?await this.evaluateExpression(node.arguments[1]):0;return object.startsWith(prefix,offset)}
this.emitError("startsWith() requires a prefix argument");return!1;case 'endsWith':if(node.arguments&&node.arguments.length>0){const suffix=await this.evaluateExpression(node.arguments[0]);return object.endsWith(suffix)}
this.emitError("endsWith() requires a suffix argument");return!1;case 'equals':if(node.arguments&&node.arguments.length>0){const other=await this.evaluateExpression(node.arguments[0]);return object.equals(other)}
this.emitError("equals() requires a string argument");return!1;case 'concat':if(node.arguments&&node.arguments.length>0){const other=await this.evaluateExpression(node.arguments[0]);return object.concat(other)}
this.emitError("concat() requires a string argument");return new ArduinoString('');default:this.emitError(`Unknown String method: ${property}`);return null}}
if(typeof object==='undefined'||object===null||object==='Serial'){const objectName=node.object?.value;if(objectName&&objectName.match(/^Serial\d*$/)){return await this.executeSerialMethod(property,node.arguments)}
if(object==='Serial'||objectName==='SERIAL'){return await this.executeSerialMethod(property,node.arguments)}
if(objectName==='Keyboard'){if(property==='begin'){this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Keyboard.begin',arguments:[],timestamp:Date.now(),message:'Keyboard.begin()'});return}
if(property==='print'&&node.arguments&&node.arguments.length>0){const text=await this.evaluateExpression(node.arguments[0]);this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Keyboard.print',arguments:[text],timestamp:Date.now(),message:`Keyboard.print(${text})`});return}
if(property==='println'){const text=node.arguments&&node.arguments.length>0?await this.evaluateExpression(node.arguments[0]):'';this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Keyboard.println',arguments:[text],timestamp:Date.now(),message:`Keyboard.println(${text})`});return}
if(property==='write'&&node.arguments&&node.arguments.length>0){const key=await this.evaluateExpression(node.arguments[0]);this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Keyboard.write',arguments:[key],timestamp:Date.now(),message:`Keyboard.write(${key})`});return}
if(property==='press'&&node.arguments&&node.arguments.length>0){const key=await this.evaluateExpression(node.arguments[0]);this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Keyboard.press',arguments:[key],timestamp:Date.now(),message:`Keyboard.press(${key})`});return}
if(property==='release'){const key=node.arguments&&node.arguments.length>0?await this.evaluateExpression(node.arguments[0]):'all';this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Keyboard.release',arguments:[key],timestamp:Date.now(),message:`Keyboard.release(${key})`});return}
if(property==='releaseAll'){this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Keyboard.releaseAll',arguments:[],timestamp:Date.now(),message:'Keyboard.releaseAll()'});return}
this.emitError(`Unknown Keyboard method: ${property}`);return null}
if(objectName==='Mouse'){if(property==='begin'){this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Mouse.begin',arguments:[],timestamp:Date.now(),message:'Mouse.begin()'});return}
if(property==='isPressed'){const buttonArg=node.arguments&&node.arguments.length>0?await this.evaluateExpression(node.arguments[0]):'MOUSE_LEFT';this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Mouse.isPressed',arguments:[buttonArg],timestamp:Date.now(),message:`Mouse.isPressed(${buttonArg})`});return!1}
if(property==='move'){const xArg=node.arguments&&node.arguments.length>0?await this.evaluateExpression(node.arguments[0]):0;const yArg=node.arguments&&node.arguments.length>1?await this.evaluateExpression(node.arguments[1]):0;const scrollArg=node.arguments&&node.arguments.length>2?await this.evaluateExpression(node.arguments[2]):0;this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Mouse.move',arguments:[xArg,yArg,scrollArg],timestamp:Date.now(),message:`Mouse.move(${xArg}, ${yArg}, ${scrollArg})`});return}
if(property==='press'){const buttonArg=node.arguments&&node.arguments.length>0?await this.evaluateExpression(node.arguments[0]):'MOUSE_LEFT';this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Mouse.press',arguments:[buttonArg],timestamp:Date.now(),message:`Mouse.press(${buttonArg})`});return}
if(property==='release'){const buttonArg=node.arguments&&node.arguments.length>0?await this.evaluateExpression(node.arguments[0]):'MOUSE_LEFT';this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Mouse.release',arguments:[buttonArg],timestamp:Date.now(),message:`Mouse.release(${buttonArg})`});return}
if(property==='click'){const buttonArg=node.arguments&&node.arguments.length>0?await this.evaluateExpression(node.arguments[0]):'MOUSE_LEFT';this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Mouse.click',arguments:[buttonArg],timestamp:Date.now(),message:`Mouse.click(${buttonArg})`});return}
this.emitError(`Unknown Mouse method: ${property}`);return null}}
if(typeof object==='object'&&object&&object.className){if(object.className==='Servo'){if(property==='attach'){const pin=node.arguments&&node.arguments.length>0?await this.evaluateExpression(node.arguments[0]):9;this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Servo.attach',arguments:[pin],timestamp:Date.now(),message:`${object.objectId || 'servo'}.attach(${pin})`});return}
if(property==='write'){const angle=node.arguments&&node.arguments.length>0?await this.evaluateExpression(node.arguments[0]):0;this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Servo.write',arguments:[angle],timestamp:Date.now(),message:`${object.objectId || 'servo'}.write(${angle})`});return}
if(property==='read'){this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Servo.read',arguments:[],timestamp:Date.now(),message:`${object.objectId || 'servo'}.read()`});return 90}
this.emitError(`Unknown Servo method: ${property}`);return null}}
if(object instanceof ArduinoLibraryObject){if(node.arguments!==undefined){const args=[];if(node.arguments){for(const arg of node.arguments){args.push(await this.evaluateExpression(arg))}}
const result=object.callMethod(property,args);if(result&&typeof result==='object'&&result.type){this.emitCommand({...result,timestamp:Date.now()})}
return result}else{return object.getProperty(property)}}
if(object instanceof ArduinoPointer&&operator==='ARROW'){const dereferenced=object.getValue();if(!dereferenced){this.emitError(`Cannot dereference null pointer`);return null}
if(this.options.verbose){console.log(`Pointer dereference: ${object.targetVariable}->${property}`)}
if(dereferenced instanceof ArduinoStruct){if(hasArguments){const args=[];if(node.arguments){for(const arg of node.arguments){args.push(await this.evaluateExpression(arg))}}
return dereferenced.callMethod(property,args)}else{const result=dereferenced.getField(property);if(this.options.verbose){console.log(`Pointer member access: ${object.targetVariable}->${property} = ${result}`)}
this.emitCommand({type:'STRUCT_FIELD_ACCESS',struct:dereferenced.structName,field:property,value:result,timestamp:Date.now(),message:`${dereferenced.structName}.${property} = ${result}`});return result}}else{this.emitError(`Cannot dereference pointer to non-struct type`);return null}}
if(object&&typeof object==='object'&&!Array.isArray(object)&&!(object instanceof ArduinoString)&&!(object instanceof ArduinoNumber)&&!(object instanceof ArduinoPointer)&&!(object instanceof ArduinoFunctionPointer)){if(property in object){if(this.options.verbose){console.log(`Struct property access: ${property} = ${object[property]}`)}
return object[property]}else{this.emitError(`Property '${property}' not found in struct`);return null}}
this.emitError(`Property access not supported for this object type`);return null}
async executeArrayAccess(node){const index=await this.evaluateExpression(node.index);let array;let arrayName;if(node.identifier?.type==='ArrayAccessNode'){array=await this.executeArrayAccess(node.identifier);arrayName=`<nested array>`}else if(node.identifier?.value){arrayName=node.identifier.value;array=this.getVariable(arrayName)}else{this.emitError("Invalid array access: no array identifier");return null}
console.log(`DEBUG Array access: ${arrayName}[${index}]`);if(array===null||array===undefined){this.emitError(`Array is null or undefined`);return null}
if(!Array.isArray(array)){this.emitError(`Variable is not an array (type: ${typeof array})`);return null}
if(index<0||index>=array.length){this.emitError(`Array index ${index} out of bounds for array (length: ${array.length})`);return null}
return array[index]}
async executeArrayInitializer(node){if(!node.elements||!Array.isArray(node.elements)){console.log(`DEBUG Array initializer: no elements found`);return[]}
const allDesignated=node.elements.every(element=>element.type==='DesignatedInitializerNode');if(allDesignated&&node.elements.length>0){const struct={};for(const element of node.elements){const designatedResult=await this.evaluateExpression(element);Object.assign(struct,designatedResult)}
console.log(`DEBUG Struct initialized with designated initializers:`,struct);return struct}else{const array=[];for(const element of node.elements){const value=await this.evaluateExpression(element);array.push(value)}
console.log(`DEBUG Array initialized: [${array.join(', ')}]`);return array}}
async executeCastExpression(node){const value=await this.evaluateExpression(node.operand);const castType=node.castType;console.log(`DEBUG Type cast: (${castType})${value} (${typeof value})`);if(value===null||value===undefined){return null}
switch(castType){case 'int':if(typeof value==='number'){return Math.floor(value)}else if(typeof value==='string'){const intValue=parseInt(value,10);return isNaN(intValue)?0:intValue}else if(typeof value==='boolean'){return value?1:0}
return parseInt(value)||0;case 'float':case 'double':if(typeof value==='number'){return value}else if(typeof value==='string'){const floatValue=parseFloat(value);return isNaN(floatValue)?0.0:floatValue}else if(typeof value==='boolean'){return value?1.0:0.0}
return parseFloat(value)||0.0;case 'char':if(typeof value==='number'){return Math.floor(value)&0xFF}else if(typeof value==='string'&&value.length>0){return value.charCodeAt(0)}
return 0;case 'bool':return Boolean(value);default:console.log(`DEBUG Unsupported cast type: ${castType}`);return value}}
async executeTernaryExpression(node){const condition=await this.evaluateExpression(node.condition);console.log(`DEBUG Ternary: ${condition} ? ${node.consequent?.value || '[expr]'} : ${node.alternate?.value || '[expr]'}`);if(condition){return await this.evaluateExpression(node.consequent)}else{return await this.evaluateExpression(node.alternate)}}
async executeSwitchStatement(node){const discriminantValue=await this.evaluateExpression(node.discriminant);this.emitCommand({type:COMMAND_TYPES.SWITCH_STATEMENT,discriminant:discriminantValue,timestamp:Date.now(),message:`switch (${discriminantValue})`});console.log(`DEBUG Switch statement: ${discriminantValue}`);let matchFound=!1;let fallThrough=!1;for(const caseNode of node.cases||[]){if(caseNode.type==='CaseStatement'){const isDefault=caseNode.test===null;let shouldExecute=fallThrough;if(!fallThrough&&!isDefault){const testValue=await this.evaluateExpression(caseNode.test);shouldExecute=discriminantValue===testValue;this.emitCommand({type:COMMAND_TYPES.SWITCH_CASE,caseValue:testValue,matched:shouldExecute,timestamp:Date.now()});console.log(`DEBUG Case ${testValue}: ${shouldExecute ? 'match' : 'no match'}`)}else if(!fallThrough&&isDefault){shouldExecute=!matchFound;this.emitCommand({type:COMMAND_TYPES.SWITCH_CASE,caseValue:'default',matched:shouldExecute,timestamp:Date.now()});console.log(`DEBUG Default case: ${shouldExecute ? 'execute' : 'skip'}`)}
if(shouldExecute){matchFound=!0;fallThrough=!0;for(const stmt of caseNode.consequent||[]){if(stmt.type==='BreakStatement'){this.emitCommand({type:COMMAND_TYPES.BREAK_STATEMENT,timestamp:Date.now(),action:'exit_switch'});console.log(`DEBUG Break statement encountered`);return}
const result=await this.executeStatement(stmt);if(result&&result.type==='break'){return}}}}}
console.log(`DEBUG Switch completed: ${matchFound ? 'match found' : 'no match'}`)}
async executeIfStatement(node){const condition=await this.evaluateExpression(node.condition);this.emitCommand({type:COMMAND_TYPES.IF_STATEMENT,condition:condition,result:condition,branch:condition?'then':'else',timestamp:Date.now()});if(condition){if(node.consequent.type==='CompoundStmtNode'){await this.executeStatement(node.consequent)}else{this.variables.pushScope('if-then');try{await this.executeStatement(node.consequent)}finally{this.variables.popScope()}}}else if(node.alternate){if(node.alternate.type==='CompoundStmtNode'){await this.executeStatement(node.alternate)}else{this.variables.pushScope('if-else');try{await this.executeStatement(node.alternate)}finally{this.variables.popScope()}}}}
async executeWhileStatement(node){this.emitCommand({type:COMMAND_TYPES.WHILE_LOOP,phase:'start',timestamp:Date.now(),message:`while loop started`});this.variables.pushScope('while-loop');try{let iterations=0;const maxIterations=Math.min(this.options.maxLoopIterations,1000);while(await this.evaluateExpression(node.condition)&&iterations<maxIterations){this.emitCommand({type:COMMAND_TYPES.WHILE_LOOP,phase:'iteration',iteration:iterations,timestamp:Date.now(),message:`while loop iteration ${iterations}`});await this.executeStatement(node.body);iterations++;await this.checkExecutionState();if(!this.executionContext.shouldContinue){break}
await this.yieldExecution()}
const limitReached=iterations>=maxIterations;this.emitCommand({type:limitReached?COMMAND_TYPES.LOOP_LIMIT_REACHED:COMMAND_TYPES.WHILE_LOOP,phase:'end',iterations:iterations,timestamp:Date.now(),message:limitReached?`While loop limit reached: completed ${iterations} iterations (max: ${maxIterations})`:`while loop completed (${iterations} iterations)`});if(limitReached){if(this.options.verbose){console.log(`While loop limit reached: ${iterations} iterations`)}
this.executionContext.shouldContinue=!1}}finally{this.variables.popScope()}}
async executeDoWhileStatement(node){this.emitCommand({type:COMMAND_TYPES.DO_WHILE_LOOP,phase:'start',timestamp:Date.now(),message:`do-while loop started`});let iterations=0;const maxIterations=Math.min(this.options.maxLoopIterations,1000);do{this.emitCommand({type:COMMAND_TYPES.DO_WHILE_LOOP,phase:'iteration',iteration:iterations,timestamp:Date.now(),message:`do-while loop iteration ${iterations}`});await this.executeStatement(node.body);iterations++;await this.checkExecutionState();if(!this.executionContext.shouldContinue){break}
await this.yieldExecution()}while(await this.evaluateExpression(node.condition)&&iterations<maxIterations);const limitReached=iterations>=maxIterations;this.emitCommand({type:limitReached?COMMAND_TYPES.LOOP_LIMIT_REACHED:COMMAND_TYPES.DO_WHILE_LOOP,phase:'end',iterations:iterations,timestamp:Date.now(),message:limitReached?`Do-while loop limit reached: completed ${iterations} iterations (max: ${maxIterations})`:`do-while loop completed (${iterations} iterations)`});if(limitReached){if(this.options.verbose){console.log(`Do-while loop limit reached: ${iterations} iterations`)}
this.executionContext.shouldContinue=!1}}
async executeForStatement(node){this.emitCommand({type:COMMAND_TYPES.FOR_LOOP,phase:'start',timestamp:Date.now(),message:`for loop started`});this.variables.pushScope('for-loop');try{if(node.initializer){await this.executeStatement(node.initializer)}
let iterations=0;const maxIterations=Math.min(this.options.maxLoopIterations,1000);while((!node.condition||await this.evaluateExpression(node.condition))&&iterations<maxIterations){this.emitCommand({type:COMMAND_TYPES.FOR_LOOP,phase:'iteration',iteration:iterations,timestamp:Date.now(),message:`for loop iteration ${iterations}`});await this.executeStatement(node.body);if(node.increment){await this.evaluateExpression(node.increment)}
iterations++;await this.checkExecutionState();if(!this.executionContext.shouldContinue){break}
await this.yieldExecution()}
const limitReached=iterations>=maxIterations;this.emitCommand({type:limitReached?COMMAND_TYPES.LOOP_LIMIT_REACHED:COMMAND_TYPES.FOR_LOOP,phase:'end',iterations:iterations,timestamp:Date.now(),message:limitReached?`For loop limit reached: completed ${iterations} iterations (max: ${maxIterations})`:`for loop completed (${iterations} iterations)`});if(limitReached){if(this.options.verbose){console.log(`For loop limit reached: ${iterations} iterations`)}
this.executionContext.shouldContinue=!1}}finally{this.variables.popScope()}}
async executeReturnStatement(node){if(node.value){const returnValue=await this.evaluateExpression(node.value);if(this.currentFunction){const expectedType=this.currentFunction.returnType?.value||'void';const actualType=this.inferValueType(returnValue);if(!this.isReturnTypeCompatible(expectedType,actualType,returnValue)){console.error(`Return type error: Function '${this.currentFunction.name}' expects ${expectedType} but returns ${actualType}`)}}
return returnValue}
return null}
inferValueType(value){if(value instanceof ArduinoString)return'String';if(value instanceof ArduinoNumber)return value.arduinoType;if(Array.isArray(value))return'array';if(typeof value==='number'){return Number.isInteger(value)?'int':'float'}
if(typeof value==='boolean')return'bool';if(typeof value==='string')return'char*';return'unknown'}
isReturnTypeCompatible(expectedType,actualType,value){if(expectedType===actualType)return!0;if(expectedType==='void')return value===null;if((expectedType==='int'||expectedType==='float')&&(actualType==='int'||actualType==='float')){return!0}
if(expectedType==='String'&&(actualType==='string'||actualType==='char*')){return!0}
return!1}
findBestFunctionOverload(functionOverloads,argCount){for(const funcNode of functionOverloads){const paramCount=funcNode.parameters?funcNode.parameters.length:0;if(paramCount===argCount){return funcNode}}
return null}
async executeUserFunction(funcName,args){if(!this.functions.has(funcName)){this.emitError(`Function '${funcName}' is not defined`);return null}
const functionOverloads=this.functions.get(funcName);const actualArgs=args?args.length:0;const funcNode=this.findBestFunctionOverload(functionOverloads,actualArgs);if(!funcNode){const paramCounts=functionOverloads.map(f=>f.parameters?f.parameters.length:0);this.emitError(`No matching overload for function '${funcName}' with ${actualArgs} arguments. Available overloads: ${paramCounts.join(', ')} parameters`);return null}
this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:funcName,arguments:args,timestamp:Date.now(),message:`${funcName}(${args.join(', ')})`});console.log(`DEBUG User function call: ${funcName}(${args.join(', ')})`);this.variables.pushScope('function');const previousFunction=this.currentFunction;this.currentFunction={name:funcName,returnType:funcNode.returnType};try{this.restoreStaticVariables(funcName);if(funcNode.parameters){for(let i=0;i<funcNode.parameters.length;i++){const param=funcNode.parameters[i];let paramName=null;if(param.declarator?.value){paramName=param.declarator.value}else if(param.declarator?.identifier?.value){paramName=param.declarator.identifier.value}else if(param.declarator?.declarator?.value){paramName=param.declarator.declarator.value}
const argValue=i<args.length?args[i]:null;if(paramName){this.variables.set(paramName,argValue);console.log(`DEBUG Parameter: ${paramName} = ${argValue} (type: ${typeof argValue})`);if(Array.isArray(argValue)){console.log(`DEBUG Array parameter: ${paramName} = [${argValue.join(', ')}] (length: ${argValue.length})`)}}else{console.log(`DEBUG Failed to extract parameter name from:`,param)}}}
let returnValue=null;if(funcNode.body){returnValue=await this.executeFunctionBody(funcNode.body)}
console.log(`DEBUG Function ${funcName} returned: ${returnValue}`);return returnValue}finally{this.variables.popScope();this.currentFunction=previousFunction}}
async executeFunctionBody(bodyNode){if(!bodyNode||bodyNode.type!=='CompoundStmtNode'){return null}
let statementCount=0;const maxStatements=1000;for(const statement of bodyNode.children||[]){statementCount++;if(statementCount>maxStatements){this.emitError(`User function exceeded maximum statements (${maxStatements}) - possible infinite recursion`);return null}
await this.checkExecutionState();if(!this.executionContext.shouldContinue){return null}
if(statement.type==='ReturnStatement'){if(statement.value){const returnValue=await this.evaluateExpression(statement.value);console.log(`DEBUG Return statement: ${returnValue}`);return returnValue}else{return null}}else{const result=await this.executeStatement(statement);if(result&&result.type==='return'){return result.value}}
await this.yieldExecution()}
return null}
async arduinoDigitalRead(args){if(args.length<1){this.emitError("digitalRead requires 1 argument: pin");return 0}
const pin=args[0];const numericPin=this.getNumericValue(pin);if(numericPin<0||numericPin>127){this.emitError(`Invalid pin number: ${numericPin}. Pin must be a number between 0-127`);return 0}
const requestId=`digitalRead_${Date.now()}_${Math.random()}`;this.emitCommand({type:COMMAND_TYPES.DIGITAL_READ_REQUEST,pin:pin,requestId:requestId,timestamp:Date.now()});try{const response=await this.waitForResponse(requestId,5000);return response.value}catch(error){this.emitError(`digitalRead timeout: ${error.message}`);const pinState=this.pinStates.get(pin);return pinState?pinState.value:0}}
arduinoAnalogWrite(args){if(args.length<2){this.emitError("analogWrite requires 2 arguments: pin, value");return}
const pin=args[0];const value=args[1];const numericPin=this.getNumericValue(pin);if(numericPin<0||numericPin>127){this.emitError(`Invalid pin number: ${numericPin}. Pin must be a number between 0-127`);return}
const numericValue=this.getNumericValue(value);if(numericValue<0||numericValue>255){this.emitError(`Invalid analog value: ${numericValue}. Analog value must be between 0-255`);return}
this.emitCommand({type:COMMAND_TYPES.ANALOG_WRITE,pin:pin,value:this.sanitizeForCommand(value),timestamp:Date.now()})}
async arduinoAnalogRead(args){if(args.length<1){this.emitError("analogRead requires 1 argument: pin");return 0}
const pin=args[0];const numericPin=this.getNumericValue(pin);if(numericPin<0||numericPin>127){this.emitError(`Invalid analog pin: ${numericPin}. Pin must be a number between 0-127`);return 0}
const requestId=`analogRead_${Date.now()}_${Math.random()}`;this.emitCommand({type:COMMAND_TYPES.ANALOG_READ_REQUEST,pin:pin,requestId:requestId,timestamp:Date.now()});try{const response=await this.waitForResponse(requestId,5000);return response.value}catch(error){this.emitError(`analogRead timeout: ${error.message}`);return Math.floor(Math.random()*1024)}}
arduinoDelayMicroseconds(args){if(args.length<1){this.emitError("delayMicroseconds requires 1 argument: microseconds");return}
const us=args[0];this.emitCommand({type:COMMAND_TYPES.DELAY_MICROSECONDS,duration:us,timestamp:Date.now()})}
async arduinoMillis(){const requestId=`millis_${Date.now()}_${Math.random()}`;this.emitCommand({type:COMMAND_TYPES.MILLIS_REQUEST,requestId:requestId,timestamp:Date.now()});try{const response=await this.waitForResponse(requestId,1000);return new ArduinoNumber(response.value,'unsigned long')}catch(error){this.emitError(`millis timeout: ${error.message}`);const elapsed=Date.now()-this.programStartTime;return new ArduinoNumber(elapsed,'unsigned long')}}
async arduinoMicros(){const requestId=`micros_${Date.now()}_${Math.random()}`;this.emitCommand({type:COMMAND_TYPES.MICROS_REQUEST,requestId:requestId,timestamp:Date.now()});try{const response=await this.waitForResponse(requestId,1000);return new ArduinoNumber(response.value,'unsigned long')}catch(error){this.emitError(`micros timeout: ${error.message}`);const elapsed=(Date.now()-this.programStartTime)*1000;return new ArduinoNumber(elapsed,'unsigned long')}}
arduinoPulseIn(args){if(args.length<2){this.emitError("pulseIn() requires at least 2 arguments: pin, value");return 0}
const pin=args[0];const value=args[1];const timeout=args.length>2?args[2]:1000000;const mockDuration=1500;this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'pulseIn',arguments:[pin,value,timeout],pin:pin,value:this.sanitizeForCommand(value),timeout:timeout,timestamp:Date.now(),message:`pulseIn(${pin}, ${value}${args.length > 2 ? ', ' + timeout : ''})`});if(this.options.verbose){console.log(`pulseIn(${pin}, ${value}) -> ${mockDuration}Î¼s`)}
return new ArduinoNumber(mockDuration,'unsigned long')}
arduinoTone(args){if(args.length<2){this.emitError("tone requires at least 2 arguments: pin, frequency");return}
const pin=args[0];const frequency=args[1];const duration=args.length>2?args[2]:null;this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'tone',arguments:duration!==null?[pin,frequency,duration]:[pin,frequency],pin:pin,frequency:frequency,duration:duration,timestamp:Date.now(),message:duration!==null?`tone(${pin}, ${frequency}, ${duration})`:`tone(${pin}, ${frequency})`});if(this.options.verbose){console.log(`tone(${pin}, ${frequency}${duration !== null ? ', ' + duration : ''})`)}}
arduinoNoTone(args){if(args.length<1){this.emitError("noTone requires 1 argument: pin");return}
const pin=args[0];this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'noTone',arguments:[pin],pin:pin,timestamp:Date.now(),message:`noTone(${pin})`});if(this.options.verbose){console.log(`noTone(${pin})`)}}
arduinoIsDigit(args){if(args.length<1){this.emitError("isDigit requires 1 argument: character");return!1}
const char=args[0];let charCode;if(typeof char==='string'&&char.length>0){charCode=char.charCodeAt(0)}else if(typeof char==='number'){charCode=char}else{return!1}
return charCode>=48&&charCode<=57}
arduinoIsPunct(args){if(args.length<1){this.emitError("isPunct requires 1 argument: character");return!1}
const char=args[0];let charStr;if(typeof char==='string'){charStr=char}else if(typeof char==='number'){charStr=String.fromCharCode(char)}else{return!1}
return/[!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~]/.test(charStr)}
arduinoIsAlpha(args){if(args.length<1){this.emitError("isAlpha requires 1 argument: character");return!1}
const char=args[0];let charCode;if(typeof char==='string'&&char.length>0){charCode=char.charCodeAt(0)}else if(typeof char==='number'){charCode=char}else{return!1}
return(charCode>=65&&charCode<=90)||(charCode>=97&&charCode<=122)}
arduinoIsAlphaNumeric(args){if(args.length<1){this.emitError("isAlphaNumeric requires 1 argument: character");return!1}
return this.arduinoIsAlpha(args)||this.arduinoIsDigit(args)}
arduinoIsSpace(args){if(args.length<1){this.emitError("isSpace requires 1 argument: character");return!1}
const char=args[0];let charCode;if(typeof char==='string'&&char.length>0){charCode=char.charCodeAt(0)}else if(typeof char==='number'){charCode=char}else{return!1}
return charCode===32||(charCode>=9&&charCode<=13)}
arduinoIsUpperCase(args){if(args.length<1){this.emitError("isUpperCase requires 1 argument: character");return!1}
const char=args[0];let charCode;if(typeof char==='string'&&char.length>0){charCode=char.charCodeAt(0)}else if(typeof char==='number'){charCode=char}else{return!1}
return charCode>=65&&charCode<=90}
arduinoIsLowerCase(args){if(args.length<1){this.emitError("isLowerCase requires 1 argument: character");return!1}
const char=args[0];let charCode;if(typeof char==='string'&&char.length>0){charCode=char.charCodeAt(0)}else if(typeof char==='number'){charCode=char}else{return!1}
return charCode>=97&&charCode<=122}
arduinoIsHexadecimalDigit(args){if(args.length<1){this.emitError("isHexadecimalDigit requires 1 argument: character");return!1}
const char=args[0];let charCode;if(typeof char==='string'&&char.length>0){charCode=char.charCodeAt(0)}else if(typeof char==='number'){charCode=char}else{return!1}
return(charCode>=48&&charCode<=57)||(charCode>=65&&charCode<=70)||(charCode>=97&&charCode<=102)}
arduinoIsAscii(args){if(args.length<1){this.emitError("isAscii requires 1 argument: character");return!1}
const char=args[0];let charCode;if(typeof char==='string'&&char.length>0){charCode=char.charCodeAt(0)}else if(typeof char==='number'){charCode=char}else{return!1}
return charCode>=0&&charCode<=127}
arduinoIsWhitespace(args){if(args.length<1){this.emitError("isWhitespace requires 1 argument: character");return!1}
const char=args[0];let charCode;if(typeof char==='string'&&char.length>0){charCode=char.charCodeAt(0)}else if(typeof char==='number'){charCode=char}else{return!1}
return charCode===32||charCode===9||charCode===10||charCode===13||charCode===12||charCode===11}
arduinoIsControl(args){if(args.length<1){this.emitError("isControl requires 1 argument: character");return!1}
const char=args[0];let charCode;if(typeof char==='string'&&char.length>0){charCode=char.charCodeAt(0)}else if(typeof char==='number'){charCode=char}else{return!1}
return(charCode>=0&&charCode<=31)||charCode===127}
arduinoIsGraph(args){if(args.length<1){this.emitError("isGraph requires 1 argument: character");return!1}
const char=args[0];let charCode;if(typeof char==='string'&&char.length>0){charCode=char.charCodeAt(0)}else if(typeof char==='number'){charCode=char}else{return!1}
return charCode>=33&&charCode<=126}
arduinoIsPrintable(args){if(args.length<1){this.emitError("isPrintable requires 1 argument: character");return!1}
const char=args[0];let charCode;if(typeof char==='string'&&char.length>0){charCode=char.charCodeAt(0)}else if(typeof char==='number'){charCode=char}else{return!1}
return charCode>=32&&charCode<=126}
avrClockPrescaleSet(args){this.emitCommand({type:'AVR_FUNCTION_CALL',function:'clock_prescale_set',args:args,message:`clock_prescale_set(${args.join(', ')})`,timestamp:Date.now()});if(this.options.verbose){console.log(`AVR clock prescaler set: ${args.join(', ')}`)}
return undefined}
async executeSerialMethod(method,args){const evaluatedArgs=[];const originalArgs=args;if(args){for(const arg of args){evaluatedArgs.push(await this.evaluateExpression(arg))}}
switch(method){case 'begin':if(evaluatedArgs.length<1){this.emitError("Serial.begin requires 1 argument: baud rate");return}
const baudRate=evaluatedArgs[0];this.hardwareState.serial.initialized=!0;this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Serial.begin',arguments:[baudRate],baudRate:baudRate,timestamp:Date.now(),message:`Serial.begin(${baudRate})`});if(this.options.verbose){console.log(`Serial.begin(${baudRate})`)}
return;case 'print':if(evaluatedArgs.length<1){this.emitError("Serial.print requires 1 argument: data");return}
const printData=this.formatSerialData(evaluatedArgs[0]);const printDisplayArg=this.formatArgumentForDisplay(evaluatedArgs[0],originalArgs[0]);this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Serial.print',arguments:[printDisplayArg],data:printData,timestamp:Date.now(),message:`Serial.print(${printDisplayArg})`});if(this.options.verbose){console.log(`Serial.print(${printData})`)}
return;case 'println':if(evaluatedArgs.length===0){this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Serial.println',arguments:[],timestamp:Date.now(),message:`Serial.println()`});if(this.options.verbose){console.log(`Serial.println()`)}
return}else{const printlnData=this.formatSerialData(evaluatedArgs[0]);const printlnDisplayArg=this.formatArgumentForDisplay(evaluatedArgs[0],originalArgs[0]);this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Serial.println',arguments:[printlnDisplayArg],data:printlnData,timestamp:Date.now(),message:`Serial.println(${printlnDisplayArg})`});if(this.options.verbose){console.log(`Serial.println(${printlnData})`)}
return}
case 'available':const availableBytes=(Math.random()<0.1)?1:0;this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Serial.available',arguments:[],timestamp:Date.now(),message:`Serial.available()`});if(this.options.verbose){console.log(`Serial.available() -> ${availableBytes}`)}
return availableBytes;case 'read':const readByte=65;this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Serial.read',arguments:[],timestamp:Date.now(),message:`Serial.read()`});if(this.options.verbose){console.log(`Serial.read() -> ${readByte}`)}
return readByte;case 'write':if(evaluatedArgs.length<1){this.emitError("Serial.write requires 1 argument: data");return}
const writeData=evaluatedArgs[0];this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Serial.write',arguments:[writeData],timestamp:Date.now(),message:`Serial.write(${writeData})`});if(this.options.verbose){console.log(`Serial.write(${writeData})`)}
return;case 'peek':const peekByte=65;this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Serial.peek',arguments:[],timestamp:Date.now(),message:`Serial.peek()`});if(this.options.verbose){console.log(`Serial.peek() -> ${peekByte}`)}
return peekByte;case 'flush':this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Serial.flush',arguments:[],timestamp:Date.now(),message:`Serial.flush()`});if(this.options.verbose){console.log(`Serial.flush()`)}
return;case 'setTimeout':if(evaluatedArgs.length<1){this.emitError("Serial.setTimeout requires 1 argument: timeout in milliseconds");return}
const timeout=evaluatedArgs[0];this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Serial.setTimeout',arguments:[timeout],timestamp:Date.now(),message:`Serial.setTimeout(${timeout})`});if(this.options.verbose){console.log(`Serial.setTimeout(${timeout})`)}
return;case 'parseInt':const parsedInt=Math.floor(Math.random()*1024);this.emitCommand({type:COMMAND_TYPES.FUNCTION_CALL,function:'Serial.parseInt',arguments:[],timestamp:Date.now(),message:`Serial.parseInt()`});if(this.options.verbose){console.log(`Serial.parseInt() -> ${parsedInt}`)}
return parsedInt;default:this.emitError(`Unknown Serial method: ${method}`);return null}}
async executeStaticMethod(className,methodName,args){const evaluatedArgs=[];if(args){for(const arg of args){evaluatedArgs.push(await this.evaluateExpression(arg))}}
return await this.executeLibraryStaticMethod(className,methodName,evaluatedArgs)}
async executeLibraryStaticMethod(libraryName,methodName,args){const library=ARDUINO_LIBRARIES[libraryName];if(!library){this.emitError(`Unknown library: ${libraryName}`);return null}
if(!library.staticMethods.includes(methodName)){this.emitError(`Unknown static method ${libraryName}.${methodName}`);return null}
this.emitCommand({type:'LIBRARY_STATIC_METHOD_CALL',library:libraryName,method:methodName,args:args,timestamp:Date.now(),message:`${libraryName}.${methodName}(${args.join(', ')})`});if(this.options.verbose){console.log(`Static method: ${libraryName}.${methodName}(${args.join(', ')})`)}
if(methodName==='Color'||methodName==='ColorHSV'){return 0x000000}
return null}
formatSerialData(data){if(data instanceof ArduinoString){return data.value}else if(typeof data==='string'){return data}else if(typeof data==='boolean'){return data?'true':'false'}else if(data===null||data===undefined){return'null'}else{return String(data)}}
formatArgumentForDisplay(evaluatedValue,originalArg){if(originalArg&&originalArg.type==='StringLiteralNode'){return `"${evaluatedValue}"`}else if(originalArg&&originalArg.type==='CharLiteralNode'){return `'${evaluatedValue}'`}else if(evaluatedValue instanceof ArduinoString){return `"${evaluatedValue.value}"`}else if(typeof evaluatedValue==='string'&&evaluatedValue.length>0){if(!/^\d+(\.\d+)?$/.test(evaluatedValue)&&evaluatedValue!=='true'&&evaluatedValue!=='false'){return `"${evaluatedValue}"`}
return String(evaluatedValue)}else{return String(evaluatedValue)}}
arduinoMap(args){if(args.length<5){this.emitError("map requires 5 arguments: value, fromLow, fromHigh, toLow, toHigh");return 0}
const[value,fromLow,fromHigh,toLow,toHigh]=args;const result=(value-fromLow)*(toHigh-toLow)/(fromHigh-fromLow)+toLow;return Math.round(result)}
arduinoConstrain(args){if(args.length<3){this.emitError("constrain requires 3 arguments: value, min, max");return 0}
const[value,minVal,maxVal]=args;return Math.max(minVal,Math.min(maxVal,value))}
arduinoRandom(args){if(args.length===1){return Math.floor(Math.random()*args[0])}else if(args.length===2){const[minVal,maxVal]=args;return Math.floor(Math.random()*(maxVal-minVal))+minVal}else{this.emitError("random requires 1 or 2 arguments");return 0}}
getNumericValue(value){if(value==null)return 0;if(value instanceof ArduinoNumber){return value.value}
if(typeof value==='number'){return value}
if(typeof value==='string'){const parsed=Number(value);if(!isNaN(parsed)){return parsed}}
if(typeof value==='object'&&value.value!==undefined){return this.getNumericValue(value.value)}
const converted=Number(value);if(!isNaN(converted)){return converted}
return 0}
sanitizeForCommand(obj){if(obj===null||obj===undefined){return obj}
if(obj&&obj.constructor&&obj.constructor.name==='ArduinoObject'){return{__type:'ArduinoObject',className:obj.className,constructorArgs:obj.constructorArgs,objectId:obj.objectId}}
return obj}
getVariable(name){if(this.variables.has(name)){const metadata=this.variables.getMetadata(name);if(metadata?.isStatic){const staticValue=this.staticVariables.get(metadata.staticKey);if(this.options.verbose){console.log(`Getting static variable ${name} = ${staticValue} (key: ${metadata.staticKey})`)}
return staticValue}
if(metadata?.isExtern&&metadata?.isForwardDeclaration&&metadata?.value===undefined){if(this.options.verbose){console.log(`Extern forward declaration ${name} not yet defined`)}
this.emitError(`Extern variable '${name}' used but not defined`);return 0}
if(this.options.verbose){console.log(`Getting variable ${name} = ${metadata?.value} (initialized: ${metadata?.isInitialized}, used: ${metadata?.isUsed}, extern: ${metadata?.isExtern})`)}
const staticKey=`global_${name}`;if(this.staticVariables.has(staticKey)){const staticValue=this.staticVariables.get(staticKey);if(this.options.verbose){console.log(`Getting static variable ${name} = ${staticValue}`)}
return staticValue}
return metadata?.value}
const constantValue=this.evaluateConstant(name);if(constantValue!==name){if(this.options.verbose){console.log(`Getting constant ${name} = ${constantValue}`)}
return constantValue}
this.emitError(`Undefined variable: ${name}`);return 0}
restoreStaticVariables(funcName){for(const[staticKey,staticValue]of this.staticVariables.entries()){if(staticKey.startsWith(`${funcName}_`)){const varName=staticKey.substring(`${funcName}_`.length);this.variables.set(varName,staticValue,{isDeclaration:!1,isStatic:!0,staticKey:staticKey});if(this.options.verbose){console.log(`Restored static variable ${varName} = ${staticValue} (key: ${staticKey})`)}}}}
setState(newState){const oldState=this.state;this.state=newState;if(this.onStateChange){this.onStateChange(newState,oldState)}
if(this.options.verbose){console.log(`State changed: ${oldState} â†’ ${newState}, Phase: ${this.executionContext.phase}, Loop: ${this.executionContext.loopIteration}`)}}
emitCommand(command){this.commandHistory.push(command);if(this.onCommand){this.onCommand(command)}
if(this.options.verbose){console.log("Command:",command)}}
emitError(message){const now=Date.now();if(now-this.lastErrorTime<1000){this.consecutiveErrors++}else{this.consecutiveErrors=1}
this.lastErrorTime=now;let enhancedMessage=message;let locationInfo=null;if(this.currentNode){locationInfo=this.extractLocationInfo(this.currentNode);if(locationInfo){enhancedMessage=`Line ${locationInfo.line}, Column ${locationInfo.column}: ${message}`;if(locationInfo.context){enhancedMessage+=`\n  â†’ ${locationInfo.context}`}}}
const error={type:COMMAND_TYPES.ERROR,message:enhancedMessage,originalMessage:message,node:this.currentNode,location:locationInfo,timestamp:now};if(this.consecutiveErrors>=this.maxConsecutiveErrors){error.message=`STOPPING DUE TO ERROR CASCADE: ${message} (${this.consecutiveErrors} consecutive errors)`;this.setState(EXECUTION_STATE.ERROR);this.emitCommand(error);this.executionContext.shouldContinue=!1;this.executionContext.isExecuting=!1;if(this.onError){this.onError(error)}
return}
this.setState(EXECUTION_STATE.ERROR);this.emitCommand(error);if(this.onError){this.onError(error)}}
extractLocationInfo(node){if(!node)return null;let line=null;let column=null;let context=null;if(node.line!==undefined&&node.column!==undefined){line=node.line;column=node.column}
if(!line&&node.token){if(node.token.line!==undefined&&node.token.column!==undefined){line=node.token.line;column=node.token.column}}
if(!line&&node.value&&typeof node.value==='object'){if(node.value.line!==undefined&&node.value.column!==undefined){line=node.value.line;column=node.value.column}}
if(!line&&node.type==='FuncCallNode'&&node.callee){if(node.callee.line!==undefined&&node.callee.column!==undefined){line=node.callee.line;column=node.callee.column}}
if(!line&&node.expression){const innerInfo=this.extractLocationInfo(node.expression);if(innerInfo&&innerInfo.line!==undefined){return innerInfo}}
if(!line&&node.type==='VarDeclNode'&&node.declarations){for(const decl of node.declarations){if(decl.initializer){const initInfo=this.extractLocationInfo(decl.initializer);if(initInfo&&initInfo.line!==undefined){line=initInfo.line;column=initInfo.column;break}}}}
if(node.type){switch(node.type){case 'IdentifierNode':context=`identifier '${node.value}'`;break;case 'FuncCallNode':const funcName=node.callee?.value||'unknown';context=`function call '${funcName}()'`;break;case 'BinaryOpNode':context=`binary operation '${node.operator}'`;break;case 'AssignmentNode':const varName=node.left?.value||'variable';context=`assignment to '${varName}'`;break;case 'VarDeclNode':const declName=node.declarator?.value||'variable';context=`declaration of '${declName}'`;break;case 'ExpressionStatement':if(node.expression){const innerInfo=this.extractLocationInfo(node.expression);if(innerInfo)return innerInfo}
context='expression statement';break;default:context=`${node.type.replace('Node', '').toLowerCase()}`;break}}
return(line!==null&&column!==null)?{line,column,context}:(context?{context}:null)}
emitWarning(message){const warning={type:COMMAND_TYPES.WARNING||'WARNING',message:message,node:this.currentNode,timestamp:Date.now()};this.emitCommand(warning);if(this.onWarning){this.onWarning(warning)}}
getControlFlowName(node){switch(node.type){case 'ReturnStatement':return'return statement';case 'BreakStatement':return'break statement';case 'ContinueStatement':return'continue statement';default:return'control flow statement'}}
visitNode(node){if(this.onNodeVisit){this.onNodeVisit(node)}}
getState(){return this.state}
getVariables(){return Object.fromEntries(this.variables.entries())}
getPinStates(){return Object.fromEntries(this.pinStates)}
getCommandHistory(){return[...this.commandHistory]}
clearCommandHistory(){this.commandHistory=[]}
async executeCaseStatement(node){const testValue=node.test?await this.evaluateExpression(node.test):null;const consequent=node.consequent||[];if(this.options.verbose){console.log(`Case statement: ${testValue !== null ? testValue : 'default'}`)}
return{type:'case_result',testValue:testValue,consequent:consequent,isDefault:testValue===null}}
handleEmptyStatement(node){if(this.options.verbose){console.log('Empty statement encountered')}
return{type:'empty_statement_result',handled:!0}}
async executeRangeBasedForStatement(node){const declaration=node.declaration;const range=node.range;const body=node.body;if(!declaration||!range||!body){this.emitError("Invalid range-based for statement: missing declaration, range, or body");return}
const rangeValue=await this.evaluateExpression(range);if(this.options.verbose){console.log(`Range-based for loop over ${typeof rangeValue}`)}
const varName=declaration.declarator?.value||declaration.declarations?.[0]?.declarator?.value;if(!varName){this.emitError("Invalid range-based for: no variable name");return}
let iterationValues=[];if(Array.isArray(rangeValue)){iterationValues=rangeValue}else if(rangeValue&&typeof rangeValue==='object'&&rangeValue.type==='array'){iterationValues=rangeValue.elements||[]}else if(typeof rangeValue==='string'){iterationValues=rangeValue.split('')}else if(typeof rangeValue==='number'){iterationValues=Array.from({length:rangeValue},(_,i)=>i)}else{iterationValues=[rangeValue]}
for(const iterValue of iterationValues){this.variables.set(varName,iterValue);const result=await this.executeStatement(body);if(result&&result.type==='break'){break}else if(result&&result.type==='continue'){continue}}
if(this.options.verbose){console.log(`Range-based for loop completed (${iterationValues.length} iterations)`)}}
async executeTernaryExpression(node){const condition=node.condition;const consequent=node.consequent;const alternate=node.alternate;if(!condition||!consequent||!alternate){this.emitError("Invalid ternary expression: missing condition, consequent, or alternate");return null}
const conditionResult=await this.evaluateExpression(condition);const isTrue=Boolean(conditionResult);if(this.options.verbose){console.log(`Ternary expression: ${conditionResult} ? ... : ...`)}
return isTrue?await this.evaluateExpression(consequent):await this.evaluateExpression(alternate)}
async executePostfixExpression(node){const operand=node.operand;const operator=node.op;if(!operand||!operator){this.emitError("Invalid postfix expression: missing operand or operator");return null}
const operatorValue=operator.value||operator;if(this.options.verbose){console.log(`Postfix expression: ${operand.value || 'expression'}${operatorValue}`)}
const currentValue=await this.evaluateExpression(operand);switch(operatorValue){case '++':if(operand.type==='IdentifierNode'){const varName=operand.value;const newValue=(parseFloat(currentValue)||0)+1;this.variables.set(varName,newValue);const varInfo=this.variables.get(varName);if(varInfo?.metadata?.isStatic){this.staticVariables.set(varInfo.metadata.staticKey,newValue);if(this.options.verbose){console.log(`Updated static variable ${varName} = ${newValue} (key: ${varInfo.metadata.staticKey})`)}}}
return currentValue;case '--':if(operand.type==='IdentifierNode'){const varName=operand.value;const newValue=(parseFloat(currentValue)||0)-1;this.variables.set(varName,newValue);const varInfo=this.variables.get(varName);if(varInfo?.metadata?.isStatic){this.staticVariables.set(varInfo.metadata.staticKey,newValue);if(this.options.verbose){console.log(`Updated static variable ${varName} = ${newValue} (key: ${varInfo.metadata.staticKey})`)}}}
return currentValue;default:this.emitError(`Unsupported postfix operator: ${operatorValue}`);return currentValue}}
async executeCastExpression(node){const castType=node.castType;const operand=node.operand;if(!castType||!operand){this.emitError("Invalid cast expression: missing cast type or operand");return null}
const sourceValue=await this.evaluateExpression(operand);const targetType=castType.value||castType;if(this.options.verbose){console.log(`C-style cast: (${targetType})${sourceValue}`)}
switch(targetType){case 'int':return parseInt(sourceValue)||0;case 'float':case 'double':return parseFloat(sourceValue)||0.0;case 'char':return String(sourceValue).charAt(0)||'\0';case 'bool':return Boolean(sourceValue);default:return{type:'cast_expression_result',targetType:targetType,sourceValue:sourceValue,castStyle:'c_style'}}}
async executeNewExpression(node){const allocationType=node.allocationType;const size=node.size;const args=node.arguments||[];if(!allocationType){this.emitError("Invalid new expression: missing allocation type");return null}
const typeName=allocationType.value||allocationType;if(this.options.verbose){console.log(`New expression: new ${typeName}${size ? `[${size}]` : ''}(${args.length} args)`)}
const evaluatedArgs=[];for(const arg of args){evaluatedArgs.push(await this.evaluateExpression(arg))}
if(size){const arraySize=await this.evaluateExpression(size);return{type:'dynamic_array',elementType:typeName,size:arraySize,elements:new Array(arraySize).fill(null),isHeapAllocated:!0}}else{const objectInstance=this.createLibraryObject(typeName,evaluatedArgs);objectInstance.isHeapAllocated=!0;return objectInstance}}
handleStructDeclaration(node){const structName=node.name?.value||node.name;const members=node.members||[];if(this.options.verbose){console.log(`Struct declaration: ${structName || 'anonymous'} with ${members.length} members`)}
const structDef={type:'struct_definition',name:structName,members:members,isStruct:!0};if(structName){this.structTypes=this.structTypes||new Map();this.structTypes.set(structName,structDef);if(this.options.verbose){console.log(`Stored struct type: ${structName}`)}}else{console.log(`DEBUG: No structName to store, skipping`)}
return structDef}
async handleEnumDeclaration(node){const enumName=node.name?.value;const members=node.members||[];if(this.options.verbose){console.log(`Enum declaration: ${enumName || 'anonymous'} with ${members.length} members`)}
const enumValues=new Map();let currentValue=0;for(const member of members){const memberName=member.name?.value;const memberValue=member.value?await this.evaluateExpression(member.value):currentValue;if(memberName){enumValues.set(memberName,memberValue);this.variables.set(memberName,memberValue)}
currentValue=memberValue+1}
const enumDef={type:'enum_definition',name:enumName,members:members,values:enumValues,isEnum:!0};if(enumName){this.enumTypes=this.enumTypes||new Map();this.enumTypes.set(enumName,enumDef)}
return enumDef}
async createStructVariable(structTypeName,variableName){if(this.options.verbose){console.log(`Creating struct variable: ${variableName} of type ${structTypeName}`)}
if(!this.structTypes){this.structTypes=new Map()}
const structDef=this.structTypes.get(structTypeName);if(!structDef){this.emitError(`Struct type '${structTypeName}' not defined`);return}
const structFields={};for(const member of structDef.members){if(member.declarations){for(const memberDecl of member.declarations){const fieldName=memberDecl.declarator?.value||memberDecl.declarator?.identifier?.value;const fieldType=member.memberType?.value||member.memberType;if(fieldName){structFields[fieldName]=fieldType}}}else{const fieldName=member.declarator?.value||member.declarator?.identifier?.value;const fieldType=member.memberType?.value||member.memberType;if(fieldName){structFields[fieldName]=fieldType}}}
const structInstance=new ArduinoStruct(structTypeName,structFields);const result=this.variables.set(variableName,structInstance,{isDeclaration:!0,declaredType:structTypeName,isStruct:!0});if(!result.success){this.emitError(result.message||`Failed to declare struct variable '${variableName}'`);return}
if(this.options.verbose){console.log(`Struct variable created: ${variableName} of type ${structTypeName} with fields [${Object.keys(structFields).join(', ')}]`)}
this.emitCommand({type:COMMAND_TYPES.VAR_SET,variable:variableName,value:structInstance,structType:structTypeName,timestamp:Date.now()})}
handleUnionDeclaration(node){const unionName=node.name?.value;const members=node.members||[];const variables=node.variables||[];if(this.options.verbose){console.log(`Union declaration: ${unionName || 'anonymous'} with ${members.length} members`)}
const unionDef={type:'union_definition',name:unionName,members:members,variables:variables,isUnion:!0};if(unionName){this.unionTypes=this.unionTypes||new Map();this.unionTypes.set(unionName,unionDef)}
return unionDef}
async executeCommaExpression(node){await this.evaluateExpression(node.left);return await this.evaluateExpression(node.right)}
async executeRangeExpression(node){const start=await this.evaluateExpression(node.start);const end=await this.evaluateExpression(node.end);return{type:'range',start,end}}
handleStructType(node){const structName=node.name;if(this.options.verbose){console.log(`Struct type reference: ${structName}`)}
this.pendingStructType=structName;return{type:'struct_type_reference',structName:structName}}
extractIdentifiersFromCommaExpression(node){const identifiers=[];function extractFromNode(n){if(n.type==='IdentifierNode'){identifiers.push(n.value)}else if(n.type==='CommaExpression'){extractFromNode(n.left);extractFromNode(n.right)}}
extractFromNode(node);return identifiers}
handleEnumType(node){return{type:'enum_type_ref',enumName:node.name||'anonymous',values:this.getEnumValues(node.name)||{}}}
async handleEnumMember(node){const value=node.value?await this.evaluateExpression(node.value):undefined;return{type:'enum_member',name:node.name,value:value}}
handleUnionType(node){return{type:'union_type_ref',unionName:node.name||'anonymous',size:this.getUnionSize(node.name)||0}}
executeTypedefDeclaration(node){const aliasName=node.typeName;if(this.options.verbose){console.log(`Processing typedef declaration: ${aliasName}`)}
if(!this.typeAliases){this.typeAliases=new Map()}
if(node.baseType?.type==='StructDeclaration'){const structDef=node.baseType;if(!this.structTypes){this.structTypes=new Map()}
this.structTypes.set(aliasName,structDef);this.typeAliases.set(aliasName,'struct');if(this.options.verbose){console.log(`Registered typedef struct: ${aliasName} with ${structDef.members?.length || 0} members`)}}else{this.typeAliases.set(aliasName,node.baseType);if(this.options.verbose){console.log(`Registered typedef alias: ${aliasName}`)}}
return{type:'typedef_registered',alias:aliasName,baseType:node.baseType}}
executeClassDeclaration(node){const className=node.className||node.name;if(this.options.verbose){console.log(`Class declaration: ${className}`)}
if(!this.classes){this.classes=new Map()}
this.classes.set(className,{name:className,members:node.members||[],methods:node.methods||[],constructors:node.constructors||[]});return{type:'class_registered',className}}
executeConstructorDeclaration(node){const className=node.className||node.name;if(this.options.verbose){console.log(`Constructor declaration: ${className}`)}
return{type:'constructor_registered',className}}
executeMemberFunctionDeclaration(node){const className=node.className||node.class;const methodName=node.methodName||node.name;if(this.options.verbose){console.log(`Member function declaration: ${className}::${methodName}`)}
return{type:'member_function_registered',className,methodName}}
executeTemplateDeclaration(node){const templateName=node.templateName||node.name;if(this.options.verbose){console.log(`Template declaration: ${templateName}`)}
if(!this.templates){this.templates=new Map()}
this.templates.set(templateName,{name:templateName,parameters:node.parameters||[],body:node.body});return{type:'template_registered',templateName}}
async executeLambdaExpression(node){const captures=node.captures||[];const parameters=node.parameters||[];const body=node.body;if(this.options.verbose){console.log(`Lambda expression with ${captures.length} captures, ${parameters.length} parameters`)}
return{type:'lambda_function',captures:captures,parameters:parameters,body:body,call:async(args)=>{this.pushScope();try{for(let i=0;i<parameters.length&&i<args.length;i++){const param=parameters[i];const paramName=param.declarator?.value||param.name;if(paramName){this.setVariable(paramName,args[i])}}
return await this.executeStatement(body)}finally{this.popScope()}}}}
getStructSize(structName){return 8}
getEnumValues(enumName){return{}}
getUnionSize(unionName){return 8}
handleMultipleStructMembers(node){return{type:'multiple_struct_members',members:node.members||[],memberType:node.memberType||'unknown'}}
handleStructMember(node){return{type:'struct_member',memberName:node.name||node.value,memberType:node.type||'unknown',size:this.getTypeSize(node.type)||4}}
handleTemplateTypeParameter(node){return{type:'template_type_param',paramName:node.name||node.value,constraint:node.constraint||null}}
getTypeSize(typeName){const typeSizes={'int':4,'char':1,'float':4,'double':8,'bool':1,'short':2,'long':8};return typeSizes[typeName]||4}
initializeDefaultMacros(){this.macros.set('HIGH','1');this.macros.set('LOW','0');this.macros.set('INPUT','0');this.macros.set('OUTPUT','1');this.macros.set('INPUT_PULLUP','2');this.macros.set('LED_BUILTIN','13');this.macros.set('SERIAL','Serial');this.macros.set('PTIME','30');this.macros.set('BAUDRATE','19200');this.macros.set('HWVER','2');this.macros.set('SWMAJ','1');this.macros.set('SWMIN','18');this.macros.set('LED_PMODE','7');this.macros.set('LED_ERR','8');this.macros.set('LED_HB','9');this.macros.set('RESET','10');this.macros.set('MOSI','11');this.macros.set('MISO','12');this.macros.set('SCK','13');this.macros.set('PI','3.14159');this.functionMacros.set('CIRCLE_AREA',{params:['r'],body:'(PI * r * r)'});if(this.options.verbose){console.log('Initialized default Arduino macros including PI and CIRCLE_AREA')}}
processPreprocessorResults(){if(!this.ast||!this.ast.preprocessorInfo){return}
const preprocessorInfo=this.ast.preprocessorInfo;if(preprocessorInfo.activeLibraries){for(const libraryName of preprocessorInfo.activeLibraries){this.activeLibraries.add(libraryName);if(this.options.verbose){console.log(`ðŸ“¦ Enabled library: ${libraryName}`)}}}
if(preprocessorInfo.macros){for(const[macroName,macroValue]of Object.entries(preprocessorInfo.macros)){if(!this.macros.has(macroName)){this.macros.set(macroName,macroValue)}else{this.macros.set(macroName,macroValue)}}}
if(preprocessorInfo.functionMacros){for(const[macroName,macroInfo]of Object.entries(preprocessorInfo.functionMacros)){this.functionMacros.set(macroName,macroInfo)}}
if(preprocessorInfo.libraryConstants){for(const[constantName,constantValue]of Object.entries(preprocessorInfo.libraryConstants)){let value=constantValue;if(typeof constantValue==='string'&&constantValue.startsWith('0x')){value=parseInt(constantValue,16)}else if(typeof constantValue==='string'&&!isNaN(constantValue)){value=Number(constantValue)}
const result=this.variables.set(constantName,value,{isDeclaration:!0,declaredType:'const int',scopeType:'global'});if(result.success){this.variables.markAsInitialized(constantName);if(this.options.verbose){console.log(`ðŸ”§ Added library constant: ${constantName} = ${value}`)}}else if(this.options.verbose){console.warn(`âš ï¸  Failed to add library constant: ${constantName}`)}}}
if(this.options.verbose&&(preprocessorInfo.activeLibraries?.length>0||Object.keys(preprocessorInfo.macros||{}).length>0)){console.log(`âœ… Processed preprocessor results: ${preprocessorInfo.activeLibraries?.length || 0} libraries, ${Object.keys(preprocessorInfo.macros || {}).length} macros, ${Object.keys(preprocessorInfo.libraryConstants || {}).length} constants`)}}
processDefine(name,value){const functionMatch=name.match(/^(\w+)\s*\(([^)]*)\)$/);if(functionMatch){const macroName=functionMatch[1];const paramsStr=functionMatch[2].trim();const params=paramsStr?paramsStr.split(',').map(p=>p.trim()):[];this.functionMacros.set(macroName,{params:params,body:value});if(this.options.verbose){console.log(`Defined function macro: ${macroName}(${params.join(', ')}) = ${value}`)}}else{this.macros.set(name,value);if(this.options.verbose){console.log(`Defined macro: ${name} = ${value}`)}}}
expandMacros(expression){let expanded=expression;for(const[name,value]of this.macros.entries()){const regex=new RegExp(`\\b${name}\\b`,'g');expanded=expanded.replace(regex,value)}
for(const[name,macro]of this.functionMacros.entries()){const regex=new RegExp(`\\b${name}\\s*\\(([^)]+)\\)`,'g');expanded=expanded.replace(regex,(match,argsStr)=>{const args=argsStr.split(',').map(arg=>arg.trim());if(args.length!==macro.params.length){console.warn(`Macro ${name} expects ${macro.params.length} arguments, got ${args.length}`);return match}
let body=macro.body;for(let i=0;i<macro.params.length;i++){const paramRegex=new RegExp(`\\b${macro.params[i]}\\b`,'g');body=body.replace(paramRegex,args[i])}
return body})}
return expanded}
isMacroDefined(name){return this.macros.has(name)||this.functionMacros.has(name)}
evaluateSimpleMacroExpression(expression){let expr=expression.trim();if(expr.startsWith('(')&&expr.endsWith(')')){expr=expr.slice(1,-1)}
expr=this.expandMacros(expr);try{if(!/^[0-9+\-*/().\ ]+$/.test(expr)){throw new Error(`Unsafe expression: ${expr}`)}
const result=eval(expr);if(this.options.verbose){console.log(`Simple macro evaluation: ${expr} = ${result}`)}
return result}catch(error){throw new Error(`Cannot evaluate expression: ${expr} (${error.message})`)}}}
if(typeof window!=='undefined'){window.ArduinoInterpreter=ArduinoInterpreter;window.COMMAND_TYPES=COMMAND_TYPES;window.EXECUTION_STATE=EXECUTION_STATE;window.INTERPRETER_VERSION=INTERPRETER_VERSION}else if(typeof module!=='undefined'&&module.exports){module.exports={ArduinoInterpreter,COMMAND_TYPES,EXECUTION_STATE,INTERPRETER_VERSION}}