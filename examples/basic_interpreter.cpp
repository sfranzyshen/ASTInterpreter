/**
 * basic_interpreter.cpp - Basic Arduino AST Interpreter Example
 * 
 * Demonstrates how to use the C++ Arduino AST Interpreter with
 * embedded AST data generated from JavaScript exportCompactAST().
 * 
 * This example shows:
 * - Loading AST from embedded binary data
 * - Setting up command listeners
 * - Running the interpreter
 * - Cross-platform validation
 */

#include "ASTInterpreter.hpp"
#include "CompactAST.hpp"
#include <iostream>
#include <iomanip>
#include <vector>
#include <fstream>

using namespace arduino_interpreter;

// =============================================================================
// EXAMPLE COMMAND LISTENER
// =============================================================================

class ExampleCommandListener : public CommandListener {
public:
    void onCommand(const Command& command) override {
        std::cout << "[COMMAND] " << serializeCommand(command) << std::endl;
        
        // Track command statistics
        commandCount_++;
        commandTypes_[static_cast<int>(command.type)]++;
    }
    
    void onError(const std::string& error) override {
        std::cout << "[ERROR] " << error << std::endl;
        errorCount_++;
    }
    
    void printStatistics() const {
        std::cout << "\n=== Execution Statistics ===" << std::endl;
        std::cout << "Total Commands: " << commandCount_ << std::endl;
        std::cout << "Errors: " << errorCount_ << std::endl;
        
        if (!commandTypes_.empty()) {
            std::cout << "Command Types:" << std::endl;
            for (const auto& [type, count] : commandTypes_) {
                if (count > 0) {
                    std::cout << "  " << commandTypeToString(static_cast<CommandType>(type)) 
                             << ": " << count << std::endl;
                }
            }
        }
        std::cout << "============================" << std::endl;
    }

private:
    uint32_t commandCount_ = 0;
    uint32_t errorCount_ = 0;
    std::map<int, uint32_t> commandTypes_;
};

// =============================================================================
// EXAMPLE RESPONSE HANDLER
// =============================================================================

class ExampleResponseHandler : public ResponseHandler {
public:
    void handleResponse(const RequestId& requestId, const CommandValue& value) override {
        std::cout << "[RESPONSE] " << requestId.toString() << " = " 
                 << commandValueToString(value) << std::endl;
        
        responses_[requestId.toString()] = value;
    }
    
    bool waitForResponse(const RequestId& requestId, CommandValue& result, uint32_t timeoutMs) override {
        // Mock implementation - in real use, this would wait for external response
        std::string id = requestId.toString();
        
        // Generate mock responses based on request type
        if (requestId.operation == "analogRead") {
            result = static_cast<int32_t>(512); // Mock analog reading
        } else if (requestId.operation == "digitalRead") {
            result = static_cast<int32_t>(1);   // Mock digital reading (HIGH)
        } else if (requestId.operation == "millis") {
            result = static_cast<int32_t>(1000); // Mock millis value
        } else if (requestId.operation == "micros") {
            result = static_cast<int32_t>(1000000); // Mock micros value
        } else {
            result = std::monostate{};
            return false;
        }
        
        handleResponse(requestId, result);
        return true;
    }

private:
    std::map<std::string, CommandValue> responses_;
};

// =============================================================================
// EMBEDDED TEST AST DATA
// =============================================================================

// This would be generated by JavaScript exportCompactAST() function
// For demonstration, we'll use a minimal valid header
const uint8_t EMBEDDED_AST[] = {
    // Header (16 bytes)
    0x50, 0x54, 0x53, 0x41,  // Magic: 'ASTP' (little-endian)
    0x00, 0x01,              // Version: 0x0100
    0x00, 0x00,              // Flags: 0x0000
    0x01, 0x00, 0x00, 0x00,  // Node count: 1
    0x10, 0x00, 0x00, 0x00,  // String table size: 16
    
    // String table (16 bytes)
    0x01, 0x00, 0x00, 0x00,  // String count: 1
    0x04, 0x00,              // String length: 4
    'v', 'o', 'i', 'd',      // String: "void"
    0x00,                    // Null terminator
    0x00, 0x00, 0x00,        // Padding to 4-byte boundary
    
    // Node data
    0x01,                    // Node type: PROGRAM
    0x00,                    // Flags: none
    0x00, 0x00               // Data size: 0
};

const size_t EMBEDDED_AST_SIZE = sizeof(EMBEDDED_AST);

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

void printHeader() {
    std::cout << "===============================================" << std::endl;
    std::cout << "Arduino AST Interpreter - C++ Implementation" << std::endl;
    std::cout << "Host Development Example" << std::endl;
    std::cout << "===============================================" << std::endl;
}

void printASTInfo(const uint8_t* data, size_t size) {
    if (!arduino_ast::isValidCompactAST(data, size)) {
        std::cout << "ERROR: Invalid AST format!" << std::endl;
        return;
    }
    
    uint16_t version = arduino_ast::getCompactASTVersion(data, size);
    uint32_t nodeCount = arduino_ast::getCompactASTNodeCount(data, size);
    size_t estimatedMemory = arduino_ast::estimateParsingMemory(data, size);
    
    std::cout << "\nAST Information:" << std::endl;
    std::cout << "  Format version: 0x" << std::hex << version << std::dec << std::endl;
    std::cout << "  Node count: " << nodeCount << std::endl;
    std::cout << "  Buffer size: " << size << " bytes" << std::endl;
    std::cout << "  Estimated memory: " << estimatedMemory << " bytes" << std::endl;
}

void demonstrateCompactASTReading() {
    std::cout << "\n--- Compact AST Reading Demo ---" << std::endl;
    
    try {
        arduino_ast::CompactASTReader reader(EMBEDDED_AST, EMBEDDED_AST_SIZE);
        
        // Parse header only
        auto header = reader.parseHeader();
        std::cout << "Header parsed successfully:" << std::endl;
        std::cout << "  Magic: 0x" << std::hex << header.magic << std::dec << std::endl;
        std::cout << "  Version: 0x" << std::hex << header.version << std::dec << std::endl;
        std::cout << "  Node count: " << header.nodeCount << std::endl;
        
        // Full parse
        auto ast = reader.parse();
        if (ast) {
            std::cout << "AST parsed successfully!" << std::endl;
            std::cout << "Root node type: " << arduino_ast::nodeTypeToString(ast->getType()) << std::endl;
        }
        
    } catch (const std::exception& e) {
        std::cout << "ERROR: " << e.what() << std::endl;
    }
}

void demonstrateInterpreter() {
    std::cout << "\n--- Interpreter Execution Demo ---" << std::endl;
    
    try {
        // Configure interpreter
        InterpreterOptions options;
        options.verbose = true;
        options.debug = true;
        options.maxLoopIterations = 3;
        options.stepDelay = 0;
        
        // Create interpreter
        auto interpreter = std::make_unique<ASTInterpreter>(EMBEDDED_AST, EMBEDDED_AST_SIZE, options);
        
        // Set up listeners
        auto commandListener = std::make_unique<ExampleCommandListener>();
        auto responseHandler = std::make_unique<ExampleResponseHandler>();
        
        interpreter->setCommandListener(commandListener.get());
        interpreter->setResponseHandler(responseHandler.get());
        
        std::cout << "Starting interpreter execution..." << std::endl;
        
        // Start execution
        bool success = interpreter->start();
        
        if (success) {
            std::cout << "Interpreter execution completed successfully!" << std::endl;
        } else {
            std::cout << "Interpreter execution failed!" << std::endl;
        }
        
        // Print statistics
        commandListener->printStatistics();
        
        // Memory statistics
        auto memStats = interpreter->getMemoryStats();
        std::cout << "\nMemory Statistics:" << std::endl;
        std::cout << "  Total memory: " << memStats.totalMemory << " bytes" << std::endl;
        std::cout << "  Variable memory: " << memStats.variableMemory << " bytes" << std::endl;
        std::cout << "  AST memory: " << memStats.astMemory << " bytes" << std::endl;
        std::cout << "  Variables: " << memStats.variableCount << std::endl;
        
    } catch (const std::exception& e) {
        std::cout << "ERROR: " << e.what() << std::endl;
    }
}

void loadAndTestExternalAST() {
    std::cout << "\n--- External AST Loading Demo ---" << std::endl;
    
    // Try to load AST file generated by JavaScript test
    std::ifstream file("test_output.ast", std::ios::binary);
    if (!file) {
        std::cout << "No external AST file found (test_output.ast)" << std::endl;
        std::cout << "Run 'node test_compact_ast.js' first to generate test data." << std::endl;
        return;
    }
    
    // Read file
    std::vector<uint8_t> buffer((std::istreambuf_iterator<char>(file)),
                               std::istreambuf_iterator<char>());
    file.close();
    
    if (buffer.empty()) {
        std::cout << "Empty AST file!" << std::endl;
        return;
    }
    
    std::cout << "Loaded external AST: " << buffer.size() << " bytes" << std::endl;
    
    // Validate and parse
    try {
        InterpreterOptions options;
        options.debug = false;
        options.maxLoopIterations = 10;
        
        auto interpreter = std::make_unique<ASTInterpreter>(buffer.data(), buffer.size(), options);
        auto commandListener = std::make_unique<ExampleCommandListener>();
        interpreter->setCommandListener(commandListener.get());
        
        bool success = interpreter->start();
        std::cout << "External AST execution: " << (success ? "SUCCESS" : "FAILED") << std::endl;
        
        commandListener->printStatistics();
        
    } catch (const std::exception& e) {
        std::cout << "ERROR with external AST: " << e.what() << std::endl;
    }
}

// =============================================================================
// MAIN FUNCTION
// =============================================================================

int main(int argc, char* argv[]) {
    printHeader();
    
    // Check for command line AST file
    if (argc > 1) {
        std::cout << "\nLoading AST file: " << argv[1] << std::endl;
        
        // Load the specified AST file
        std::ifstream file(argv[1], std::ios::binary);
        if (!file) {
            std::cout << "ERROR: Cannot open AST file: " << argv[1] << std::endl;
            return 1;
        }
        
        // Read file
        std::vector<uint8_t> buffer((std::istreambuf_iterator<char>(file)),
                                   std::istreambuf_iterator<char>());
        file.close();
        
        if (buffer.empty()) {
            std::cout << "ERROR: Empty AST file!" << std::endl;
            return 1;
        }
        
        std::cout << "Loaded AST file: " << buffer.size() << " bytes" << std::endl;
        
        // Use the loaded AST file for all demonstrations
        printASTInfo(buffer.data(), buffer.size());
        
        // Test with the loaded AST
        try {
            InterpreterOptions options;
            options.verbose = true;
            options.debug = true;
            options.maxLoopIterations = 3;
            options.stepDelay = 0;
            
            auto interpreter = std::make_unique<ASTInterpreter>(buffer.data(), buffer.size(), options);
            auto commandListener = std::make_unique<ExampleCommandListener>();
            auto responseHandler = std::make_unique<ExampleResponseHandler>();
            
            interpreter->setCommandListener(commandListener.get());
            interpreter->setResponseHandler(responseHandler.get());
            
            std::cout << "Starting interpreter execution..." << std::endl;
            bool success = interpreter->start();
            
            std::cout << "Interpreter execution: " << (success ? "SUCCESS" : "FAILED") << std::endl;
            commandListener->printStatistics();
            
        } catch (const std::exception& e) {
            std::cout << "ERROR: " << e.what() << std::endl;
        }
        
    } else {
        // Default behavior - use embedded AST for demo
        std::cout << "\nUsing embedded demo AST (no file specified)" << std::endl;
        
        // Print AST information
        printASTInfo(EMBEDDED_AST, EMBEDDED_AST_SIZE);
        
        // Demonstrate compact AST reading
        demonstrateCompactASTReading();
        
        // Demonstrate interpreter execution
        demonstrateInterpreter();
        
        // Try to load and test external AST
        loadAndTestExternalAST();
    }
    
    std::cout << "\n--- Demo Complete ---" << std::endl;
    
    return 0;
}