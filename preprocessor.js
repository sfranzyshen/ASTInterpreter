#!/usr/bin/env node
const PREPROCESSOR_VERSION='1.2.0';const LIBRARY_INCLUDES={'Adafruit_NeoPixel.h':{library:'Adafruit_NeoPixel',constants:{'NEO_GRB':'0x52','NEO_RGB':'0x20','NEO_RGBW':'0x28','NEO_KHZ800':'0x0000','NEO_KHZ400':'0x0100'},activate:!0},'Servo.h':{library:'Servo',constants:{},activate:!0},'SPI.h':{library:'SPI',constants:{'MSBFIRST':'1','LSBFIRST':'0','SPI_MODE0':'0','SPI_MODE1':'1','SPI_MODE2':'2','SPI_MODE3':'3'},activate:!0},'Wire.h':{library:'Wire',constants:{},activate:!0},'EEPROM.h':{library:'EEPROM',constants:{},activate:!0},'avr/power.h':{constants:{'clock_div_1':'0x00','clock_div_2':'0x01','clock_div_4':'0x02','clock_div_8':'0x03','clock_div_16':'0x04','clock_div_32':'0x05','clock_div_64':'0x06','clock_div_128':'0x07','clock_div_256':'0x08'}},'Arduino.h':{constants:{'HIGH':'1','LOW':'0','INPUT':'0','OUTPUT':'1','INPUT_PULLUP':'2','LED_BUILTIN':'13'}}};class ArduinoPreprocessor{constructor(options={}){this.options={verbose:options.verbose||!1,debug:options.debug||!1,platformDefines:options.platformDefines||['ARDUINO','__AVR__'],platformContext:options.platformContext||null,...options};this.macros=new Map();this.functionMacros=new Map();this.activeLibraries=new Set();this.libraryConstants=new Map();this.conditionalStack=[];this.initializeDefaultMacros();if(this.options.verbose){console.log(`ArduinoPreprocessor v${PREPROCESSOR_VERSION} initialized`)}}
initializeDefaultMacros(){this.macros.set('HIGH','1');this.macros.set('LOW','0');this.macros.set('INPUT','0');this.macros.set('OUTPUT','1');this.macros.set('INPUT_PULLUP','2');this.macros.set('LED_BUILTIN','13');this.macros.set('PI','3.14159');if(this.options.platformContext){const platformDefines=this.options.platformContext.getDefines();Object.entries(platformDefines).forEach(([key,value])=>{this.macros.set(key,String(value))});if(this.options.verbose){console.log(`ðŸŽ¯ Loaded ${Object.keys(platformDefines).length} platform defines from ${this.options.platformContext.currentPlatform.displayName}`)}}else{this.macros.set('ARDUINO_ARCH_AVR','1');this.macros.set('F_CPU','16000000UL');this.macros.set('ARDUINO_API_VERSION','10001');this.macros.set('MOSI','11');this.macros.set('MISO','12');this.macros.set('SCK','13');this.options.platformDefines.forEach(define=>{this.macros.set(define,'1')})}
if(this.options.verbose){console.log(`Initialized ${this.macros.size} default Arduino macros`)}}
preprocess(sourceCode){if(this.options.debug){console.log('Starting preprocessing...')}
let processedCode=sourceCode;try{processedCode=this.processIncludes(processedCode);processedCode=this.processDefines(processedCode);processedCode=this.processConditionals(processedCode);processedCode=this.performMacroSubstitution(processedCode);if(this.options.debug){console.log(`Preprocessing complete. Active libraries: ${Array.from(this.activeLibraries).join(', ')}`);console.log(`Defined macros: ${this.macros.size} simple, ${this.functionMacros.size} function-like`)}
return{processedCode,activeLibraries:Array.from(this.activeLibraries),libraryConstants:Object.fromEntries(this.libraryConstants),macros:Object.fromEntries(this.macros),functionMacros:Object.fromEntries(this.functionMacros)}}catch(error){console.error('Preprocessing error:',error.message);return{processedCode:sourceCode,activeLibraries:[],libraryConstants:{},macros:Object.fromEntries(this.macros),functionMacros:{},error:error.message}}}
processIncludes(code){const includeRegex=/#include\s*[<"]([^>"]+)[>"]/g;let processedCode=code;let match;includeRegex.lastIndex=0;while((match=includeRegex.exec(code))!==null){const includeFile=match[1];const fullInclude=match[0];if(LIBRARY_INCLUDES[includeFile]){const config=LIBRARY_INCLUDES[includeFile];if(config.activate&&config.library){this.activeLibraries.add(config.library);if(this.options.verbose){console.log(`Activated library: ${config.library}`)}}
Object.entries(config.constants||{}).forEach(([name,value])=>{this.macros.set(name,value);this.libraryConstants.set(name,value)});if(this.options.verbose&&Object.keys(config.constants||{}).length>0){console.log(`Added ${Object.keys(config.constants).length} constants from ${includeFile}`)}}else if(this.options.verbose){console.log(`Unknown include file: ${includeFile} (ignoring)`)}
processedCode=processedCode.replace(fullInclude,'')}
return processedCode}
processDefines(code){const lines=code.split('\n');const processedLines=[];for(let i=0;i<lines.length;i++){const line=lines[i];const trimmed=line.trim();if(trimmed.startsWith('#define')){this.processDefineDirective(trimmed)}else if(trimmed.startsWith('#undef')){this.processUndefDirective(trimmed)}else{processedLines.push(line)}}
return processedLines.join('\n')}
processDefineDirective(defineLine){const content=defineLine.substring(7).trim();const functionMacroMatch=content.match(/^([A-Z_][A-Z0-9_]*)\s*\(([^)]*)\)\s+(.+)$/i);if(functionMacroMatch){const name=functionMacroMatch[1];const paramsStr=functionMacroMatch[2].trim();const body=functionMacroMatch[3].trim();const params=paramsStr?paramsStr.split(',').map(p=>p.trim()):[];this.functionMacros.set(name,{params:params,body:body});if(this.options.verbose){console.log(`Defined function macro: ${name}(${params.join(', ')}) -> ${body}`)}}else{const parts=content.match(/^([A-Z_][A-Z0-9_]*)\s+(.+)$/i);if(parts){const name=parts[1];const value=parts[2].trim();this.macros.set(name,value);if(this.options.verbose){console.log(`Defined macro: ${name} -> ${value}`)}}else{const nameMatch=content.match(/^([A-Z_][A-Z0-9_]*)$/i);if(nameMatch){const name=nameMatch[1];this.macros.set(name,'1');if(this.options.verbose){console.log(`Defined flag macro: ${name} -> 1`)}}}}}
processUndefDirective(undefLine){const macroName=undefLine.substring(6).trim();if(this.macros.has(macroName)){this.macros.delete(macroName);if(this.options.verbose){console.log(`Undefined macro: ${macroName}`)}}else if(this.options.verbose){console.log(`Macro not defined, ignoring #undef: ${macroName}`)}
if(this.functionMacros.has(macroName)){this.functionMacros.delete(macroName)}}
processConditionals(code){const lines=code.split('\n');const processedLines=[];let skipLines=!1;let conditionalDepth=0;for(let i=0;i<lines.length;i++){const line=lines[i];const trimmed=line.trim();if(trimmed.startsWith('#ifdef')){const macro=trimmed.substring(6).trim();conditionalDepth++;if(this.macros.has(macro)){skipLines=!1;if(this.options.verbose){console.log(`#ifdef ${macro}: TRUE (including section)`)}}else{skipLines=!0;if(this.options.verbose){console.log(`#ifdef ${macro}: FALSE (skipping section)`)}}}else if(trimmed.startsWith('#ifndef')){const macro=trimmed.substring(7).trim();conditionalDepth++;if(!this.macros.has(macro)){skipLines=!1;if(this.options.verbose){console.log(`#ifndef ${macro}: TRUE (including section)`)}}else{skipLines=!0;if(this.options.verbose){console.log(`#ifndef ${macro}: FALSE (skipping section)`)}}}else if(trimmed.startsWith('#endif')){conditionalDepth--;if(conditionalDepth===0){skipLines=!1}}else if(trimmed.startsWith('#else')){skipLines=!skipLines}else if(trimmed.startsWith('#if ')){const expression=trimmed.substring(3).trim();conditionalDepth++;try{let evalExpression=expression;evalExpression=evalExpression.replace(/defined\s*\(\s*([A-Za-z_][A-Za-z0-9_]*)\s*\)/g,(match,macroName)=>{const isDefined=this.macros.has(macroName)?'1':'0';if(this.options.verbose){console.log(`   defined(${macroName}) â†’ ${isDefined}`)}
return isDefined});for(const[macro,value]of this.macros){const regex=new RegExp(`\\b${macro}\\b`,'g');evalExpression=evalExpression.replace(regex,value)}
evalExpression=evalExpression.replace(/\b[A-Za-z_][A-Za-z0-9_]*\b/g,(match)=>{if(/^[0-9]/.test(match)||['&&','||','==','!=','>','<','>=','<='].includes(match)){return match}
return'0'});if(this.options.verbose){console.log(`   Expression: ${expression} â†’ ${evalExpression}`)}
const result=eval(evalExpression);if(result){skipLines=!1;if(this.options.verbose){console.log(`#if ${expression}: TRUE (including section)`)}}else{skipLines=!0;if(this.options.verbose){console.log(`#if ${expression}: FALSE (skipping section)`)}}}catch(error){skipLines=!1;if(this.options.verbose){console.log(`#if ${expression}: EVAL_ERROR (including section)`)}}}else{if(!skipLines){processedLines.push(line)}}}
return processedLines.join('\n')}
performMacroSubstitution(code){let substitutedCode=code;for(const[macroName,macroValue]of this.macros){const regex=new RegExp(`\\b${macroName}\\b`,'g');substitutedCode=substitutedCode.replace(regex,macroValue)}
for(const[macroName,macroInfo]of this.functionMacros){const{params,body}=macroInfo;const regex=new RegExp(`\\b${macroName}\\s*\\(([^)]*)\\)`,'g');substitutedCode=substitutedCode.replace(regex,(match,argsStr)=>{const args=argsStr?argsStr.split(',').map(arg=>arg.trim()):[];let expandedBody=body;for(let i=0;i<params.length&&i<args.length;i++){const paramRegex=new RegExp(`\\b${params[i]}\\b`,'g');expandedBody=expandedBody.replace(paramRegex,args[i])}
if(this.options.verbose){console.log(`Expanded macro: ${match} -> ${expandedBody}`)}
return expandedBody})}
return substitutedCode}
getStats(){return{version:PREPROCESSOR_VERSION,macros:this.macros.size,functionMacros:this.functionMacros.size,activeLibraries:this.activeLibraries.size,libraryConstants:this.libraryConstants.size}}}
if(typeof window!=='undefined'){window.ArduinoPreprocessor=ArduinoPreprocessor;window.LIBRARY_INCLUDES=LIBRARY_INCLUDES;window.PREPROCESSOR_VERSION=PREPROCESSOR_VERSION}else if(typeof module!=='undefined'&&module.exports){module.exports={ArduinoPreprocessor,LIBRARY_INCLUDES,PREPROCESSOR_VERSION}}