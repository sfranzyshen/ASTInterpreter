const PARSER_VERSION="5.0.0";function getArduinoPreprocessor(){try{if(typeof require!=='undefined'){const preprocessorModule=require('./preprocessor.js');return preprocessorModule.ArduinoPreprocessor}else if(typeof window!=='undefined'&&window.ArduinoPreprocessor){return window.ArduinoPreprocessor}}catch(error){if(typeof console!=='undefined'){console.warn('Arduino Preprocessor not available:',error.message)}}
return null}
const KEYWORDS={'void':'VOID','int':'INT','long':'LONG','float':'FLOAT','double':'DOUBLE','char':'CHAR','short':'SHORT','bool':'BOOL','boolean':'BOOLEAN','byte':'BYTE','size_t':'SIZE_T','word':'WORD','unsigned':'UNSIGNED','signed':'SIGNED','String':'STRING','Servo':'SERVO','LiquidCrystal':'LIQUID_CRYSTAL','uint8_t':'UINT8_T','int8_t':'INT8_T','uint16_t':'UINT16_T','int16_t':'INT16_T','uint32_t':'UINT32_T','int32_t':'INT32_T','uint64_t':'UINT64_T','int64_t':'INT64_T','const':'CONST','static':'STATIC','volatile':'VOLATILE','extern':'EXTERN','PROGMEM':'PROGMEM','struct':'STRUCT','typedef':'TYPEDEF','enum':'ENUM','union':'UNION','class':'CLASS','template':'TEMPLATE','typename':'TYPENAME','auto':'AUTO','public':'PUBLIC','private':'PRIVATE','protected':'PROTECTED','virtual':'VIRTUAL','override':'OVERRIDE','final':'FINAL','constexpr':'CONSTEXPR','decltype':'DECLTYPE','explicit':'EXPLICIT','mutable':'MUTABLE','inline':'INLINE','noexcept':'NOEXCEPT','nullptr':'NULLPTR','friend':'FRIEND','operator':'OPERATOR','new':'NEW','delete':'DELETE','static_cast':'STATIC_CAST','dynamic_cast':'DYNAMIC_CAST','const_cast':'CONST_CAST','reinterpret_cast':'REINTERPRET_CAST','namespace':'NAMESPACE','using':'USING','if':'IF','else':'ELSE','for':'FOR','while':'WHILE','do':'DO','return':'RETURN','break':'BREAK','continue':'CONTINUE','switch':'SWITCH','case':'CASE','default':'DEFAULT','goto':'GOTO','true':'TRUE','false':'FALSE','NULL':'NULL','HIGH':'HIGH','LOW':'LOW','INPUT':'INPUT','OUTPUT':'OUTPUT','INPUT_PULLUP':'INPUT_PULLUP','INPUT_PULLDOWN':'INPUT_PULLDOWN','OUTPUT_OPENDRAIN':'OUTPUT_OPENDRAIN','LED_BUILTIN':'LED_BUILTIN','HEX':'HEX','DEC':'DEC','OCT':'OCT','BIN':'BIN','sizeof':'SIZEOF','digitalRead':'ARDUINO_FUNC','digitalWrite':'ARDUINO_FUNC','pinMode':'ARDUINO_FUNC','analogRead':'ARDUINO_FUNC','analogWrite':'ARDUINO_FUNC','analogReference':'ARDUINO_FUNC','analogReadResolution':'ARDUINO_FUNC','analogWriteResolution':'ARDUINO_FUNC','tone':'ARDUINO_FUNC','noTone':'ARDUINO_FUNC','pulseIn':'ARDUINO_FUNC','pulseInLong':'ARDUINO_FUNC','shiftIn':'ARDUINO_FUNC','shiftOut':'ARDUINO_FUNC','delay':'ARDUINO_FUNC','delayMicroseconds':'ARDUINO_FUNC','millis':'ARDUINO_FUNC','micros':'ARDUINO_FUNC','map':'ARDUINO_FUNC','constrain':'ARDUINO_FUNC','min':'ARDUINO_FUNC','max':'ARDUINO_FUNC','abs':'ARDUINO_FUNC','sq':'ARDUINO_FUNC','sqrt':'ARDUINO_FUNC','pow':'ARDUINO_FUNC','sin':'ARDUINO_FUNC','cos':'ARDUINO_FUNC','tan':'ARDUINO_FUNC','random':'ARDUINO_FUNC','randomSeed':'ARDUINO_FUNC','attachInterrupt':'ARDUINO_FUNC','detachInterrupt':'ARDUINO_FUNC','interrupts':'ARDUINO_FUNC','noInterrupts':'ARDUINO_FUNC'};const TYPE_CATEGORIES={FUNDAMENTAL:['INT','CHAR','FLOAT','DOUBLE','VOID','BOOL','BOOLEAN'],STDLIB:['SIZE_T','PTRDIFF_T','WCHAR_T'],FIXED_WIDTH:['UINT8_T','INT8_T','UINT16_T','INT16_T','UINT32_T','INT32_T','UINT64_T','INT64_T'],ARDUINO:['STRING','BYTE','WORD','SERVO','LIQUID_CRYSTAL'],MODIFIERS:['CONST','VOLATILE','STATIC','EXTERN','UNSIGNED','SIGNED'],EXTENDED:['LONG','SHORT','AUTO'],CXX_SPECIFIERS:['VIRTUAL','OVERRIDE','FINAL','CONSTEXPR','EXPLICIT','MUTABLE','INLINE']};const ALL_TYPES=Object.values(TYPE_CATEGORIES).flat();function isValidType(tokenType,context='any'){if(tokenType==='IDENTIFIER')return!0;const isKnownType=ALL_TYPES.includes(tokenType);switch(context){case 'declaration':return isKnownType&&!TYPE_CATEGORIES.CXX_SPECIFIERS.includes(tokenType);case 'cast':return TYPE_CATEGORIES.FUNDAMENTAL.includes(tokenType)||TYPE_CATEGORIES.STDLIB.includes(tokenType)||TYPE_CATEGORIES.FIXED_WIDTH.includes(tokenType)||TYPE_CATEGORIES.ARDUINO.includes(tokenType)||TYPE_CATEGORIES.EXTENDED.includes(tokenType)||['UNSIGNED','SIGNED','CONST','VOLATILE'].includes(tokenType)||tokenType==='IDENTIFIER';case 'parameter':return isKnownType;case 'any':default:return isKnownType}}
function isTypeModifier(tokenType){return TYPE_CATEGORIES.MODIFIERS.includes(tokenType)}
function isStorageClass(tokenType){return['STATIC','EXTERN','VOLATILE'].includes(tokenType)}
const PRECEDENCE={'COMMA':0,'OR':1,'AND':2,'BITWISE_OR':3,'BITWISE_XOR':4,'BITWISE_AND':5,'AMPERSAND':5,'EQ':6,'NEQ':6,'LT':7,'GT':7,'LTE':7,'GTE':7,'LSHIFT':8,'RSHIFT':8,'PLUS':9,'MINUS':9,'MUL':10,'DIV':10,'MOD':10,};class Parser{constructor(code,options={}){this.code=code;this.options=options;this.position=0;this.currentChar=this.code[this.position];this.line=1;this.column=1;this.currentToken=null;this.peekToken=null;this.peekToken2=null;this.advanceToken();this.advanceToken();this.advanceToken()}
advance(){if(this.currentChar==='\n'){this.line++;this.column=1}else{this.column++}
this.position++;this.currentChar=this.position<this.code.length?this.code[this.position]:null}
eatChar(char){if(this.currentChar===char){this.advance()}else{throw new Error(`Lexer Error on line ${this.line}, column ${this.column}: Expected character '${char}' but found '${this.currentChar || 'EOF'}'`)}}
peek(){const peekPos=this.position+1;return peekPos<this.code.length?this.code[peekPos]:null}
advanceToken(){this.currentToken=this.peekToken;this.peekToken=this.peekToken2;this.peekToken2=this.getNextToken()}
eat(tokenType){if(this.currentToken.type===tokenType){this.advanceToken()}else{if(tokenType==='SEMICOLON'&&['PRIVATE','PUBLIC','PROTECTED','RETURN'].includes(this.currentToken.type)){this.advanceToken();while(this.currentToken.type!=='EOF'&&this.currentToken.type!=='SEMICOLON'&&this.currentToken.type!=='RBRACE'){this.advanceToken()}
if(this.currentToken.type==='SEMICOLON'){this.advanceToken()}
return}
const{line,column}=this.currentToken;throw new Error(`Parsing Error on line ${line}, column ${column}: Expected token type '${tokenType}' but found '${this.currentToken.type}' (value: '${this.currentToken.value}')`)}}
skipWhitespace(){while(this.currentChar!==null&&/\s/.test(this.currentChar)){this.advance()}}
skipComments(){if(this.currentChar==='/'&&this.peek()==='/'){while(this.currentChar!==null&&this.currentChar!=='\n'){this.advance()}
return!0}
if(this.currentChar==='/'&&this.peek()==='*'){this.advance();this.advance();while(this.currentChar!==null&&!(this.currentChar==='*'&&this.peek()==='/')){this.advance()}
this.eatChar('*');this.eatChar('/');return!0}
return!1}
stringLiteral(){let result='';const startLine=this.line;const startColumn=this.column;this.eatChar('"');const webFriendlyMode=this.options.webFriendlyMode||!1;while(this.currentChar!==null&&this.currentChar!=='"'){if(this.currentChar==='\\'){this.advance();if(this.currentChar!==null){switch(this.currentChar){case 'n':result+='\n';break;case 't':result+='\t';break;case 'r':result+='\r';break;case '\\':result+='\\';break;case '"':result+='"';break;case "'":result+="'";break;case '/':result+='/';break;case 'b':result+='\b';break;case 'f':result+='\f';break;case 'v':result+='\v';break;case '\n':this.advance();continue;case '\r':this.advance();if(this.currentChar==='\n'){this.advance()}
continue;default:if(webFriendlyMode){result+=this.currentChar}else{result+=this.currentChar}
break}
this.advance()}}else if(this.currentChar==='\n'){if(webFriendlyMode){result+=this.currentChar;this.advance()}else{throw new Error(`Lexer Error on line ${this.line}, column ${this.column}: Unescaped newline in string literal`)}}else{result+=this.currentChar;this.advance()}}
if(this.currentChar!=='"'){if(webFriendlyMode){if(this.options&&this.options.verbose){console.warn(`Warning: Unterminated string literal starting at line ${startLine}, column ${startColumn}. Attempting recovery.`)}
return{type:'STRING_LITERAL',value:result,unterminated:!0}}else{throw new Error(`Lexer Error on line ${startLine}, column ${startColumn}: Expected character '"' but found 'EOF'`)}}
this.eatChar('"');return{type:'STRING_LITERAL',value:result}}
rawStringLiteral(){const startLine=this.line;const startColumn=this.column;this.advance();this.advance();let delimiter='';while(this.currentChar!==null&&this.currentChar!=='('&&delimiter.length<16){delimiter+=this.currentChar;this.advance()}
if(this.currentChar!=='('){throw new Error(`Lexer Error on line ${this.line}, column ${this.column}: Expected '(' in raw string literal`)}
this.advance();let content='';const endPattern=')'+delimiter+'"';let matchIndex=0;while(this.currentChar!==null){if(this.currentChar===endPattern[matchIndex]){matchIndex++;if(matchIndex===endPattern.length){this.advance();break}}else{if(matchIndex>0){content+=endPattern.substring(0,matchIndex);matchIndex=0}
if(this.currentChar!==endPattern[0]){content+=this.currentChar}else{matchIndex=1}}
this.advance()}
if(matchIndex<endPattern.length){const webFriendlyMode=this.options&&this.options.webFriendlyMode;if(webFriendlyMode){if(this.options&&this.options.verbose){console.warn(`Warning: Unterminated raw string literal starting at line ${startLine}, column ${startColumn}. Expected closing pattern: ${endPattern}`)}
return{type:'STRING_LITERAL',value:content,unterminated:!0,rawString:!0,delimiter:delimiter}}else{throw new Error(`Lexer Error on line ${startLine}, column ${startColumn}: Unterminated raw string literal. Expected closing pattern: ${endPattern}`)}}
return{type:'STRING_LITERAL',value:content,rawString:!0,delimiter:delimiter}}
charLiteral(){this.eatChar("'");let result='';while(this.currentChar!=="'"&&this.currentChar!==null){if(this.currentChar==='\\'){this.advance();switch(this.currentChar){case 'n':result+='\n';break;case 't':result+='\t';break;case 'r':result+='\r';break;case '\\':result+='\\';break;case "'":result+="'";break;case '"':result+='"';break;case '0':result+='\0';break;case 'b':result+='\b';break;case 'f':result+='\f';break;case 'v':result+='\v';break;default:result+=this.currentChar;break}
this.advance()}else{result+=this.currentChar;this.advance()}}
this.eatChar("'");return{type:'CHAR_LITERAL',value:result}}
number(){let result='';if(this.currentChar==='0'&&(this.peek()==='x'||this.peek()==='X')){result+=this.currentChar;this.advance();result+=this.currentChar;this.advance();while(this.currentChar!==null&&/[0-9a-fA-F]/.test(this.currentChar)){result+=this.currentChar;this.advance()}
let suffix='';while(this.currentChar!==null&&/[LlUu]/.test(this.currentChar)){suffix+=this.currentChar;this.advance()}
return{type:'HEX_NUMBER',value:parseInt(result,16),suffix:suffix}}
if(this.currentChar==='0'&&/[0-7]/.test(this.peek())){result+=this.currentChar;this.advance();while(this.currentChar!==null&&/[0-7]/.test(this.currentChar)){result+=this.currentChar;this.advance()}
let suffix='';while(this.currentChar!==null&&/[LlUu]/.test(this.currentChar)){suffix+=this.currentChar;this.advance()}
return{type:'OCTAL_NUMBER',value:parseInt(result,8),suffix:suffix}}
if(this.currentChar==='0'&&(this.peek()==='b'||this.peek()==='B')){result+=this.currentChar;this.advance();result+=this.currentChar;this.advance();while(this.currentChar!==null&&/[01]/.test(this.currentChar)){result+=this.currentChar;this.advance()}
let suffix='';while(this.currentChar!==null&&/[LlUu]/.test(this.currentChar)){suffix+=this.currentChar;this.advance()}
return{type:'BINARY_NUMBER',value:parseInt(result.substring(2),2),suffix:suffix}}
while(this.currentChar!==null&&/\d/.test(this.currentChar)){result+=this.currentChar;this.advance()}
if(this.currentChar==='.'&&this.peek()&&/\d/.test(this.peek())){result+='.';this.advance();while(this.currentChar!==null&&/\d/.test(this.currentChar)){result+=this.currentChar;this.advance()}
if(this.currentChar==='e'||this.currentChar==='E'){result+=this.currentChar;this.advance();if(this.currentChar==='+'||this.currentChar==='-'){result+=this.currentChar;this.advance()}
while(this.currentChar!==null&&/\d/.test(this.currentChar)){result+=this.currentChar;this.advance()}}
let suffix='';while(this.currentChar!==null&&/[LlUufF]/.test(this.currentChar)){suffix+=this.currentChar;this.advance()}
return{type:'FLOAT_NUMBER',value:parseFloat(result),suffix:suffix}}
let suffix='';while(this.currentChar!==null&&/[LlUufF]/.test(this.currentChar)){suffix+=this.currentChar;this.advance()}
if(suffix){if(/[fF]/.test(suffix)){return{type:'FLOAT_NUMBER',value:parseFloat(result),suffix:suffix}}else{return{type:'NUMBER',value:Number(result),suffix:suffix}}}
return{type:'NUMBER',value:Number(result)}}
floatFromDot(){let result='';if(this.currentChar==='.'){result+='.';this.advance();while(this.currentChar!==null&&/\d/.test(this.currentChar)){result+=this.currentChar;this.advance()}
let suffix='';while(this.currentChar!==null&&/[LlUufF]/.test(this.currentChar)){suffix+=this.currentChar;this.advance()}
return{type:'FLOAT_NUMBER',value:parseFloat(result),suffix:suffix}}
return{type:'DOT',value:'.'}}
identifier(){let result='';while(this.currentChar!==null&&/[a-zA-Z0-9_]/.test(this.currentChar)){result+=this.currentChar;this.advance()}
let tokenType=(KEYWORDS.hasOwnProperty(result)?KEYWORDS[result]:null)||'IDENTIFIER';if(!this.options.recognizeArduinoFunctions&&tokenType==='ARDUINO_FUNC'){tokenType='IDENTIFIER'}
return{type:tokenType,value:result}}
getNextToken(){while(this.currentChar!==null){const line=this.line;const column=this.column;if(/\s/.test(this.currentChar)){this.skipWhitespace();continue}
if(this.currentChar==='/'&&(this.peek()==='/'||this.peek()==='*')){this.skipComments();continue}
if(this.currentChar==='#'){throw new Error(`Unexpected preprocessor directive at line ${line}, column ${column}. All preprocessor directives should be handled before parsing.`)}
if(this.currentChar==='"'){return{...this.stringLiteral(),line,column}}
if(this.currentChar==="'"){return{...this.charLiteral(),line,column}}
if(this.currentChar==='='&&this.peek()==='='){this.advance();this.advance();return{type:'EQ',value:'==',line,column}}
if(this.currentChar==='!'&&this.peek()==='='){this.advance();this.advance();return{type:'NEQ',value:'!=',line,column}}
if(this.currentChar==='<'&&this.peek()==='='){this.advance();this.advance();return{type:'LTE',value:'<=',line,column}}
if(this.currentChar==='>'&&this.peek()==='='){this.advance();this.advance();return{type:'GTE',value:'>=',line,column}}
if(this.currentChar==='&'&&this.peek()==='&'){this.advance();this.advance();return{type:'AND',value:'&&',line,column}}
if(this.currentChar==='|'&&this.peek()==='|'){this.advance();this.advance();return{type:'OR',value:'||',line,column}}
if(this.currentChar==='+'&&this.peek()==='='){this.advance();this.advance();return{type:'PLUS_ASSIGN',value:'+=',line,column}}
if(this.currentChar==='-'&&this.peek()==='='){this.advance();this.advance();return{type:'MINUS_ASSIGN',value:'-=',line,column}}
if(this.currentChar==='+'&&this.peek()==='+'){this.advance();this.advance();return{type:'PLUS_PLUS',value:'++',line,column}}
if(this.currentChar==='-'&&this.peek()==='-'){this.advance();this.advance();return{type:'MINUS_MINUS',value:'--',line,column}}
if(this.currentChar==='<'&&this.peek()==='<'){const savedPos=this.position;const savedChar=this.currentChar;const savedLine=this.line;const savedColumn=this.column;this.advance();this.advance();if(this.currentChar==='='){this.advance();return{type:'LSHIFT_ASSIGN',value:'<<=',line,column}}else{this.position=savedPos;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.advance();this.advance();return{type:'LSHIFT',value:'<<',line,column}}}
if(this.currentChar==='>'&&this.peek()==='>'){const savedPos=this.position;const savedChar=this.currentChar;const savedLine=this.line;const savedColumn=this.column;this.advance();this.advance();if(this.currentChar==='='){this.advance();return{type:'RSHIFT_ASSIGN',value:'>>=',line,column}}else{this.position=savedPos;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.advance();this.advance();return{type:'RSHIFT',value:'>>',line,column}}}
if(this.currentChar==='*'&&this.peek()==='='){this.advance();this.advance();return{type:'MUL_ASSIGN',value:'*=',line,column}}
if(this.currentChar==='/'&&this.peek()==='='){this.advance();this.advance();return{type:'DIV_ASSIGN',value:'/=',line,column}}
if(this.currentChar==='%'&&this.peek()==='='){this.advance();this.advance();return{type:'MOD_ASSIGN',value:'%=',line,column}}
if(this.currentChar==='&'&&this.peek()==='='){this.advance();this.advance();return{type:'AND_ASSIGN',value:'&=',line,column}}
if(this.currentChar==='|'&&this.peek()==='='){this.advance();this.advance();return{type:'OR_ASSIGN',value:'|=',line,column}}
if(this.currentChar==='^'&&this.peek()==='='){this.advance();this.advance();return{type:'XOR_ASSIGN',value:'^=',line,column}}
if(this.currentChar==='-'&&this.peek()==='>'){this.advance();this.advance();return{type:'ARROW',value:'->',line,column}}
if(/\d/.test(this.currentChar)||(this.currentChar==='0'&&(this.peek()==='x'||this.peek()==='X'))){return{...this.number(),line,column}}
if(this.currentChar==='.'&&/\d/.test(this.peek())){return{...this.floatFromDot(),line,column}}
if(this.currentChar==='R'&&this.peek()==='"'){return{...this.rawStringLiteral(),line,column}}
if(this.currentChar==='L'&&this.peek()==="'"){this.advance();const charLiteral=this.charLiteral();return{...charLiteral,type:'WIDE_CHAR_LITERAL',line,column}}
if(/[a-zA-Z_]/.test(this.currentChar)){return{...this.identifier(),line,column}}
const char=this.currentChar;if(char===':'&&this.peek()===':'){this.advance();this.advance();return{type:'SCOPE',value:'::',line,column}}
this.advance();switch(char){case ';':return{type:'SEMICOLON',value:';',line,column};case '(':return{type:'LPAREN',value:'(',line,column};case ')':return{type:'RPAREN',value:')',line,column};case '{':return{type:'LBRACE',value:'{',line,column};case '}':return{type:'RBRACE',value:'}',line,column};case '[':return{type:'LBRACKET',value:'[',line,column};case ']':return{type:'RBRACKET',value:']',line,column};case ':':return{type:'COLON',value:':',line,column};case '=':return{type:'ASSIGN',value:'=',line,column};case ',':return{type:'COMMA',value:',',line,column};case '.':if(this.currentChar==='.'&&this.peek()==='.'){this.advance();this.advance();return{type:'ELLIPSIS',value:'...',line,column}}
return{type:'DOT',value:'.',line,column};case '+':return{type:'PLUS',value:'+',line,column};case '-':return{type:'MINUS',value:'-',line,column};case '!':return{type:'NOT',value:'!',line,column};case '*':return{type:'MUL',value:'*',line,column};case '/':return{type:'DIV',value:'/',line,column};case '%':return{type:'MOD',value:'%',line,column};case '<':return{type:'LT',value:'<',line,column};case '>':return{type:'GT',value:'>',line,column};case '&':return{type:'AMPERSAND',value:'&',line,column};case '|':return{type:'BITWISE_OR',value:'|',line,column};case '^':return{type:'BITWISE_XOR',value:'^',line,column};case '~':return{type:'BITWISE_NOT',value:'~',line,column};case '?':return{type:'QUESTION',value:'?',line,column}}
throw new Error(`Lexer Error on line ${line}, column ${column}: Unrecognized character '${char}' (ASCII: ${char.charCodeAt(0)})`)}
return{type:'EOF',value:null,line:this.line,column:this.column}}
parseCompoundStatement(){this.eat('LBRACE');const statements=[];while(this.currentToken.type!=='RBRACE'&&this.currentToken.type!=='EOF'){statements.push(this.parseStatement())}
this.eat('RBRACE');return{type:'CompoundStmtNode',children:statements}}
parseStatement(){if(this.currentToken.type==='PreprocessorDirective'){throw new Error(`Unexpected preprocessor directive in parsed code: ${this.currentToken.value}. Preprocessor should have handled this before parsing.`)}
if(this.currentToken.type==='IF'){return this.parseIfStatement()}
if(this.currentToken.type==='WHILE'){return this.parseWhileStatement()}
if(this.currentToken.type==='DO'){return this.parseDoWhileStatement()}
if(this.currentToken.type==='FOR'){return this.parseForStatement()}
if(this.currentToken.type==='SWITCH'){return this.parseSwitchStatement()}
if(this.currentToken.type==='BREAK'){return this.parseBreakStatement()}
if(this.currentToken.type==='CONTINUE'){return this.parseContinueStatement()}
if(this.currentToken.type==='RETURN'){return this.parseReturnStatement()}
if(this.currentToken.type==='LBRACE'){return this.parseCompoundStatement()}
if(this.currentToken.type==='SEMICOLON'){this.eat('SEMICOLON');return{type:'EmptyStatement'}}
const currentType=this.currentToken.type;const isType=isValidType(currentType,'any')||isStorageClass(currentType);const isTypeConst=(currentType==='INT'||currentType==='LONG'||currentType==='FLOAT')&&this.peekToken.type==='CONST';const isArrayDecl=(isType&&this.peekToken.type==='IDENTIFIER'&&this.peekToken2.type==='LBRACKET')||(isTypeConst&&this.peekToken2.type==='IDENTIFIER');const isPointerDecl=isType&&this.peekToken.type==='MUL';const isFunctionPointerDecl=isType&&this.peekToken.type==='LPAREN'&&this.peekToken2&&this.peekToken2.type==='MUL';const isConstPointerDecl=(currentType==='CONST')&&isValidType(this.peekToken.type,'declaration')&&this.peekToken2&&this.peekToken2.type==='MUL';const isConstTypeDecl=(currentType==='CONST')&&isValidType(this.peekToken.type,'declaration')&&this.peekToken2&&this.peekToken2.type==='IDENTIFIER';const isVolatileTypeDecl=(currentType==='VOLATILE')&&isValidType(this.peekToken.type,'declaration')&&this.peekToken2&&this.peekToken2.type==='IDENTIFIER';const isStaticTypeDecl=(currentType==='STATIC')&&(isValidType(this.peekToken.type,'declaration')||(this.peekToken.type==='UNSIGNED'&&['LONG','INT','SHORT','CHAR'].includes(this.peekToken2?.type)));const isStaticCompositeType=(currentType==='STATIC')&&((this.peekToken.type==='IDENTIFIER'&&this.peekToken.value?.match(/^(uint|int)\d+_t$/)&&this.peekToken2?.type==='IDENTIFIER')||(['LONG','SHORT'].includes(this.peekToken.type)&&this.peekToken2?.type==='IDENTIFIER'));const isTemplateTypeDecl=isType&&this.peekToken.type==='LT';const isNamespaceTemplateTypeDecl=(currentType==='IDENTIFIER'&&this.peekToken.type==='SCOPE'&&this.peekToken2.type==='IDENTIFIER'&&this.isNamespaceQualifiedVariableDeclaration());if((isType&&this.peekToken.type==='IDENTIFIER')||(isTypeConst&&this.peekToken2.type==='IDENTIFIER')||isArrayDecl||isPointerDecl||isFunctionPointerDecl||isConstPointerDecl||isConstTypeDecl||isVolatileTypeDecl||isStaticTypeDecl||isStaticCompositeType||isTemplateTypeDecl||isNamespaceTemplateTypeDecl){return this.parseVariableDeclaration()}
if(currentType==='UNSIGNED'&&['LONG','INT'].includes(this.peekToken.type)){if(this.peekToken2.type==='IDENTIFIER'){return this.parseVariableDeclaration()}
if(this.peekToken.type==='LONG'&&this.peekToken2.type==='INT'){const savedPosition=this.position;const savedChar=this.currentChar;const savedLine=this.line;const savedColumn=this.column;const savedCurrent=this.currentToken;const savedPeek=this.peekToken;const savedPeek2=this.peekToken2;try{this.advanceToken();this.advanceToken();this.advanceToken();const isIdentifier=this.currentToken.type==='IDENTIFIER';this.position=savedPosition;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.currentToken=savedCurrent;this.peekToken=savedPeek;this.peekToken2=savedPeek2;if(isIdentifier){return this.parseVariableDeclaration()}}catch(e){this.position=savedPosition;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.currentToken=savedCurrent;this.peekToken=savedPeek;this.peekToken2=savedPeek2}}}
if(currentType==='LONG'&&['INT','DOUBLE'].includes(this.peekToken.type)){if(this.peekToken2.type==='IDENTIFIER'){return this.parseVariableDeclaration()}}
if(currentType==='STRUCT'){return this.parseStructDeclaration()}
if(['PUBLIC','PRIVATE','PROTECTED'].includes(currentType)){this.advanceToken();if(this.currentToken.type==='COLON'){this.advanceToken()}
return{type:'CommentNode',value:`Skipped ${currentType.toLowerCase()} access specifier in statement`}}
const expressionNode=this.parseExpression();this.eat('SEMICOLON');return{type:'ExpressionStatement',expression:expressionNode}}
parseReturnStatement(){this.eat('RETURN');let value=null;if(this.currentToken.type!=='SEMICOLON'){value=this.parseExpression()}
this.eat('SEMICOLON');return{type:'ReturnStatement',value}}
parseContinueStatement(){this.eat('CONTINUE');this.eat('SEMICOLON');return{type:'ContinueStatement'}}
parseIfStatement(){this.eat('IF');this.eat('LPAREN');const condition=this.parseExpression();this.eat('RPAREN');const consequent=this.parseStatement();let alternate=null;if(this.currentToken.type==='ELSE'){this.eat('ELSE');alternate=this.parseStatement()}
return{type:'IfStatement',condition,consequent,alternate}}
parseWhileStatement(){this.eat('WHILE');this.eat('LPAREN');const condition=this.parseExpression();this.eat('RPAREN');const body=this.parseStatement();return{type:'WhileStatement',condition,body}}
parseDoWhileStatement(){this.eat('DO');const body=this.parseStatement();this.eat('WHILE');this.eat('LPAREN');const condition=this.parseExpression();this.eat('RPAREN');this.eat('SEMICOLON');return{type:'DoWhileStatement',body,condition}}
parseForStatement(){this.eat('FOR');this.eat('LPAREN');let initializer=null;if(this.currentToken.type!=='SEMICOLON'){const currentType=this.currentToken.type;if(currentType==='IDENTIFIER'&&this.peekToken&&['ASSIGN','PLUS_ASSIGN','MINUS_ASSIGN','MUL_ASSIGN','DIV_ASSIGN','MOD_ASSIGN'].includes(this.peekToken.type)){initializer=this.parseExpression()}else if(currentType==='IDENTIFIER'&&this.peekToken&&this.peekToken.type==='SEMICOLON'){initializer=this.parseExpression()}else if(isValidType(currentType,'declaration')||isTypeModifier(currentType)){initializer=this.parseVariableDeclaration(!1)}else{initializer=this.parseExpression()}}
if(this.currentToken.type==='COLON'){this.eat('COLON');const range=this.parseExpression();this.eat('RPAREN');const body=this.parseStatement();return{type:'RangeBasedForStatement',declaration:initializer,range:range,body:body}}
this.eat('SEMICOLON');let condition=null;if(this.currentToken.type!=='SEMICOLON'){condition=this.parseExpression()}
this.eat('SEMICOLON');let increment=null;if(this.currentToken.type!=='RPAREN'){increment=this.parseExpression()}
this.eat('RPAREN');const body=this.parseStatement();return{type:'ForStatement',initializer,condition,increment,body}}
parseSwitchStatement(){this.eat('SWITCH');this.eat('LPAREN');const discriminant=this.parseExpression();this.eat('RPAREN');this.eat('LBRACE');const cases=[];while(this.currentToken.type!=='RBRACE'&&this.currentToken.type!=='EOF'){cases.push(this.parseCaseStatement())}
this.eat('RBRACE');return{type:'SwitchStatement',discriminant,cases}}
parseCaseStatement(){let test=null;if(this.currentToken.type==='CASE'){this.eat('CASE');test=this.parseCaseExpression()}else{this.eat('DEFAULT')}
this.eat('COLON');const consequent=[];while(this.currentToken.type!=='CASE'&&this.currentToken.type!=='DEFAULT'&&this.currentToken.type!=='RBRACE'){consequent.push(this.parseStatement())}
return{type:'CaseStatement',test,consequent}}
parseCaseExpression(){const left=this.parseExpression();if(this.currentToken.type==='ELLIPSIS'){this.eat('ELLIPSIS');const right=this.parseExpression();return{type:'RangeExpression',start:left,end:right}}
return left}
parseBreakStatement(){this.eat('BREAK');this.eat('SEMICOLON');return{type:'BreakStatement'}}
parseStructDeclaration(expectSemicolon=!0){this.eat('STRUCT');let name=null;if(this.currentToken.type==='IDENTIFIER'){name=this.currentToken.value;this.eat('IDENTIFIER')}
if(this.currentToken.type==='LBRACE'){this.eat('LBRACE');const members=[];while(this.currentToken.type!=='RBRACE'&&this.currentToken.type!=='EOF'){members.push(this.parseStructMember())}
this.eat('RBRACE');if(expectSemicolon){this.eat('SEMICOLON')}
return{type:'StructDeclaration',name,members}}
return{type:'StructType',name}}
parseEnumDeclaration(expectSemicolon=!0){this.eat('ENUM');let name=null;if(this.currentToken.type==='IDENTIFIER'){name=this.currentToken.value;this.eat('IDENTIFIER')}
if(this.currentToken.type==='LBRACE'){this.eat('LBRACE');const members=[];if(this.currentToken.type!=='RBRACE'){members.push(this.parseEnumMember());while(this.currentToken.type==='COMMA'){this.eat('COMMA');if(this.currentToken.type==='RBRACE')break;members.push(this.parseEnumMember())}}
this.eat('RBRACE');if(expectSemicolon){this.eat('SEMICOLON')}
return{type:'EnumDeclaration',name,members}}
return{type:'EnumType',name}}
parseEnumMember(){const name=this.currentToken.value;this.eat('IDENTIFIER');let value=null;if(this.currentToken.type==='ASSIGN'){this.eat('ASSIGN');value=this.parseExpression()}
return{type:'EnumMember',name,value}}
parseUnionDeclaration(expectSemicolon=!0){this.eat('UNION');let name=null;if(this.currentToken.type==='IDENTIFIER'){name=this.currentToken.value;this.eat('IDENTIFIER')}
if(this.currentToken.type==='LBRACE'){this.eat('LBRACE');const members=[];while(this.currentToken.type!=='RBRACE'&&this.currentToken.type!=='EOF'){members.push(this.parseStructMember())}
this.eat('RBRACE');const variables=[];if(this.currentToken.type==='IDENTIFIER'){variables.push(this.currentToken.value);this.eat('IDENTIFIER');while(this.currentToken.type==='COMMA'){this.eat('COMMA');variables.push(this.currentToken.value);this.eat('IDENTIFIER')}}
if(expectSemicolon){this.eat('SEMICOLON')}
return{type:'UnionDeclaration',name,members,variables}}
return{type:'UnionType',name}}
parseTypedefDeclaration(){this.eat('TYPEDEF');if(this.currentToken.type==='STRUCT'){const structDecl=this.parseStructDeclaration(!1);if(this.currentToken.type==='IDENTIFIER'){const typeName=this.currentToken.value;this.eat('IDENTIFIER');this.eat('SEMICOLON');return{type:'TypedefDeclaration',baseType:structDecl,typeName:typeName}}else{throw new Error(`Expected typedef name after struct definition at line ${this.currentToken.line}`)}}
if(this.currentToken.type==='UNION'){const unionDecl=this.parseUnionDeclaration(!1);if(this.currentToken.type==='IDENTIFIER'){const typeName=this.currentToken.value;this.eat('IDENTIFIER');this.eat('SEMICOLON');return{type:'TypedefDeclaration',baseType:unionDecl,typeName:typeName}}else{throw new Error(`Expected typedef name after union definition at line ${this.currentToken.line}`)}}
if(this.currentToken.type==='ENUM'){const enumDecl=this.parseEnumDeclaration(!1);if(this.currentToken.type==='IDENTIFIER'){const typeName=this.currentToken.value;this.eat('IDENTIFIER');this.eat('SEMICOLON');return{type:'TypedefDeclaration',baseType:enumDecl,typeName:typeName}}else{throw new Error(`Expected typedef name after enum definition at line ${this.currentToken.line}`)}}
const baseType=this.currentToken.value;this.eat(this.currentToken.type);if(this.currentToken.type==='LPAREN'&&this.peekToken.type==='MUL'){this.eat('LPAREN');this.eat('MUL');const typeName=this.currentToken.value;this.eat('IDENTIFIER');this.eat('RPAREN');const parameters=this.parseParameterList();this.eat('SEMICOLON');return{type:'TypedefDeclaration',baseType:{type:'FunctionPointerType',returnType:baseType,parameters:parameters},typeName:typeName}}
const simpleBaseType=this.currentToken.value;this.eat(this.currentToken.type);if(this.currentToken.type==='IDENTIFIER'){const typeName=this.currentToken.value;this.eat('IDENTIFIER');this.eat('SEMICOLON');return{type:'TypedefDeclaration',baseType:{type:'TypeNode',value:simpleBaseType},typeName:typeName}}else{throw new Error(`Expected typedef name at line ${this.currentToken.line}`)}}
parseType(){if(this.currentToken.type==='STRUCT'){let typeName='struct';this.eat('STRUCT');if(this.currentToken.type==='IDENTIFIER'){typeName+=' '+this.currentToken.value;this.eat('IDENTIFIER')}
return{type:'TypeNode',value:typeName}}
let typeValue='';while(['STATIC','EXTERN','VOLATILE','CONST'].includes(this.currentToken.type)){typeValue+=this.currentToken.value+' ';this.eat(this.currentToken.type)}
if(['UNSIGNED','SIGNED'].includes(this.currentToken.type)){typeValue+=this.currentToken.value+' ';this.eat(this.currentToken.type)}
if(isValidType(this.currentToken.type,'parameter')){typeValue+=this.currentToken.value;this.eat(this.currentToken.type)}else{throw new Error(`Expected type name at line ${this.currentToken.line}, column ${this.currentToken.column}, but found '${this.currentToken.value}'`)}
let templateArgs=null;if(this.currentToken.type==='LT'){this.eat('LT');templateArgs=[];if(this.currentToken.type!=='GT'){templateArgs.push(this.parseTemplateArgument());while(this.currentToken.type==='COMMA'){this.eat('COMMA');templateArgs.push(this.parseTemplateArgument())}}
this.eatTemplateClose()}
const typeNode={type:'TypeNode',value:typeValue,templateArgs:templateArgs};return typeNode}
isNamespaceQualifiedVariableDeclaration(){const savedPosition=this.position;const savedChar=this.currentChar;const savedLine=this.line;const savedColumn=this.column;const savedCurrent=this.currentToken;const savedPeek=this.peekToken;const savedPeek2=this.peekToken2;try{this.advanceToken();while(this.currentToken.type==='SCOPE'&&this.peekToken.type==='IDENTIFIER'){this.advanceToken();this.advanceToken()}
const isTemplate=this.currentToken.type==='LT';const isDirectVariable=this.currentToken.type==='IDENTIFIER';const isFunctionCall=this.currentToken.type==='LPAREN';if(isFunctionCall){return!1}
if(isTemplate){let depth=1;this.advanceToken();while(depth>0&&this.currentToken.type!=='EOF'){if(this.currentToken.type==='LT')depth++;else if(this.currentToken.type==='GT')depth--;this.advanceToken()}
return this.currentToken.type==='IDENTIFIER'}
return isDirectVariable}catch(e){return!1}finally{this.position=savedPosition;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.currentToken=savedCurrent;this.peekToken=savedPeek;this.peekToken2=savedPeek2}}
isAnonymousEnumWithVariable(){const savedPosition=this.position;const savedChar=this.currentChar;const savedLine=this.line;const savedColumn=this.column;const savedCurrent=this.currentToken;const savedPeek=this.peekToken;const savedPeek2=this.peekToken2;try{this.advanceToken();this.advanceToken();let braceDepth=1;while(braceDepth>0&&this.currentToken.type!=='EOF'){if(this.currentToken.type==='LBRACE'){braceDepth++}else if(this.currentToken.type==='RBRACE'){braceDepth--}
this.advanceToken()}
return this.currentToken.type==='IDENTIFIER'}catch(e){return!1}finally{this.position=savedPosition;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.currentToken=savedCurrent;this.peekToken=savedPeek;this.peekToken2=savedPeek2}}
parseAnonymousEnumWithVariable(){this.eat('ENUM');this.eat('LBRACE');const members=[];if(this.currentToken.type!=='RBRACE'){members.push(this.parseEnumMember());while(this.currentToken.type==='COMMA'){this.eat('COMMA');if(this.currentToken.type==='RBRACE')break;members.push(this.parseEnumMember())}}
this.eat('RBRACE');const variableName=this.currentToken.value;this.eat('IDENTIFIER');let initializer=null;if(this.currentToken.type==='ASSIGN'){this.eat('ASSIGN');initializer=this.parseExpression()}
this.eat('SEMICOLON');return{type:'AnonymousEnumWithVariable',members:members,variable:{name:variableName,initializer:initializer}}}
parseTemplateArgument(){const currentType=this.currentToken.type;const isTypeName=isValidType(currentType,'any')||isTypeModifier(currentType);if(isTypeName){return this.parseTemplateArgumentType()}else{return this.parseAssignmentExpression(!0)}}
parseTemplateArgumentType(){const baseType=this.parseType();let pointerLevel=0;let typeValue=baseType.value||baseType.name||baseType.type;while(this.currentToken.type==='MUL'){this.eat('MUL');pointerLevel++;typeValue+='*'}
return{type:'TypeNode',value:typeValue,isPointer:pointerLevel>0,pointerLevel:pointerLevel,templateArgs:baseType.templateArgs}}
parseTemplateArgumentExpression(){const start=this.tokenIndex;let bracketDepth=0;let parenDepth=0;let squareDepth=0;const tokens=[];while(this.currentToken.type!=='EOF'){const token=this.currentToken;if(token.type==='LT')bracketDepth++;else if(token.type==='GT'){if(bracketDepth===0)break;bracketDepth--}else if(token.type==='LPAREN')parenDepth++;else if(token.type==='RPAREN')parenDepth--;else if(token.type==='LBRACKET')squareDepth++;else if(token.type==='RBRACKET')squareDepth--;else if(token.type==='COMMA'&&bracketDepth===0&&parenDepth===0&&squareDepth===0){break}
tokens.push(token);this.advanceToken()}
return this.parseAssignmentExpression()}
eatTemplateClose(){if(this.currentToken.type==='GT'){this.eat('GT')}else if(this.currentToken.type==='RSHIFT'){const currentLine=this.currentToken.line;const currentColumn=this.currentToken.column;this.advanceToken();const fakeGT={type:'GT',value:'>',line:currentLine,column:currentColumn+1};this.currentToken=fakeGT}else{throw new Error(`Expected '>' to close template, but found '${this.currentToken.value}' at line ${this.currentToken.line}, column ${this.currentToken.column}`)}}
parseStructMember(){if(this.currentToken.type==='STRUCT'||this.currentToken.type==='UNION'){const isStruct=this.currentToken.type==='STRUCT';if(isStruct){this.eat('STRUCT')}else{this.eat('UNION')}
if(this.currentToken.type==='LBRACE'){this.eat('LBRACE');const members=[];while(this.currentToken.type!=='RBRACE'&&this.currentToken.type!=='EOF'){members.push(this.parseStructMember())}
this.eat('RBRACE');const declarator=this.parseDeclarator();this.eat('SEMICOLON');return{type:'StructMember',memberType:{type:isStruct?'AnonymousStruct':'AnonymousUnion',members:members},declarator:declarator,bitField:null}}}
const type=this.parseType();const declarations=[];const firstDeclarator=this.parseDeclarator();let defaultValue=null;if(this.currentToken.type==='ASSIGN'){this.eat('ASSIGN');defaultValue=this.parseExpression()}
let bitField=null;if(this.currentToken.type==='COLON'){this.eat('COLON');bitField=this.parseExpression()}
declarations.push({declarator:firstDeclarator,defaultValue:defaultValue,bitField:bitField});while(this.currentToken.type==='COMMA'){this.eat('COMMA');const declarator=this.parseDeclarator();let declDefaultValue=null;if(this.currentToken.type==='ASSIGN'){this.eat('ASSIGN');declDefaultValue=this.parseExpression()}
let declBitField=null;if(this.currentToken.type==='COLON'){this.eat('COLON');declBitField=this.parseExpression()}
declarations.push({declarator:declarator,defaultValue:declDefaultValue,bitField:declBitField})}
this.eat('SEMICOLON');if(declarations.length===1){const decl=declarations[0];const memberNode={type:'StructMember',memberType:type,declarator:decl.declarator,bitField:decl.bitField};if(decl.defaultValue!==null){memberNode.defaultValue=decl.defaultValue}
return memberNode}else{return{type:'MultipleStructMembers',memberType:type,declarations:declarations}}}
parseLambdaExpression(){const startLine=this.currentToken.line;const startColumn=this.currentToken.column;this.eat('LBRACKET');const captureList=[];while(this.currentToken.type!=='RBRACKET'&&this.currentToken.type!=='EOF'){if(this.currentToken.type==='ASSIGN'){captureList.push({type:'CaptureAll',mode:'value'});this.eat('ASSIGN')}else if(this.currentToken.type==='AMPERSAND'){captureList.push({type:'CaptureAll',mode:'reference'});this.eat('AMPERSAND')}else if(this.currentToken.type==='IDENTIFIER'){const captureName=this.currentToken.value;this.eat('IDENTIFIER');captureList.push({type:'CaptureVariable',name:captureName,mode:'value'})}
if(this.currentToken.type==='COMMA'){this.eat('COMMA')}}
this.eat('RBRACKET');let parameters=[];if(this.currentToken.type==='LPAREN'){parameters=this.parseParameterList()}
let isMutable=!1;if(this.currentToken.type==='IDENTIFIER'&&this.currentToken.value==='mutable'){isMutable=!0;this.eat('IDENTIFIER')}
let returnType=null;if(this.currentToken.type==='ARROW'){this.eat('ARROW');returnType=this.parseType()}
let body=null;if(this.currentToken.type==='LBRACE'){body=this.parseCompoundStatement()}else{throw new Error(`Expected lambda body at line ${this.currentToken.line}, column ${this.currentToken.column}`)}
return{type:'LambdaExpression',captureList:captureList,parameters:parameters,body:body,mutable:isMutable,returnType:returnType,line:startLine,column:startColumn}}
parseExpression(){return this.parseCommaExpression()}
parseCommaExpression(){let left=this.parseAssignmentExpression();while(this.currentToken.type==='COMMA'){const operator=this.currentToken;this.eat('COMMA');const right=this.parseAssignmentExpression();left={type:'CommaExpression',left,op:operator,right}}
return left}
parseAssignmentExpression(inTemplate=!1){const left=this.parseTernaryExpression(inTemplate);const assignmentTokens=['ASSIGN','PLUS_ASSIGN','MINUS_ASSIGN','MUL_ASSIGN','DIV_ASSIGN','MOD_ASSIGN','AND_ASSIGN','OR_ASSIGN','XOR_ASSIGN','LSHIFT_ASSIGN','RSHIFT_ASSIGN'];if(assignmentTokens.includes(this.currentToken.type)){const operator=this.currentToken.value;this.eat(this.currentToken.type);const right=this.parseAssignmentExpression(inTemplate);return{type:'AssignmentNode',operator,left,right}}
return left}
parseTernaryExpression(inTemplate=!1){const condition=this.parseBinaryExpression(0,inTemplate);if(this.currentToken.type==='QUESTION'){this.eat('QUESTION');const consequent=this.parseExpression();this.eat('COLON');const alternate=this.parseTernaryExpression();return{type:'TernaryExpression',condition,consequent,alternate}}
return condition}
parseBinaryExpression(precedence=0,inTemplate=!1){let left=this.parseUnaryExpression();while(precedence<(PRECEDENCE[this.currentToken.type]||0)){if(inTemplate&&(this.currentToken.type==='GT'||this.currentToken.type==='COMMA')){break}
const operator=this.currentToken;this.eat(operator.type);const right=this.parseBinaryExpression(PRECEDENCE[operator.type],inTemplate);left={type:'BinaryOpNode',left,op:operator,right}}
return left}
parseUnaryExpression(){if(['NOT','MINUS','PLUS','PLUS_PLUS','MINUS_MINUS','BITWISE_NOT','AMPERSAND','MUL'].includes(this.currentToken.type)){const operator=this.currentToken;this.advanceToken();if(operator.type==='MUL'){const operand=this.parseUnaryExpression();return{type:'UnaryOpNode',op:{...operator,value:'*',semantic:'dereference'},operand}}
if(operator.type==='AMPERSAND'){const operand=this.parseUnaryExpression();return{type:'UnaryOpNode',op:{...operator,value:'&',semantic:'address-of'},operand}}
const operand=this.parseUnaryExpression();return{type:'UnaryOpNode',op:operator,operand}}
if(this.currentToken.type==='SIZEOF'){this.eat('SIZEOF');if(this.currentToken.type==='LPAREN'){this.eat('LPAREN');const currentType=this.currentToken.type;const isValidTypeToken=isValidType(currentType,'any');let isSimpleTypeName=!1;if(isValidTypeToken&&this.peekToken){if(this.peekToken.type==='RPAREN'){isSimpleTypeName=!0}else if(this.peekToken.type==='MUL'&&this.peekToken2&&this.peekToken2.type==='RPAREN'){isSimpleTypeName=!0}}
if(isSimpleTypeName){let typeName=this.currentToken.value;this.eat(this.currentToken.type);if(this.currentToken.type==='MUL'){typeName+='*';this.eat('MUL')}
this.eat('RPAREN');return{type:'SizeofExpression',operand:{type:'TypeNode',value:typeName}}}else{const expr=this.parseExpression();this.eat('RPAREN');return{type:'SizeofExpression',operand:expr}}}
const operand=this.parseUnaryExpression();return{type:'SizeofExpression',operand}}
if(this.currentToken.type==='NEW'){return this.parseNewExpression()}
return this.parsePostfixExpression()}
parseNewExpression(){this.eat('NEW');const type=this.parseType();if(this.currentToken.type==='LBRACKET'){this.eat('LBRACKET');const size=this.parseExpression();this.eat('RBRACKET');return{type:'NewExpression',allocationType:type,isArray:!0,size:size}}
let args=[];if(this.currentToken.type==='LPAREN'){this.eat('LPAREN');if(this.currentToken.type!=='RPAREN'){args.push(this.parseExpression());while(this.currentToken.type==='COMMA'){this.eat('COMMA');args.push(this.parseExpression())}}
this.eat('RPAREN')}
return{type:'NewExpression',allocationType:type,isArray:!1,arguments:args}}
parsePostfixExpression(){let left=this.parseCallMemberExpression();if(this.currentToken.type==='PLUS_PLUS'||this.currentToken.type==='MINUS_MINUS'){const operator=this.currentToken;this.eat(operator.type);return{type:'PostfixExpressionNode',operand:left,op:operator}}
return left}
parseCallMemberExpression(){let left=this.parsePrimaryExpression();while(this.currentToken.type==='DOT'||this.currentToken.type==='ARROW'||this.currentToken.type==='SCOPE'||this.currentToken.type==='LPAREN'||this.currentToken.type==='LBRACKET'){if(this.currentToken.type==='DOT'||this.currentToken.type==='ARROW'){const operatorType=this.currentToken.type;this.eat(operatorType);const property={type:'IdentifierNode',value:this.currentToken.value};this.eat('IDENTIFIER');left={type:'MemberAccessNode',object:left,property,operator:operatorType}}else if(this.currentToken.type==='SCOPE'){this.eat('SCOPE');const property={type:'IdentifierNode',value:this.currentToken.value};this.eat('IDENTIFIER');left={type:'NamespaceAccessNode',namespace:left,member:property}}else if(this.currentToken.type==='LBRACKET'){this.eat('LBRACKET');const index=this.parseExpression();this.eat('RBRACKET');left={type:'ArrayAccessNode',identifier:left,index}}else{left=this.parseFunctionCall(left)}}
return left}
parsePrimaryExpression(){const token=this.currentToken;if(['STATIC_CAST','DYNAMIC_CAST','CONST_CAST','REINTERPRET_CAST'].includes(token.type)){return this.parseCppCast()}
if(token.type==='LPAREN'){const savedPosition=this.position;const savedChar=this.currentChar;const savedLine=this.line;const savedColumn=this.column;const savedCurrent=this.currentToken;const savedPeek=this.peekToken;const savedPeek2=this.peekToken2;this.advanceToken();const possibleType=this.currentToken.type;let isCast=!1;const isValidForCast=isValidType(possibleType,'cast');if(isValidForCast&&this.peekToken.type==='RPAREN'){const nextAfterRParen=this.peekToken2?.type;const canStartExpression=['IDENTIFIER','NUMBER','HEX_NUMBER','OCTAL_NUMBER','BINARY_NUMBER','FLOAT_NUMBER','STRING_LITERAL','CHAR_LITERAL','TRUE','FALSE','LPAREN','MINUS','PLUS','NOT','BITWISE_NOT','PLUS_PLUS','MINUS_MINUS','AMPERSAND','MUL','SIZEOF','HIGH','LOW','INPUT','OUTPUT','INPUT_PULLUP','INPUT_PULLDOWN','OUTPUT_OPENDRAIN'].includes(nextAfterRParen);if(canStartExpression){isCast=!0}}
if(!isCast&&isValidForCast){let tempPos=this.position;let tempChar=this.currentChar;let tempLine=this.line;let tempColumn=this.column;let tempCurrent=this.currentToken;let tempPeek=this.peekToken;let tempPeek2=this.peekToken2;try{this.advanceToken();if(['CONST','VOLATILE'].includes(possibleType)){if(isValidType(this.currentToken.type,'cast')){this.advanceToken()}}else if(possibleType==='UNSIGNED'&&['LONG','INT','SHORT','CHAR'].includes(this.currentToken.type)){this.advanceToken();if(this.currentToken.type==='INT'){this.advanceToken()}}else if(possibleType==='LONG'&&this.currentToken.type==='LONG'){this.advanceToken();if(this.currentToken.type==='INT'){this.advanceToken()}}
while(this.currentToken.type==='MUL'){this.advanceToken()}
if(this.currentToken.type==='RPAREN'){this.advanceToken();const nextToken=this.currentToken.type;const canStartExpression=['IDENTIFIER','NUMBER','HEX_NUMBER','OCTAL_NUMBER','BINARY_NUMBER','FLOAT_NUMBER','STRING_LITERAL','CHAR_LITERAL','TRUE','FALSE','LPAREN','MINUS','PLUS','NOT','BITWISE_NOT','PLUS_PLUS','MINUS_MINUS','AMPERSAND','MUL','SIZEOF'].includes(nextToken);isCast=canStartExpression}else{isCast=!1}}catch(e){isCast=!1}
this.position=tempPos;this.currentChar=tempChar;this.line=tempLine;this.column=tempColumn;this.currentToken=tempCurrent;this.peekToken=tempPeek;this.peekToken2=tempPeek2}
this.position=savedPosition;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.currentToken=savedCurrent;this.peekToken=savedPeek;this.peekToken2=savedPeek2;if(isCast){return this.parseCastExpression()}else{this.eat('LPAREN');const expr=this.parseExpression();this.eat('RPAREN');return expr}}
switch(token.type){case 'NUMBER':case 'HEX_NUMBER':case 'OCTAL_NUMBER':case 'BINARY_NUMBER':case 'FLOAT_NUMBER':this.eat(token.type);const node={type:'NumberNode',value:token.value};if(this.options.includePositions){node.line=token.line;node.column=token.column}
return node;case 'STRING_LITERAL':const currentStringToken=this.currentToken;this.eat('STRING_LITERAL');const stringNode={type:'StringLiteralNode',value:currentStringToken.value};if(this.options.includePositions){stringNode.line=currentStringToken.line;stringNode.column=currentStringToken.column}
if(currentStringToken.rawString){stringNode.rawString=currentStringToken.rawString;stringNode.delimiter=currentStringToken.delimiter}
if(currentStringToken.unterminated){stringNode.unterminated=currentStringToken.unterminated}
return stringNode;case 'CHAR_LITERAL':this.eat('CHAR_LITERAL');const charNode={type:'CharLiteralNode',value:token.value};if(this.options.includePositions){charNode.line=token.line;charNode.column=token.column}
return charNode;case 'WIDE_CHAR_LITERAL':this.eat('WIDE_CHAR_LITERAL');return{type:'WideCharLiteralNode',value:token.value};case 'STRING':this.eat('STRING');return{type:'IdentifierNode',value:token.value};case 'LBRACE':return this.parseArrayInitializer();case 'LBRACKET':return this.parseLambdaExpression();case 'IDENTIFIER':case 'LED_BUILTIN':case 'HIGH':case 'LOW':case 'OUTPUT':case 'INPUT':case 'INPUT_PULLUP':case 'INPUT_PULLDOWN':case 'OUTPUT_OPENDRAIN':case 'TRUE':case 'FALSE':case 'HEX':case 'DEC':case 'OCT':case 'BIN':case 'NULL':case 'NULLPTR':case 'ARDUINO_FUNC':this.advanceToken();let nodeType;if(token.type==='IDENTIFIER'){nodeType='IdentifierNode'}else if(token.type==='ARDUINO_FUNC'){nodeType='ArduinoFunctionNode'}else{nodeType='ConstantNode'}
const resultNode={type:nodeType,value:token.value};if(this.options.includePositions){resultNode.line=token.line;resultNode.column=token.column}
return resultNode}
if(['BYTE','INT','LONG','FLOAT','DOUBLE','CHAR','SHORT','BOOL','BOOLEAN','UINT8_T','INT8_T','UINT16_T','INT16_T','UINT32_T','INT32_T','UINT64_T','INT64_T'].includes(token.type)&&this.peekToken.type==='LPAREN'){const castType=token.value;this.advanceToken();this.eat('LPAREN');const argument=this.parseExpression();this.eat('RPAREN');return{type:'FunctionStyleCastNode',castType:castType,argument:argument}}
if(['PRIVATE','PUBLIC','PROTECTED','RETURN'].includes(token.type)){this.advanceToken();return{type:'IdentifierNode',value:'SKIPPED_'+token.type}}
const{line,column,type}=this.currentToken;throw new Error(`Parsing Error on line ${line}, column: ${column}: Unexpected token ${type} in expression.`)}
parseCppCast(){const castType=this.currentToken.value;this.eat(this.currentToken.type);this.eat('LT');const targetType=this.parseType();this.eatTemplateClose();this.eat('LPAREN');const expression=this.parseExpression();this.eat('RPAREN');return{type:'CppCastNode',castType:castType,targetType:targetType,expression:expression}}
parseCastExpression(){this.eat('LPAREN');let castType='';while(['CONST','VOLATILE'].includes(this.currentToken.type)){castType+=this.currentToken.value+' ';this.eat(this.currentToken.type)}
castType+=this.currentToken.value;const mainType=this.currentToken.type;this.eat(this.currentToken.type);if(mainType==='UNSIGNED'&&['LONG','INT','SHORT','CHAR'].includes(this.currentToken.type)){castType+=' '+this.currentToken.value;this.eat(this.currentToken.type);if(this.currentToken.type==='INT'){castType+=' '+this.currentToken.value;this.eat(this.currentToken.type)}}else if(mainType==='LONG'&&this.currentToken.type==='LONG'){castType+=' '+this.currentToken.value;this.eat(this.currentToken.type);if(this.currentToken.type==='INT'){castType+=' '+this.currentToken.value;this.eat(this.currentToken.type)}}
while(this.currentToken.type==='MUL'){castType+='*';this.eat('MUL')}
this.eat('RPAREN');const operand=this.parseUnaryExpression();return{type:'CastExpression',castType,operand}}
parseArrayInitializer(){this.eat('LBRACE');const elements=[];if(this.currentToken.type!=='RBRACE'){elements.push(this.parseInitializerElement());while(this.currentToken.type==='COMMA'){this.eat('COMMA');if(this.currentToken.type==='RBRACE')break;elements.push(this.parseInitializerElement())}}
this.eat('RBRACE');return{type:'ArrayInitializerNode',elements}}
parseInitializerElement(){if(this.currentToken.type==='DOT'){this.eat('DOT');const fieldName=this.currentToken.value;this.eat('IDENTIFIER');this.eat('ASSIGN');const value=this.parseAssignmentExpression();return{type:'DesignatedInitializerNode',field:fieldName,value:value}}
return this.parseAssignmentExpression()}
parseFunctionCall(callee){this.eat('LPAREN');const args=[];if(this.currentToken.type!=='RPAREN'){args.push(this.parseAssignmentExpression());while(this.currentToken.type==='COMMA'){this.eat('COMMA');args.push(this.parseAssignmentExpression())}}
this.eat('RPAREN');return{type:'FuncCallNode',callee,arguments:args}}
parseConstructorCall(typeValue){const callee={type:'IdentifierNode',value:typeValue};this.eat('LPAREN');const args=[];if(this.currentToken.type!=='RPAREN'){args.push(this.parseAssignmentExpression());while(this.currentToken.type==='COMMA'){this.eat('COMMA');args.push(this.parseAssignmentExpression())}}
this.eat('RPAREN');return{type:'ConstructorCallNode',callee:callee,arguments:args}}
parseFunctionDefinition(){let storageClass='';if(['STATIC','EXTERN','VOLATILE'].includes(this.currentToken.type)){storageClass=this.currentToken.value;this.eat(this.currentToken.type)}
let typeModifiers='';while(['CONST','VOLATILE'].includes(this.currentToken.type)){typeModifiers+=this.currentToken.value+' ';this.eat(this.currentToken.type)}
let returnTypeValue=this.currentToken.value;this.eat(this.currentToken.type);while(this.currentToken.type==='MUL'){returnTypeValue+='*';this.eat('MUL')}
let fullReturnType='';if(storageClass)fullReturnType+=storageClass+' ';if(typeModifiers)fullReturnType+=typeModifiers;fullReturnType+=returnTypeValue;const typeNode={type:'TypeNode',value:fullReturnType.trim()};const declarator={type:'DeclaratorNode',value:this.currentToken.value};this.eat('IDENTIFIER');const parameters=this.parseParameterList();const body=this.parseCompoundStatement();return{type:'FuncDefNode',returnType:typeNode,declarator,parameters,body}}
parseConstructorDefinition(){const className={type:'IdentifierNode',value:this.currentToken.value};this.eat('IDENTIFIER');this.eat('SCOPE');const constructorName={type:'IdentifierNode',value:this.currentToken.value};this.eat('IDENTIFIER');const parameters=this.parseParameterList();let initializerList=[];if(this.currentToken.type==='COLON'){this.eat('COLON');do{const memberName={type:'IdentifierNode',value:this.currentToken.value};this.eat('IDENTIFIER');this.eat('LPAREN');const initValue=this.parseExpression();this.eat('RPAREN');initializerList.push({type:'MemberInitializer',member:memberName,value:initValue});if(this.currentToken.type==='COMMA'){this.eat('COMMA')}else{break}}while(!0);}
const body=this.parseCompoundStatement();return{type:'ConstructorDefinition',className:className,constructorName:constructorName,parameters:parameters,initializerList:initializerList,body:body}}
parseScopedFunctionDefinition(){const className={type:'IdentifierNode',value:this.currentToken.value};this.eat('IDENTIFIER');this.eat('SCOPE');let isDestructor=!1;if(this.currentToken.type==='BITWISE_NOT'){isDestructor=!0;this.eat('BITWISE_NOT')}
const methodName={type:'IdentifierNode',value:this.currentToken.value};this.eat('IDENTIFIER');const parameters=this.parseParameterList();let initializerList=[];if(!isDestructor&&this.currentToken.type==='COLON'){this.eat('COLON');do{const memberName={type:'IdentifierNode',value:this.currentToken.value};this.eat('IDENTIFIER');this.eat('LPAREN');const initValue=this.parseExpression();this.eat('RPAREN');initializerList.push({type:'MemberInitializer',member:memberName,value:initValue})}while(this.currentToken.type==='COMMA'&&(this.advanceToken(),!0));}
const body=this.parseCompoundStatement();if(isDestructor){return{type:'DestructorDefinition',className:className,destructorName:methodName,parameters:parameters,body:body}}else{return{type:'ScopedFunctionDefinition',className:className,methodName:methodName,parameters:parameters,initializerList:initializerList,body:body}}}
parseScopedMethodDefinition(){const returnType=this.parseType();const className={type:'IdentifierNode',value:this.currentToken.value};this.eat('IDENTIFIER');this.eat('SCOPE');let isDestructor=!1;if(this.currentToken.type==='BITWISE_NOT'){isDestructor=!0;this.eat('BITWISE_NOT')}
const methodName={type:'IdentifierNode',value:this.currentToken.value};this.eat('IDENTIFIER');const parameters=this.parseParameterList();let initializerList=[];const body=this.parseCompoundStatement();if(isDestructor){return{type:'ScopedDestructorDefinition',returnType:returnType,className:className,destructorName:methodName,parameters:parameters,body:body}}else{return{type:'ScopedMethodDefinition',returnType:returnType,className:className,methodName:methodName,parameters:parameters,body:body}}}
parseParameterList(){const params=[];this.eat('LPAREN');if(this.currentToken.type==='RPAREN'){this.eat('RPAREN');return params}
params.push(this.parseParameter());while(this.currentToken.type==='COMMA'){this.eat('COMMA');if(this.currentToken.type==='ELLIPSIS'){this.eat('ELLIPSIS');params.push({type:'VariadicParameter',name:'...'});break}else{params.push(this.parseParameter())}}
this.eat('RPAREN');return params}
parseParameter(){let typeValue=this.currentToken.value;const currentType=this.currentToken.type;if(!isValidType(currentType,'parameter')&&!isTypeModifier(currentType)&&!isStorageClass(currentType)){throw new Error(`Expected type in parameter, but found '${this.currentToken.value}' (${currentType}) at line ${this.currentToken.line}, column ${this.currentToken.column}`)}
if(['UNSIGNED','SIGNED','CONST','VOLATILE','STATIC'].includes(currentType)){typeValue+=' ';this.eat(currentType);if(this.currentToken.type!=='RPAREN'&&this.currentToken.type!=='COMMA'){typeValue+=this.currentToken.value;this.eat(this.currentToken.type)}}else{this.eat(currentType)}
let pointerLevel=0;while(this.currentToken.type==='MUL'){this.eat('MUL');typeValue+='*';pointerLevel++}
let isReference=!1;if(this.currentToken.type==='AMPERSAND'){this.eat('AMPERSAND');typeValue+='&';isReference=!0}
const typeNode={type:'TypeNode',value:typeValue,isPointer:pointerLevel>0,pointerLevel:pointerLevel};if(isReference){typeNode.isReference=isReference}
if(this.currentToken.type==='LPAREN'&&this.peekToken.type==='MUL'){this.eat('LPAREN');this.eat('MUL');const name=this.currentToken.value;this.eat('IDENTIFIER');this.eat('RPAREN');const parameters=this.parseParameterList();const declarator={type:'FunctionPointerDeclaratorNode',identifier:{type:'IdentifierNode',value:name},parameters:parameters};return{type:'ParamNode',paramType:typeNode,declarator:declarator}}
if(this.currentToken.type==='IDENTIFIER'){const declarator={type:'DeclaratorNode',value:this.currentToken.value};this.eat('IDENTIFIER');if(this.currentToken.type==='LBRACKET'){this.eat('LBRACKET');let arraySize=null;if(this.currentToken.type!=='RBRACKET'){arraySize=this.parseExpression()}
this.eat('RBRACKET');declarator.type='ArrayDeclaratorNode';declarator.identifier={type:'IdentifierNode',value:declarator.value};declarator.dimensions=[arraySize];delete declarator.value}
const result={type:'ParamNode',paramType:typeNode,declarator:declarator};if(this.currentToken.type==='ASSIGN'){this.eat('ASSIGN');result.defaultValue=this.parseExpression()}
return result}else{return{type:'ParamNode',paramType:typeNode,declarator:{type:'DeclaratorNode',value:''}}}}
parseVariableDeclaration(expectSemicolon=!0){let typeValue='';let isPointer=!1;let pointerLevel=0;if(['STATIC','EXTERN','PROGMEM'].includes(this.currentToken.type)){const storageClass=this.currentToken.value;this.eat(this.currentToken.type);typeValue+=storageClass+' '}
if(this.currentToken.type==='VOLATILE'){this.eat('VOLATILE');typeValue+='volatile '}
if(this.currentToken.type==='CONSTEXPR'){this.eat('CONSTEXPR');typeValue+='constexpr '}
if(this.currentToken.type==='CONST'){this.eat('CONST');typeValue+='const '}
if(this.currentToken.type==='PROGMEM'){this.eat('PROGMEM');typeValue+='PROGMEM '}
if(this.currentToken.type==='UNSIGNED'){this.eat('UNSIGNED');typeValue+='unsigned '}
if(this.currentToken.type==='STRUCT'){const structType=this.parseStructDeclaration();typeValue+='struct '+(structType.name||'')}else if(this.currentToken.type==='DECLTYPE'){this.eat('DECLTYPE');typeValue+='decltype';this.eat('LPAREN');typeValue+='(';const expr=this.parseExpression();if(expr&&expr.type){typeValue+=expr.value||'expr'}
this.eat('RPAREN');typeValue+=')'}else{typeValue+=this.currentToken.value;this.eat(this.currentToken.type);if(this.currentToken.type==='SCOPE'){this.eat('SCOPE');typeValue+='::';typeValue+=this.currentToken.value;this.eat('IDENTIFIER')}
if(this.currentToken.type==='LT'){this.eat('LT');typeValue+='<';if(this.currentToken.type!=='GT'){const firstArg=this.parseTemplateArgument();if(firstArg.type==='TypeNode'){typeValue+=firstArg.value}else{typeValue+=firstArg.value||'unknown'}
while(this.currentToken.type==='COMMA'){this.eat('COMMA');typeValue+=', ';const arg=this.parseTemplateArgument();if(arg.type==='TypeNode'){typeValue+=arg.value}else{typeValue+=arg.value||'unknown'}}}
this.eatTemplateClose();typeValue+='>'}
if(['LONG','INT','SHORT','CHAR','DOUBLE'].includes(this.currentToken.type)){typeValue+=' '+this.currentToken.value;this.eat(this.currentToken.type)}}
if(this.currentToken.type==='CONST'){this.eat('CONST');typeValue+=' const'}
while(this.currentToken.type==='MUL'){isPointer=!0;pointerLevel++;this.eat('MUL')}
if(isPointer){typeValue+=' '+'*'.repeat(pointerLevel)}
let isReference=!1;if(this.currentToken.type==='AMPERSAND'){isReference=!0;this.eat('AMPERSAND');typeValue+='&'}
const typeNode={type:'TypeNode',value:typeValue.trim(),isPointer,pointerLevel,isReference};const declarations=[];declarations.push(this.parseVariableDeclarator(typeValue));while(this.currentToken.type==='COMMA'){this.eat('COMMA');declarations.push(this.parseVariableDeclarator(typeValue))}
if(expectSemicolon){if(this.currentToken.type==='LBRACE'){let braceDepth=1;this.advanceToken();while(braceDepth>0&&this.currentToken.type!=='EOF'){if(this.currentToken.type==='LBRACE'){braceDepth++}else if(this.currentToken.type==='RBRACE'){braceDepth--}
this.advanceToken()}
return{type:'VarDeclNode',varType:typeNode,declarations}}else if(this.currentToken.type==='RETURN'){while(this.currentToken.type!=='EOF'&&this.currentToken.type!=='SEMICOLON'&&this.currentToken.type!=='RBRACE'){this.advanceToken()}
if(this.currentToken.type==='SEMICOLON'){this.advanceToken()}
return{type:'VarDeclNode',varType:typeNode,declarations}}else{this.eat('SEMICOLON')}}
return{type:'VarDeclNode',varType:typeNode,declarations}}
parseVariableDeclarator(typeValue=null){const declarator=this.parseDeclarator();let initializer=null;if(this.currentToken.type==='ASSIGN'){this.eat('ASSIGN');if(['PRIVATE','PUBLIC','PROTECTED','RETURN'].includes(this.currentToken.type)){this.advanceToken();if(['SEMICOLON','COMMA','RBRACE'].includes(this.currentToken.type)){initializer=null}else{try{initializer=this.parseExpression()}catch(e){initializer=null}}}else{initializer=this.parseExpression()}}else if(this.currentToken.type==='LPAREN'){initializer=this.parseConstructorCall(typeValue)}
return{declarator,initializer}}
parseDeclarator(){let hasProgmemPrefix=!1;if(this.currentToken.type==='PROGMEM'){hasProgmemPrefix=!0;this.eat('PROGMEM')}
if(this.currentToken.type==='LPAREN'&&this.peekToken.type==='MUL'){this.eat('LPAREN');this.eat('MUL');const identifier={type:'IdentifierNode',value:this.currentToken.value};this.eat('IDENTIFIER');this.eat('RPAREN');if(this.currentToken.type==='LPAREN'){const parameters=this.parseParameterList();return{type:'FunctionPointerDeclaratorNode',identifier:identifier,parameters:parameters}}
return{type:'PointerDeclaratorNode',identifier:identifier}}
if(this.currentToken.type==='MUL'){this.eat('MUL');if(this.currentToken.type==='IDENTIFIER'){const identifier={type:'IdentifierNode',value:this.currentToken.value};this.eat('IDENTIFIER');return{type:'PointerDeclaratorNode',identifier:identifier}}else{throw new Error(`Parsing Error on line ${this.currentToken.line}: Expected identifier after *`)}}
if(this.currentToken.type!=='IDENTIFIER'){throw new Error(`Parsing Error on line ${this.currentToken.line}: Expected identifier in declarator`)}
const identifier={type:'IdentifierNode',value:this.currentToken.value};this.eat('IDENTIFIER');const dimensions=[];while(this.currentToken.type==='LBRACKET'){this.eat('LBRACKET');let size=null;if(this.currentToken.type!=='RBRACKET'){size=this.parseExpression()}
this.eat('RBRACKET');dimensions.push(size)}
let hasProgmem=!1;if(this.currentToken.type==='PROGMEM'){hasProgmem=!0;this.eat('PROGMEM')}
if(dimensions.length>0){const arrayNode={type:'ArrayDeclaratorNode',identifier:identifier,dimensions:dimensions,hasProgmem:hasProgmem||hasProgmemPrefix};return arrayNode}
const declaratorNode={type:'DeclaratorNode',value:identifier.value};if(hasProgmem||hasProgmemPrefix){declaratorNode.hasProgmem=!0}
return declaratorNode}
parse(){const programNode={type:'ProgramNode',children:[]};while(this.currentToken.type!=='EOF'){try{programNode.children.push(this.parseTopLevelStatement())}catch(e){if(this.options&&this.options.verbose){console.error(e)}
programNode.children.push({type:'ErrorNode',value:e.message});while(this.currentToken.type!=='EOF'&&this.currentToken.type!=='SEMICOLON'&&this.currentToken.type!=='RBRACE'){this.advanceToken()}
if(this.currentToken.type==='SEMICOLON'||this.currentToken.type==='RBRACE'){this.advanceToken()}}}
return programNode}
isConstructorCall(){const savedPosition=this.position;const savedChar=this.currentChar;const savedLine=this.line;const savedColumn=this.column;const savedCurrent=this.currentToken;const savedPeek=this.peekToken;const savedPeek2=this.peekToken2;try{this.advanceToken();this.advanceToken();this.advanceToken();if(this.currentToken.type==='RPAREN'){this.advanceToken();return this.currentToken.type==='SEMICOLON'}
const firstTokenType=this.currentToken.type;const isExplicitType=TYPE_CATEGORIES.FUNDAMENTAL.includes(firstTokenType)||TYPE_CATEGORIES.FIXED_WIDTH.includes(firstTokenType)||TYPE_CATEGORIES.STDLIB.includes(firstTokenType)||TYPE_CATEGORIES.ARDUINO.includes(firstTokenType)||TYPE_CATEGORIES.MODIFIERS.includes(firstTokenType);if(isExplicitType){this.advanceToken();if(this.currentToken.type==='IDENTIFIER'){return!1}}
if(firstTokenType==='IDENTIFIER'){const possibleTypeName=this.currentToken.value;this.advanceToken();if(this.currentToken.type==='IDENTIFIER'||possibleTypeName?.match(/^(uint|int)\d+_t$/)){return!1}
if(['COMMA','RPAREN'].includes(this.currentToken.type)){return!0}}
if(['NUMBER','HEX_NUMBER','OCTAL_NUMBER','BINARY_NUMBER','FLOAT_NUMBER','STRING_LITERAL','CHAR_LITERAL','HIGH','LOW','TRUE','FALSE'].includes(firstTokenType)){return!0}
return!1}finally{this.position=savedPosition;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.currentToken=savedCurrent;this.peekToken=savedPeek;this.peekToken2=savedPeek2}}
isFunctionDeclaration(){const savedPosition=this.position;const savedChar=this.currentChar;const savedLine=this.line;const savedColumn=this.column;const savedCurrent=this.currentToken;const savedPeek=this.peekToken;const savedPeek2=this.peekToken2;try{this.advanceToken();this.advanceToken();this.advanceToken();let parenDepth=1;while(parenDepth>0&&this.currentToken.type!=='EOF'){if(this.currentToken.type==='LPAREN'){parenDepth++}else if(this.currentToken.type==='RPAREN'){parenDepth--}
if(parenDepth>0){this.advanceToken()}}
if(this.currentToken.type==='RPAREN'){this.advanceToken();return this.currentToken.type==='SEMICOLON'}
return!1}catch(e){return!1}finally{this.position=savedPosition;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.currentToken=savedCurrent;this.peekToken=savedPeek;this.peekToken2=savedPeek2}}
parseFunctionDeclaration(){let storageClass='';if(['STATIC','EXTERN','VOLATILE'].includes(this.currentToken.type)){storageClass=this.currentToken.value;this.eat(this.currentToken.type)}
let typeModifiers='';while(['CONST','VOLATILE'].includes(this.currentToken.type)){typeModifiers+=this.currentToken.value+' ';this.eat(this.currentToken.type)}
let returnTypeValue=this.currentToken.value;this.eat(this.currentToken.type);while(this.currentToken.type==='MUL'){returnTypeValue+='*';this.eat('MUL')}
let fullReturnType='';if(storageClass)fullReturnType+=storageClass+' ';if(typeModifiers)fullReturnType+=typeModifiers;fullReturnType+=returnTypeValue;const typeNode={type:'TypeNode',value:fullReturnType.trim()};const declarator={type:'DeclaratorNode',value:this.currentToken.value};this.eat('IDENTIFIER');const parameters=this.parseParameterList();this.eat('SEMICOLON');return{type:'FuncDeclNode',returnType:typeNode,declarator,parameters}}
addError(message){if(this.options&&this.options.verbose){console.error(`Parser Error: ${message}`)}}
skipToNext(tokenTypes){while(this.currentToken.type!=='EOF'&&!tokenTypes.includes(this.currentToken.type)){this.advanceToken()}}
parseBlock(){return this.parseCompoundStatement()}
parseClassDeclaration(){this.eat('CLASS');const className=this.currentToken.value;this.eat('IDENTIFIER');let baseClasses=[];if(this.currentToken.type==='COLON'){this.eat('COLON');do{let accessSpecifier='private';if(['PUBLIC','PRIVATE','PROTECTED'].includes(this.currentToken.type)){accessSpecifier=this.currentToken.value;this.eat(this.currentToken.type)}
const baseClassName=this.currentToken.value;this.eat('IDENTIFIER');baseClasses.push({type:'BaseClass',name:baseClassName,accessSpecifier:accessSpecifier});if(this.currentToken.type==='COMMA'){this.eat('COMMA')}else{break}}while(this.currentToken.type==='PUBLIC'||this.currentToken.type==='PRIVATE'||this.currentToken.type==='PROTECTED'||this.currentToken.type==='IDENTIFIER');}
this.eat('LBRACE');const members=[];let currentAccessSpecifier='private';while(this.currentToken.type!=='RBRACE'&&this.currentToken.type!=='EOF'){if(['PUBLIC','PRIVATE','PROTECTED'].includes(this.currentToken.type)){currentAccessSpecifier=this.currentToken.value;this.eat(this.currentToken.type);this.eat('COLON');continue}
try{const member=this.parseClassMember(className,currentAccessSpecifier);if(member){member.accessSpecifier=currentAccessSpecifier;members.push(member)}}catch(error){this.addError(`Error parsing class member: ${error.message}`);this.skipToNext(['SEMICOLON','RBRACE','PUBLIC','PRIVATE','PROTECTED']);if(this.currentToken.type==='SEMICOLON'){this.advanceToken()}}}
this.eat('RBRACE');this.eat('SEMICOLON');return{type:'ClassDeclaration',name:className,baseClasses:baseClasses,members:members}}
parseClassMember(className,accessSpecifier){const currentType=this.currentToken.type;const peekType=this.peekToken?.type;const peek2Type=this.peekToken2?.type;if(currentType==='SEMICOLON'){this.eat('SEMICOLON');return null}
if(currentType==='IDENTIFIER'&&this.currentToken.value===className&&peekType==='LPAREN'){return this.parseConstructor(className)}
if(currentType==='BITWISE_NOT'&&peekType==='IDENTIFIER'&&this.peekToken.value===className){this.advanceToken();this.advanceToken();if(this.currentToken.type==='LPAREN'){this.skipToNext(['SEMICOLON','LBRACE','RBRACE']);if(this.currentToken.type==='SEMICOLON'){this.advanceToken()}}
return null}
const isType=isValidType(currentType,'any')||isTypeModifier(currentType)||isStorageClass(currentType);if(isType&&peekType==='IDENTIFIER'&&peek2Type==='LPAREN'){return this.parseMemberFunctionOrDeclaration()}
if(isType){try{return this.parseVariableDeclaration()}catch(e){this.skipToNext(['SEMICOLON','RBRACE','PUBLIC','PRIVATE','PROTECTED']);if(this.currentToken.type==='SEMICOLON'){this.advanceToken()}
return null}}
if(this.options&&this.options.verbose){console.warn(`Skipping unknown class member token: ${currentType} (${this.currentToken.value}) at line ${this.currentToken.line}`)}
this.advanceToken();return null}
parseConstructor(className){this.eat('IDENTIFIER');const parameters=this.parseParameterList();let initializerList=null;if(this.currentToken.type==='COLON'){this.eat('COLON');initializerList=[];do{const memberName=this.currentToken.value;this.eat('IDENTIFIER');this.eat('LPAREN');const initValue=this.parseExpression();this.eat('RPAREN');initializerList.push({type:'MemberInitializer',member:memberName,value:initValue});if(this.currentToken.type==='COMMA'){this.eat('COMMA')}}while(this.currentToken.type==='IDENTIFIER');}
const body=this.parseBlock();return{type:'ConstructorDeclaration',name:className,parameters:parameters,initializerList:initializerList,body:body}}
parseMemberFunctionOrDeclaration(){const returnType=this.currentToken.value;this.eat(this.currentToken.type);const functionName=this.currentToken.value;this.eat('IDENTIFIER');const parameters=this.parseParameterList();let isConst=!1;if(this.currentToken.type==='CONST'){isConst=!0;this.eat('CONST')}
if(this.currentToken.type==='SEMICOLON'){this.eat('SEMICOLON');return{type:'MemberFunctionDeclaration',returnType:returnType,name:functionName,parameters:parameters,isConst:isConst,body:null}}else{const body=this.parseBlock();return{type:'MemberFunctionDeclaration',returnType:returnType,name:functionName,parameters:parameters,isConst:isConst,body:body}}}
parseTemplateDeclaration(){this.eat('TEMPLATE');this.eat('LT');const parameters=[];if(this.currentToken.type!=='GT'){parameters.push(this.parseTemplateParameter());while(this.currentToken.type==='COMMA'){this.eat('COMMA');parameters.push(this.parseTemplateParameter())}}
this.eatTemplateClose();const declaration=this.parseTopLevelStatement();return{type:'TemplateDeclaration',parameters:parameters,declaration:declaration}}
parseTemplateParameter(){if(this.currentToken.type==='TYPENAME'||this.currentToken.type==='CLASS'){const kind=this.currentToken.value;this.eat(this.currentToken.type);let name=null;if(this.currentToken.type==='IDENTIFIER'){name=this.currentToken.value;this.eat('IDENTIFIER')}
return{type:'TemplateTypeParameter',kind:kind,name:name}}else{const paramType=this.currentToken.value;this.eat(this.currentToken.type);const name=this.currentToken.value;this.eat('IDENTIFIER');return{type:'TemplateValueParameter',paramType:paramType,name:name}}}
parseTopLevelStatement(){const currentType=this.currentToken.type;const peekType=this.peekToken.type;const peek2Type=this.peekToken2.type;const isType=isValidType(currentType,'any')||isTypeModifier(currentType)||isStorageClass(currentType);if(currentType==='STRUCT'&&peekType==='IDENTIFIER'&&peek2Type==='LBRACE'){return this.parseStructDeclaration()}
if(currentType==='STRUCT'&&peekType==='IDENTIFIER'){return this.parseVariableDeclaration()}
if(currentType==='ENUM'&&peekType==='IDENTIFIER'&&peek2Type==='LBRACE'){return this.parseEnumDeclaration()}
if(currentType==='ENUM'&&peekType==='LBRACE'){if(this.isAnonymousEnumWithVariable()){return this.parseAnonymousEnumWithVariable()}else{return this.parseEnumDeclaration()}}
if(currentType==='ENUM'&&peekType==='IDENTIFIER'&&peek2Type==='IDENTIFIER'){return this.parseVariableDeclaration()}
if(currentType==='UNION'&&peekType==='IDENTIFIER'&&peek2Type==='LBRACE'){return this.parseUnionDeclaration()}
if(currentType==='UNION'&&peekType==='LBRACE'){return this.parseUnionDeclaration()}
if(currentType==='TYPEDEF'){return this.parseTypedefDeclaration()}
if(currentType==='CLASS'){return this.parseClassDeclaration()}
if(currentType==='TEMPLATE'){return this.parseTemplateDeclaration()}
if(currentType==='TEMPLATE'){return this.parseTemplateDeclaration()}
if(currentType==='DECLTYPE'||currentType==='CONSTEXPR'){return this.parseVariableDeclaration()}
if(isType&&peekType==='LPAREN'&&peek2Type==='MUL'){return this.parseVariableDeclaration()}
if(isType&&peekType==='MUL'){if(this.peekToken2&&this.peekToken2.type==='IDENTIFIER'){const savedPosition=this.position;const savedChar=this.currentChar;const savedLine=this.line;const savedColumn=this.column;const savedCurrent=this.currentToken;const savedPeek=this.peekToken;const savedPeek2=this.peekToken2;try{this.advanceToken();this.advanceToken();this.advanceToken();const isFunction=this.currentToken.type==='LPAREN';this.position=savedPosition;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.currentToken=savedCurrent;this.peekToken=savedPeek;this.peekToken2=savedPeek2;if(isFunction){if(this.isFunctionDeclaration()){return this.parseFunctionDeclaration()}else{return this.parseFunctionDefinition()}}}catch(e){this.position=savedPosition;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.currentToken=savedCurrent;this.peekToken=savedPeek;this.peekToken2=savedPeek2}}
return this.parseVariableDeclaration()}
if(isType&&peekType==='IDENTIFIER'&&peek2Type==='SCOPE'){const savedPosition=this.position;const savedChar=this.currentChar;const savedLine=this.line;const savedColumn=this.column;const savedCurrent=this.currentToken;const savedPeek=this.peekToken;const savedPeek2=this.peekToken2;try{this.advanceToken();this.advanceToken();this.advanceToken();let isDestructor=!1;if(this.currentToken.type==='BITWISE_NOT'){isDestructor=!0;this.advanceToken()}
if(this.currentToken.type==='IDENTIFIER'){this.advanceToken();if(this.currentToken.type==='LPAREN'){this.position=savedPosition;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.currentToken=savedCurrent;this.peekToken=savedPeek;this.peekToken2=savedPeek2;return this.parseScopedMethodDefinition()}}}catch(e){}
this.position=savedPosition;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.currentToken=savedCurrent;this.peekToken=savedPeek;this.peekToken2=savedPeek2}
if(isType&&peekType==='IDENTIFIER'){if(peek2Type==='LPAREN'){if(this.isConstructorCall()){return this.parseVariableDeclaration()}else if(this.isFunctionDeclaration()){return this.parseFunctionDeclaration()}else{return this.parseFunctionDefinition()}}else if(isStorageClass(currentType)&&peek2Type==='IDENTIFIER'){const savedPosition=this.position;const savedChar=this.currentChar;const savedLine=this.line;const savedColumn=this.column;const savedCurrent=this.currentToken;const savedPeek=this.peekToken;const savedPeek2=this.peekToken2;try{this.advanceToken();this.advanceToken();this.advanceToken();if(this.currentToken.type==='LPAREN'){this.position=savedPosition;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.currentToken=savedCurrent;this.peekToken=savedPeek;this.peekToken2=savedPeek2;return this.parseFunctionDefinition()}}catch(e){}
this.position=savedPosition;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.currentToken=savedCurrent;this.peekToken=savedPeek;this.peekToken2=savedPeek2;return this.parseVariableDeclaration()}else{return this.parseVariableDeclaration()}}else if(isType&&peekType==='LT'){return this.parseVariableDeclaration()}else if(currentType==='IDENTIFIER'&&peekType==='SCOPE'&&peek2Type==='IDENTIFIER'&&this.isNamespaceQualifiedVariableDeclaration()){return this.parseVariableDeclaration()}else if(currentType==='UNSIGNED'&&['INT','LONG','FLOAT','CHAR','SHORT'].includes(peekType)){if(peek2Type==='IDENTIFIER'){return this.parseVariableDeclaration()}
if(peekType==='LONG'&&peek2Type==='INT'){const savedPosition=this.position;const savedChar=this.currentChar;const savedLine=this.line;const savedColumn=this.column;const savedCurrent=this.currentToken;const savedPeek=this.peekToken;const savedPeek2=this.peekToken2;try{this.advanceToken();this.advanceToken();this.advanceToken();const isIdentifier=this.currentToken.type==='IDENTIFIER';this.position=savedPosition;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.currentToken=savedCurrent;this.peekToken=savedPeek;this.peekToken2=savedPeek2;if(isIdentifier){return this.parseVariableDeclaration()}}catch(e){this.position=savedPosition;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.currentToken=savedCurrent;this.peekToken=savedPeek;this.peekToken2=savedPeek2}}}else if(currentType==='LONG'&&['INT','DOUBLE'].includes(peekType)){if(peek2Type==='IDENTIFIER'){return this.parseVariableDeclaration()}}else if(isValidType(currentType,'declaration')&&peekType==='CONST'&&peek2Type==='IDENTIFIER'){return this.parseVariableDeclaration()}else if(currentType==='CONST'){const savedPosition=this.position;const savedChar=this.currentChar;const savedLine=this.line;const savedColumn=this.column;const savedCurrent=this.currentToken;const savedPeek=this.peekToken;const savedPeek2=this.peekToken2;try{this.advanceToken();if(isValidType(this.currentToken.type,'declaration')){this.advanceToken();if(this.currentToken.type==='LONG'||this.currentToken.type==='INT'||this.currentToken.type==='SHORT'){this.advanceToken()}}
while(this.currentToken.type==='MUL'){this.advanceToken()}
if(this.currentToken.type==='IDENTIFIER'){this.advanceToken();if(this.currentToken.type==='LPAREN'){this.position=savedPosition;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.currentToken=savedCurrent;this.peekToken=savedPeek;this.peekToken2=savedPeek2;return this.parseFunctionDefinition()}}}catch(e){}
this.position=savedPosition;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.currentToken=savedCurrent;this.peekToken=savedPeek;this.peekToken2=savedPeek2;return this.parseVariableDeclaration()}else if(currentType==='EXTERN'&&(isValidType(peekType,'declaration')||isTypeModifier(peekType))){return this.parseVariableDeclaration()}else if(currentType==='STATIC'){return this.parseVariableDeclaration()}else if(currentType==='VOLATILE'){return this.parseVariableDeclaration()}else if(currentType==='SIGNED'){return this.parseVariableDeclaration()}else if(currentType==='PROGMEM'&&(isValidType(peekType,'declaration')||isTypeModifier(peekType))){return this.parseVariableDeclaration()}else if(['VIRTUAL','INLINE','EXPLICIT','CONSTEXPR'].includes(currentType)){return this.parseFunctionDefinition()}else if(currentType==='AUTO'){return this.parseVariableDeclaration()}else if(['PUBLIC','PRIVATE','PROTECTED'].includes(currentType)){this.advanceToken();if(this.currentToken.type==='COLON'){this.advanceToken()}
return{type:'CommentNode',value:`Skipped ${currentType.toLowerCase()} access specifier`}}else if(['RBRACE','SEMICOLON','RETURN'].includes(currentType)){this.advanceToken();return{type:'CommentNode',value:`Skipped stray ${currentType.toLowerCase()}`}}else if(currentType==='PreprocessorDirective'){throw new Error(`Unexpected preprocessor directive: ${this.currentToken.value}. All preprocessor directives should be handled before parsing.`)}else if(currentType==='IDENTIFIER'&&peekType==='SCOPE'&&(peek2Type==='IDENTIFIER'||peek2Type==='BITWISE_NOT')){const savedPosition=this.position;const savedChar=this.currentChar;const savedLine=this.line;const savedColumn=this.column;const savedCurrent=this.currentToken;const savedPeek=this.peekToken;const savedPeek2=this.peekToken2;try{this.advanceToken();this.advanceToken();const isDestructor=this.currentToken.type==='BITWISE_NOT';if(isDestructor){this.advanceToken();if(this.currentToken.type!=='IDENTIFIER'){throw new Error('Expected destructor name after ~')}}
this.advanceToken();if(this.currentToken.type==='LPAREN'){this.position=savedPosition;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.currentToken=savedCurrent;this.peekToken=savedPeek;this.peekToken2=savedPeek2;return this.parseScopedFunctionDefinition()}else{this.position=savedPosition;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.currentToken=savedCurrent;this.peekToken=savedPeek;this.peekToken2=savedPeek2;const expressionNode=this.parseExpression();this.eat('SEMICOLON');return{type:'ExpressionStatement',expression:expressionNode}}}catch(e){this.position=savedPosition;this.currentChar=savedChar;this.line=savedLine;this.column=savedColumn;this.currentToken=savedCurrent;this.peekToken=savedPeek;this.peekToken2=savedPeek2;const expressionNode=this.parseExpression();this.eat('SEMICOLON');return{type:'ExpressionStatement',expression:expressionNode}}}else if(['WHILE','FOR','IF','DO'].includes(currentType)){return this.parseStatement()}else if(currentType==='IDENTIFIER'){const expressionNode=this.parseExpression();this.eat('SEMICOLON');return{type:'ExpressionStatement',expression:expressionNode}}else if(currentType==='MUL'){const expressionNode=this.parseExpression();this.eat('SEMICOLON');return{type:'ExpressionStatement',expression:expressionNode}}else if(['MINUS_MINUS','PLUS_PLUS','NOT','BITWISE_NOT'].includes(currentType)){const expressionNode=this.parseExpression();this.eat('SEMICOLON');return{type:'ExpressionStatement',expression:expressionNode}}else{throw new Error(`Parser Error on line ${this.currentToken.line}: Unexpected token ${currentType} at top level`)}}}
function parse(code,options={}){const{verbose=!1,throwOnError=!1,includePreprocessor=!1,recognizeArduinoFunctions=!1,webFriendlyMode=!1,enablePreprocessor=!0,platformContext=null}=options;try{let processedCode=code;let preprocessorResult=null;const ArduinoPreprocessorClass=getArduinoPreprocessor();if(enablePreprocessor&&ArduinoPreprocessorClass){try{const preprocessor=new ArduinoPreprocessorClass({verbose:verbose,debug:!1,platformContext:platformContext});preprocessorResult=preprocessor.preprocess(code);processedCode=preprocessorResult.processedCode;if(verbose){console.log(' Arduino Preprocessing completed:');console.log(`    Macros defined: ${Object.keys(preprocessorResult.macros || {}).length}`);console.log(`    Active libraries: ${preprocessorResult.activeLibraries?.length || 0}`);console.log(`    Library constants: ${Object.keys(preprocessorResult.libraryConstants || {}).length}`);if(preprocessorResult.activeLibraries?.length>0){console.log(`    Libraries: ${preprocessorResult.activeLibraries.join(', ')}`)}}}catch(preprocessorError){if(verbose){console.warn('  Preprocessor error, using original code:',preprocessorError.message)}
processedCode=code}}
const parserOptions={...options,includePreprocessor:!1};const parser=new Parser(processedCode,parserOptions);const ast=parser.parse();if(preprocessorResult){ast.preprocessorInfo={activeLibraries:preprocessorResult.activeLibraries||[],macros:preprocessorResult.macros||{},functionMacros:preprocessorResult.functionMacros||{},libraryConstants:preprocessorResult.libraryConstants||{}}}
const errors=[];function collectErrors(node){if(node&&typeof node==='object'){if(node.type==='ErrorNode'){errors.push(node.value)}
for(const key in node){if(Array.isArray(node[key])){node[key].forEach(collectErrors)}else if(typeof node[key]==='object'){collectErrors(node[key])}}}}
collectErrors(ast);if(verbose||errors.length>0){const totalNodes=countNodes(ast);const successRate=errors.length===0?100:Math.max(0,((totalNodes-errors.length)/totalNodes*100));console.log(`\n Parser Analysis (v${PARSER_VERSION}):`);console.log(`    Success Rate: ${successRate.toFixed(1)}%`);console.log(`    Successful Nodes: ${totalNodes - errors.length}`);console.log(`    Error Nodes: ${errors.length}`);if(errors.length>0){console.log(`\n Parsing Issues Found:`);errors.forEach((error,i)=>{console.log(`   ${i + 1}. ${error}`)});console.log(`\n Suggestions:`);if(errors.some(e=>e.includes('Unexpected token'))){console.log(`    Check for missing semicolons or braces`)}
if(errors.some(e=>e.includes('Expected token'))){console.log(`    Verify syntax matches C++ standards`)}
if(errors.some(e=>e.includes('function')||e.includes('LBRACE'))){console.log(`    Check function declarations vs definitions`)}
console.log(`    Consider updating to latest parser version`)}}
return ast}catch(e){const errorMsg=createDetailedErrorMessage(e,code);if(verbose){console.error(`\n Critical Parser Error (v${PARSER_VERSION}):`);console.error(`   ${errorMsg}`);console.error(`\n Recovery Suggestions:`);console.error(`    Check for syntax errors near the reported line`);console.error(`    Ensure all braces and parentheses are balanced`);console.error(`    Verify that all statements end with semicolons`);console.error(`    Consider breaking complex expressions into simpler parts`)}
if(throwOnError){throw new Error(errorMsg)}
return{type:'ProgramNode',children:[{type:'ErrorNode',value:errorMsg,severity:'critical',suggestions:['Check syntax near the error location','Ensure balanced braces and parentheses','Verify semicolon placement']}]}}}
function createDetailedErrorMessage(error,code){const lines=code.split('\n');const lineMatch=error.message.match(/line (\d+)/);if(lineMatch){const lineNum=parseInt(lineMatch[1]);const contextStart=Math.max(0,lineNum-3);const contextEnd=Math.min(lines.length,lineNum+2);let context='\n Code Context:\n';for(let i=contextStart;i<contextEnd;i++){const marker=i===lineNum-1?'>>> ':'    ';const lineNumStr=(i+1).toString().padStart(3,' ');context+=`${marker}${lineNumStr}: ${lines[i] || '(empty)'}\n`}
return error.message+context}
return error.message}
function countNodes(node){if(!node||typeof node!=='object')return 0;let count=1;for(const key in node){if(Array.isArray(node[key])){count+=node[key].reduce((sum,item)=>sum+countNodes(item),0)}else if(typeof node[key]==='object'){count+=countNodes(node[key])}}
return count}
function prettyPrintAST(node,indent=''){if(!node)return'';let output=indent+` ${node.type}`;if(node.value!==undefined&&typeof node.value!=='object'){output+=` (${JSON.stringify(node.value)})`}
if(node.op){output+=` (${JSON.stringify(node.op.value)})`}
if(node.operator){output+=` (${JSON.stringify(node.operator)})`}
output+='\n';const newIndent=indent+'    ';if(node.children){for(let i=0;i<node.children.length;i++){output+=prettyPrintAST(node.children[i],newIndent)}}
const namedChildren={'VarDeclNode':['varType','declarations'],'FuncDefNode':['returnType','declarator','parameters','body'],'FuncCallNode':['callee','arguments'],'FunctionStyleCastNode':['argument'],'IfStatement':['condition','consequent','alternate'],'WhileStatement':['condition','body'],'DoWhileStatement':['body','condition'],'ForStatement':['initializer','condition','increment','body'],'RangeBasedForStatement':['declaration','range','body'],'SwitchStatement':['discriminant','cases'],'CaseStatement':['test','consequent'],'RangeExpression':['start','end'],'BinaryOpNode':['left','right'],'AssignmentNode':['left','right'],'ExpressionStatement':['expression'],'MemberAccessNode':['object','property'],'NamespaceAccessNode':['namespace','member'],'UnaryOpNode':['operand'],'ParamNode':['paramType','declarator','defaultValue'],'ArrayDeclaratorNode':['identifier','dimensions'],'FunctionPointerDeclaratorNode':['identifier','parameters'],'PointerDeclaratorNode':['identifier'],'ArrayAccessNode':['identifier','index'],'ConstructorCallNode':['callee','arguments'],'ArrayInitializerNode':['elements'],'DesignatedInitializerNode':['field','value'],'PostfixExpressionNode':['operand','op'],'ReturnStatement':['value'],'CastExpression':['castType','operand'],'NewExpression':['allocationType','size','arguments'],'TernaryExpression':['condition','consequent','alternate'],'StructDeclaration':['name','members'],'StructMember':['memberType','declarator','bitField'],'MultipleStructMembers':['memberType','declarations'],'EnumDeclaration':['name','members'],'EnumMember':['name','value'],'AnonymousEnumWithVariable':['members','variable'],'UnionDeclaration':['name','members','variables'],'SizeofExpression':['operand'],'TypeNode':['templateArgs'],'ContinueStatement':[],'ConstructorDefinition':['className','constructorName','parameters','initializerList','body'],'MemberInitializer':['member','value']};if(namedChildren[node.type]){namedChildren[node.type].forEach(key=>{const child=node[key];if(child){if(Array.isArray(child)){if(child.length>0){output+=newIndent+` ${key}:\n`;child.forEach((item)=>{if(typeof item==='object'&&item&&item.declarator&&key==='declarations'){const declName=item.declarator.value||item.declarator.identifier?.value||'unnamed';output+=newIndent+'   '+` declarator: ${declName}\n`;if(item.initializer){output+=newIndent+'   '+` initializer:\n`;output+=prettyPrintAST(item.initializer,newIndent+'   '+'   ')}}else{output+=prettyPrintAST(item,newIndent+'   ')}})}}else if(typeof child==='object'){if(key==='body'&&child.children&&child.children.length===0){output+=newIndent+` ${key}: {}\n`}else{output+=newIndent+` ${key}:\n`;output+=prettyPrintAST(child,newIndent+'   ')}}else{output+=newIndent+` ${key}: ${child}\n`}}})}
return output}(function(globalContext){globalContext.parse=parse;globalContext.prettyPrintAST=prettyPrintAST;globalContext.Parser=Parser;globalContext.PARSER_VERSION=PARSER_VERSION})(typeof window!=='undefined'?window:(typeof global!=='undefined'?global:this));if(typeof module!=='undefined'&&module.exports){module.exports={Parser,parse,prettyPrintAST}}