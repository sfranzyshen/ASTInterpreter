<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interpreter Test Harness (Self-Contained)</title>
    <style>
        body { font-family: monospace; background-color: #1a1a2e; color: #e0e0e0; padding: 1rem; }
        h1 { color: #00f0ff; }
        #log { white-space: pre-wrap; border: 1px solid #00f0ff; padding: 1rem; background-color: #1f2937; border-radius: 0.5rem; }
        .success { color: #33ff33; }
        .failure { color: #ff3333; }
    </style>
</head>
<body>

    <h1>Interpreter Test Harness Log</h1>
    <pre id="log">Starting tests...</pre>

    <script src="interpreter.js"></script>
    
    <script>
        const logElement = document.getElementById('log');
        let fullLog = '';

        // --- All Test Cases Embedded Here ---
        const testFiles = [
            // --- Original 54 Tests ---
            { name: "test1.ino", content: `// Test Case for Array Access\nint myPins[] = {2, 4, 8};\n\nvoid setup() {\n  pinMode(myPins[1], OUTPUT);\n}\n\nvoid loop() {\n  // empty\n}` },
            { name: "test2.ino", content: `// To test the Lexer and Parser\nvoid setup() {\n  /*\n    This is the setup function.\n    It runs once at the beginning.\n  */\n  Serial.begin(9600); // Initialize serial communication\n}\n\nvoid loop() {\n  // Turn the LED on\n  digitalWrite(13, HIGH);\n  delay(1000); // Wait for a second\n\n  // Turn the LED off\n  digitalWrite(13, LOW);\n  delay(1000); // Wait for another second\n}` },
            { name: "test3.ino", content: `#include <Arduino.h>\n\n// Global variable declarations\nconst int ledPin = 13;\nint counter = 0;\nfloat dutyCycle = 127.5; // Test floating point\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  for (int i = 0; i < 2; i++) {\n    digitalWrite(ledPin, HIGH);\n    delay(50);\n    digitalWrite(ledPin, LOW);\n    delay(50);\n  }\n\n  if (counter >= 5 && counter < 10) {\n    // This block should not execute on the first few loops\n  }\n\n  counter += 1; // Test compound assignment\n  delay(500);\n}` },
            { name: "test4.ino", content: `// Test Case for Operator Precedence\nvoid setup() {\n  int a = 5;\n  int b = 10;\n  int c = 2;\n\n  if (a + b / c == 10 && b > 9) {\n    // Parser should correctly evaluate (b / c) first, then (a + ...),\n    // then (== 10), then (> 9), and finally the &&.\n  }\n}\n\nvoid loop() {\n  // empty\n}` },
            { name: "test5.ino", content: `// Test Case for Parentheses Precedence\nvoid setup() {\n  int a = 5;\n  int b = 10;\n  int c = 2;\n\n  int result = (a + b) * c; // Should evaluate (a + b) first.\n}\n\nvoid loop() {\n  // empty\n}` },
            { name: "test6.ino", content: `// Test Case for Unary vs. Binary Operators\nvoid setup() {\n  int x = 10;\n  int y = -x;      // Unary minus\n  int z = 10 - 5;  // Binary minus\n}\n\nvoid loop() {\n  // empty\n}` },
            { name: "test7.ino", content: `// Test Case for C++-Style Initialization\nvoid setup() {\n  int x(10);\n}\n\nvoid loop() {\n  // empty\n}` },
            { name: "test8.ino", content: `// Test Rigorous Brackets & Parentheses\nint myPins[] = {2, 4, 8};\n\nint getIndex() {\n  return 1;\n}\n\nvoid setup() {\n  int x = myPins[0];\n  int y = myPins[getIndex()];\n  pinMode(myPins[2], OUTPUT);\n  int z = (myPins[0] + getIndex()) * myPins[2];\n}\n\nvoid loop() {\n  // empty\n}` },
            { name: "test9.ino", content: `// Test Case for the return statement\nint getValue() {\n  return 42;\n}\n\nvoid doSomething() {\n  return;\n}\n\nvoid setup() {}\nvoid loop() {}` },
            { name: "test10.ino", content: `// Test Case for Advanced Numeric Literals\nint hexValue = 0x1A;\nint octValue = 032;\nfloat sciValue = 2.6e1;\n\nvoid setup() {}\nvoid loop() {}` },
            { name: "test11.ino", content: `// Test Case for Character Literals\nchar myChar = 'C';\n\nvoid setup() {}\nvoid loop() {}` },
            { name: "test12.ino", content: `// Test Case for the \"Dangling Else\"\nvoid setup() {\n  int x = 5;\n  int y = 10;\n  if (x > 0)\n    if (y > 20)\n      pinMode(1, HIGH);\n    else\n      pinMode(1, LOW);\n}\n\nvoid loop() {}` },
            { name: "test13.ino", content: `// Test Case for Pointer vs. Multiplication\nvoid setup() {\n  int x = 5 * 10;\n  int* p = &x;\n}\n\nvoid loop() {}` },
            { name: "test14.ino", content: `// Test Case for Function Pointer Declarations\nvoid myInterruptService() {}\n\nvoid setup() {\n  void (*myFunction)() = &myInterruptService;\n}\n\nvoid loop() {}` },
            { name: "test15.ino", content: `// Nested Loops and Variable Scope\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int i = 0;\n  while (i < 3) {\n    for (int j = 0; j < 3; j++) {\n      int k = 0;\n      do {\n        Serial.print("i: ");\n        Serial.print(i);\n        Serial.print(", j: ");\n        Serial.print(j);\n        Serial.print(", k: ");\n        Serial.println(k);\n        k++;\n      } while (k < 2);\n    }\n    i++;\n  }\n}` },
            { name: "test16.ino", content: `// Complex Conditional Logic\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int x = 5;\n  int y = 10;\n  int z = 15;\n\n  if ((x < y && y != z) || (x == 5 && z > 10)) {\n    if (z / x > 2 && y % 2 == 0) {\n      Serial.println("Condition 1 met.");\n    } else {\n      Serial.println("Condition 2 met.");\n    }\n  } else if (x > y || y == 10) {\n    Serial.println("Condition 3 met.");\n  } else {\n    Serial.println("No conditions met.");\n  }\n}` },
            { name: "test17.ino", content: `// Operator Precedence and Associativity\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int a = 20;\n  int b = 5;\n  int c = 2;\n  int d = 3;\n\n  int result1 = a + b * c - d;\n  int result2 = (a + b) * c - d;\n  int result3 = a / (b - d) + c;\n\n  Serial.print("Result 1: "); Serial.println(result1);\n  Serial.print("Result 2: "); Serial.println(result2);\n  Serial.print("Result 3: "); Serial.println(result3);\n}` },
            { name: "test18.ino", content: `// Function Calls and Parameter Passing\nint add(int x, int y) {\n  return x + y;\n}\n\nint multiply(int x, int y) {\n  return x * y;\n}\n\nint calculate(int x, int y, int z) {\n  return multiply(add(x, y), z);\n}\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int a = 5;\n  int b = 10;\n  int c = 2;\n\n  int finalResult = calculate(a, b, c);\n\n  Serial.print("Final result: ");\n  Serial.println(finalResult);\n}` },
            { name: "test19.ino", content: `// Loop Control Statements (break, continue)\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  for (int i = 0; i < 5; i++) {\n    for (int j = 0; j < 5; j++) {\n      if (j == 2) {\n        Serial.println("Continuing inner loop...");\n        continue;\n      }\n      if (i == 3) {\n        Serial.println("Breaking outer loop...");\n        break;\n      }\n      Serial.print("i: ");\n      Serial.print(i);\n      Serial.print(", j: ");\n      Serial.print(j);\n      Serial.println(j);\n    }\n  }\n}` },
            { name: "test20.ino", content: `// Ternary Operator and Bitwise Operators\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int a = 10;\n  int b = 20;\n\n  int maxVal = (a > b) ? a : b;\n  Serial.print("Max value: "); Serial.println(maxVal);\n\n  int c = 0b1010;\n  int d = 0b0110;\n  int andResult = c & d;\n  int orResult = c | d;\n  int xorResult = c ^ d;\n  int shiftResult = c << 1;\n\n  Serial.print("AND result: "); Serial.println(andResult);\n  Serial.print("OR result: "); Serial.println(orResult);\n  Serial.print("XOR result: "); Serial.println(xorResult);\n  Serial.print("Shift result: "); Serial.println(shiftResult);\n}` },
            { name: "test21.ino", content: `// Floating-Point Arithmetic and Mixed Types\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float f1 = 3.14;\n  float f2 = 2.0;\n  int i1 = 5;\n\n  float result1 = f1 * f2;\n  float result2 = (f1 + i1) / f2;\n\n  if (result2 > 4.0 && i1 < 10) {\n    Serial.println("Calculation is correct.");\n  } else {\n    Serial.println("Calculation is incorrect.");\n  }\n\n  Serial.print("Result 1: "); Serial.println(result1, 4);\n  Serial.print("Result 2: "); Serial.println(result2, 4);\n}` },
            { name: "test22.ino", content: `// String and Character Literals\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  char myChar = 'A';\n  char escapedChar = '\\n';\n  const char* str1 = "Hello";\n  const char* str2 = " world!";\n\n  Serial.print(str1);\n  Serial.println(str2);\n  Serial.print("My character is: ");\n  Serial.println(myChar);\n\n  Serial.print(myChar);\n  Serial.print(escapedChar);\n}` },
            { name: "test23.ino", content: `// Multiple Statements on a Single Line\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int x = 10; int y = 20; if (x < y) { Serial.println("X is less than Y."); }\n  int i = 0; while (i < 3) { Serial.println(i); i++; }\n  for (int j = 0; j < 2; j++) { Serial.print("J is: "); Serial.println(j); }\n}` },
            { name: "test24.ino", content: `// Mixed-Type Expressions and Casting\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int a = 10;\n  float b = 3.0;\n\n  float result1 = (float)(a / 3);\n  float result2 = a / b;\n  float result3 = (float)a * b + 5.5;\n\n  Serial.print("Result 1 (int div, cast): "); Serial.println(result1, 4);\n  Serial.print("Result 2 (float div): "); Serial.println(result2, 4);\n  Serial.print("Result 3 (mixed): "); Serial.println(result3, 4);\n}` },
            { name: "test25.ino", content: `// switch statement with fall-through and nested blocks\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int x = 2;\n  switch (x) {\n    case 1:\n      Serial.println("Case 1");\n    case 2: {\n      int y = 5;\n      Serial.println("Case 2");\n      Serial.print("y is: ");\n      Serial.println(y);\n    }\n    case 3:\n      Serial.println("Case 3");\n      break;\n    default:\n      Serial.println("Default case");\n      break;\n  }\n}` },
            { name: "test26.ino", content: `// Complex Preprocessor Directives\n#define PI 3.14159\n#define CIRCLE_AREA(r) (PI * r * r)\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  #ifdef PI\n    float radius = 5.0;\n    float area = CIRCLE_AREA(radius);\n    Serial.print("Area of circle: ");\n    Serial.println(area);\n  #else\n    Serial.println("PI is not defined.");\n  #endif\n}` },
            { name: "test27.ino", content: `// Array Indexing and Multidimensional Arrays\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int arr[5] = {10, 20, 30, 40, 50};\n  int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};\n  int i = 2;\n  int j = 1;\n  int k = 1;\n\n  int val1 = arr[i * 2 - 1];\n  int val2 = matrix[j][k];\n\n  Serial.print("Val 1: ");\n  Serial.println(val1);\n  Serial.print("Val 2: ");\n  Serial.println(val2);\n}` },
            { name: "test28.ino", content: `// Function Pointers and Callbacks\nint myFunc(int a, int b) {\n  return a + b;\n}\n\nvoid callFunc(int (*funcPtr)(int, int)) {\n  Serial.print("Result: ");\n  Serial.println(funcPtr(10, 20));\n}\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int (*ptr)(int, int);\n  ptr = &myFunc;\n  callFunc(ptr);\n}` },
            { name: "test29.ino", content: `// Chained Assignments and Unary Operators\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int a, b, c;\n  a = b = c = 5;\n  int x = 10;\n  int y = ++x;\n  int z = y++;\n  Serial.print("a: "); Serial.println(a);\n  Serial.print("x: "); Serial.println(x);\n  Serial.print("y: "); Serial.println(y);\n  Serial.print("z: "); Serial.println(z);\n  int result = --x * (y++);\n  Serial.print("Final result: "); Serial.println(result);\n}` },
            { name: "test30.ino", content: `// Complex for loop with multiple expressions\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int i = 0;\n  int j = 10;\n\n  for (i = 0, j = 10; i < j; i++, j--) {\n    Serial.print("i: ");\n    Serial.print(i);\n    Serial.print(", j: ");\n    Serial.print(j);\n    Serial.println(j);\n  }\n}` },
            { name: "test31.ino", content: `// do-while loop with a complex condition\nbool checkCondition(int val) {\n  return val % 2 == 0;\n}\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int count = 0;\n  int val = 10;\n\n  do {\n    count++;\n    val--;\n    Serial.print("Count: ");\n    Serial.println(count);\n  } while (count < 5 && checkCondition(val) == false);\n}` },
            { name: "test32.ino", content: `// Structs and Member Access\nstruct Point {\n  int x;\n  int y;\n};\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  struct Point p1;\n  p1.x = 10;\n  p1.y = 20;\n\n  Serial.print("Point x: ");\n  Serial.println(p1.x);\n  Serial.print("Point y: ");\n  Serial.println(p1.y);\n}` },
            { name: "test33.ino", content: `// Unary Plus and Minus with Operator Precedence\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int a = 5;\n  int b = -10;\n\n  int result1 = a + -b;\n  int result2 = -a * b;\n  int result3 = 10 - +a;\n\n  Serial.print("Result 1: "); Serial.println(result1);\n  Serial.print("Result 2: "); Serial.println(result2);\n  Serial.print("Result 3: "); Serial.println(result3);\n}` },
            { name: "test34.ino", content: `// Empty and NULL statements\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int i = 0;\n  while (i < 5) {\n    i++;\n  } ;\n\n  for (int j = 0; j < 5; j++);\n\n  if (1 == 1) {}\n\n  Serial.println("Execution finished.");\n}` },
            { name: "test35.ino", content: `// Pointers and Pointer Arithmetic\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int arr[3] = {10, 20, 30};\n  int *ptr = arr;\n\n  Serial.print("First element: ");\n  Serial.println(*ptr);\n\n  ptr++;\n  Serial.print("Next element: ");\n  Serial.println(*ptr);\n\n  int nextVal = *(ptr + 1);\n  Serial.print("Next value with arithmetic: ");\n  Serial.println(nextVal);\n}` },
            { name: "test36.ino", content: `// Initializer Lists and Designated Initializers\nstruct Point {\n  int x;\n  int y;\n};\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int numbers[] = {1, 2, 3};\n  struct Point p = {.x = 10, .y = 20};\n\n  Serial.print("Numbers[1]: ");\n  Serial.println(numbers[1]);\n\n  Serial.print("Point x: ");\n  Serial.println(p.x);\n\n  Serial.print("Point y: ");\n  Serial.println(p.y);\n}` },
            { name: "test37.ino", content: `// Type Promotion and Implicit Conversions\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  char c = 'A';\n  int i = 5;\n  float f = 2.5;\n\n  int result1 = c + i;\n  float result2 = i * f;\n\n  Serial.print("Result 1: ");\n  Serial.println(result1);\n\n  Serial.print("Result 2: ");\n  Serial.println(result2);\n}` },
            { name: "test38.ino", content: `// typedef and Structs with Pointers\ntypedef struct {\n  int x;\n  int y;\n} MyPoint;\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  MyPoint p1;\n  MyPoint *p2;\n\n  p1.x = 10;\n  p1.y = 20;\n\n  p2 = &p1;\n\n  Serial.print("Value of x using pointer: ");\n  Serial.println(p2->x);\n\n  p2->y = 30;\n  Serial.print("Modified value of y: ");\n  Serial.println(p1.y);\n}` },
            { name: "test39.ino", content: `// static Variables and Scope\nvoid counter() {\n  static int count = 0;\n  count++;\n  Serial.print("Count is: ");\n  Serial.println(count);\n}\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  counter();\n  delay(1000);\n}` },
            { name: "test40.ino", content: `// const and volatile Qualifiers\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  const int myConst = 100;\n  volatile int myVolatile = 50;\n\n  Serial.print("My constant: ");\n  Serial.println(myConst);\n\n  Serial.print("My volatile: ");\n  Serial.println(myVolatile);\n}` },
            { name: "test41.ino", content: `// Logical Operators with Short-Circuiting\nint myFunc() {\n  Serial.println("myFunc() was called.");\n  return 1;\n}\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int x = 0;\n  int y = 5;\n\n  if (x == 0 || myFunc()) {\n    Serial.println("Condition 1 is true.");\n  }\n\n  if (x == 1 && myFunc()) {\n    Serial.println("Condition 2 is true.");\n  }\n}` },
            { name: "test42.ino", content: `// Conditional Operator in a Loop\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int x = 0;\n  for (int i = 0; i < 5; i++) {\n    x = (i == 0) ? 1 : ((i % 2 == 0) ? i + 10 : i * 10);\n    Serial.print("For i=");\n    Serial.print(i);\n    Serial.print(", x is: ");\n    Serial.println(x);\n  }\n}` },
            { name: "test43.ino", content: `// Variable Declarations in a for Loop\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  for (int i = 0; i < 3; i++) {\n    Serial.print("i: ");\n    Serial.println(i);\n  }\n}` },
            { name: "test44.ino", content: `// Unary sizeof Operator\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int a = 10;\n  char b = 'B';\n  float c = 3.14;\n\n  Serial.print("Size of int: ");\n  Serial.println(sizeof(a));\n\n  Serial.print("Size of char: ");\n  Serial.println(sizeof(char));\n\n  Serial.print("Size of float: ");\n  Serial.println(sizeof(c));\n}` },
            { name: "test45.ino", content: `// Comma Operator in a for Loop\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int a = 0, b = 10;\n  for (int i = 0; i < 3; i++) {\n    Serial.print("Initial a: ");\n    Serial.println(a);\n    a = (a++, b++);\n    Serial.print("Final a: ");\n    Serial.println(a);\n  }\n}` },
            { name: "test46.ino", content: `// Nested for and if with break and continue\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  for (int i = 0; i < 5; i++) {\n    for (int j = 0; j < 5; j++) {\n      if (i == 2 && j == 2) {\n        Serial.println("Skipping inner loop...");\n        continue;\n      }\n      if (i == 3) {\n        Serial.println("Breaking outer loop...");\n        break;\n      }\n      Serial.print("i: ");\n      Serial.print(i);\n      Serial.print(", j: ");\n      Serial.print(j);\n      Serial.println(j);\n    }\n    if (i == 3) {\n      break;\n    }\n  }\n}` },
            { name: "test47.ino", content: `// Pointer to Pointer\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int x = 100;\n  int *p1 = &x;\n  int **p2 = &p1;\n\n  Serial.print("Value of x: ");\n  Serial.println(x);\n\n  Serial.print("Value of *p1: ");\n  Serial.println(*p1);\n\n  Serial.print("Value of **p2: ");\n  Serial.println(**p2);\n\n  **p2 = 200;\n  Serial.print("New value of x: ");\n  Serial.println(x);\n}` },
            { name: "test48.ino", content: `// Self-Referential Structs (Linked List Node)\nstruct Node {\n  int data;\n  struct Node* next;\n};\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  struct Node n1, n2;\n  n1.data = 10;\n  n1.next = &n2;\n\n  n2.data = 20;\n  n2.next = NULL;\n\n  Serial.print("Data from n1: ");\n  Serial.println(n1.data);\n  Serial.print("Data from n2 via n1: ");\n  Serial.println(n1.next->data);\n}` },
            { name: "test49.ino", content: `// static Global Variable and Function\nstatic int global_counter = 0;\n\nstatic void incrementCounter() {\n  global_counter++;\n}\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  incrementCounter();\n  Serial.print("Counter: ");\n  Serial.println(global_counter);\n  delay(1000);\n}` },
            { name: "test50.ino", content: `// Unsigned Integer Rollover\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  unsigned int i = 4294967295;\n  Serial.print("Initial value: ");\n  Serial.println(i);\n  i++;\n  Serial.print("After increment (rollover): ");\n  Serial.println(i);\n  i = 0;\n  i--;\n  Serial.print("After decrement (rollover): ");\n  Serial.println(i);\n}` },
            { name: "test51.ino", content: `// Complex Function Declarations\nint applyOperation(int (*op)(int, int), int a, int b) {\n  return op(a, b);\n}\n\nint add(int x, int y) {\n  return x + y;\n}\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int result = applyOperation(add, 5, 10);\n  Serial.print("Result of applyOperation: ");\n  Serial.println(result);\n}` },
            { name: "test52.ino", content: `// Bit-Fields in Structs\nstruct MyFlags {\n  unsigned int a : 1;\n  unsigned int b : 1;\n  unsigned int c : 6;\n};\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  struct MyFlags flags;\n  flags.a = 1;\n  flags.b = 0;\n  flags.c = 50;\n\n  Serial.print("Flag a: ");\n  Serial.println(flags.a);\n  Serial.print("Flag c: ");\n  Serial.println(flags.c);\n}` },
            { name: "test53.ino", content: `// extern Keyword\nextern int externalVariable;\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  externalVariable = 10;\n  Serial.print("External variable value: ");\n  Serial.println(externalVariable);\n}\n\nint externalVariable = 5;` },
            { name: "test54.ino", content: `// Ternary Operator with Complex Expressions\nint getBigger(int x, int y) {\n  return (x > y) ? x : y;\n}\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int a = 10, b = 20, c = 30;\n\n  int result = (a < b) ? getBigger(a, c) : (a + b);\n\n  Serial.print("Final result: ");\n  Serial.println(result);\n}` },
            
            // --- NEW: Test for Undeclared Variable ---
            { name: "test55_undeclared_var.ino", content: `// Test case for undeclared variable error\nvoid setup() {\n  int x = 10;\n  x = y; // ERROR: 'y' is not declared\n}\n\nvoid loop() {}` },

            // --- NEW: Tests to diagnose existing problems ---
            { name: "test56_multiple_specifiers.ino", content: `// Test case for multiple type specifiers (const and static)\nstatic const int my_constant = 42;\n\nvoid setup() {}\nvoid loop() {}` },
            { name: "test57_unsigned_long.ino", content: `// Test case for unsigned long\nunsigned long int my_long = 123456789UL;\n\nvoid setup() {}\nvoid loop() {}` },
            { name: "test58_typedef_struct.ino", content: `// Test case for typedef struct with a name\ntypedef struct MyData {\n  int value;\n} my_alias;\n\nvoid setup() {}\nvoid loop() {}` },
            { name: "test59_function_pointer_return.ino", content: `// Test for complex function pointer declaration in return type\nint (*getFuncPtr(void))(int, int) {\n  return 0;\n}\n\nvoid setup() {}\nvoid loop() {}` },
            { name: "test60_function_pointer_param.ino", content: `// Test for function pointer as a parameter\nvoid callFuncPtr(void (*callback)()) {\n  callback();\n}\n\nvoid myFunc() {}\n\nvoid setup() {\n  callFuncPtr(myFunc);\n}\n\nvoid loop() {}` },
            { name: "test61_bitfield_struct.ino", content: `// Test case for bit-field syntax within a struct\nstruct Status {\n  unsigned int flag1 : 1;\n  unsigned int flag2 : 1;\n};\n\nvoid setup() {}\nvoid loop() {}` },
            { name: "test62_preprocessor_undef.ino", content: `// Test preprocessor #undef\n#define MY_MACRO 1\n#undef MY_MACRO\n\nvoid setup() {}\nvoid loop() {}` },
			// Add these to your `testFiles` array in test_harness.html
			{ name: "numeric_test_int_basic.ino", content: `int x = 123;` },
			{ name: "numeric_test_hex_valid.ino", content: `int h1 = 0xAF; int h2 = 0Xbeef;` },
			{ name: "numeric_test_oct_valid.ino", content: `int o1 = 07; int o2 = 0123;` },
			{ name: "numeric_test_bin_valid.ino", content: `int b1 = 0b101; int b2 = 0B11110000;` },
			{ name: "numeric_test_float_basic.ino", content: `float f1 = 3.14; float f2 = .5; float f3 = 1.0e-5;` },
			{ name: "numeric_test_suffix_U.ino", content: `unsigned int u1 = 100U;` },
			{ name: "numeric_test_suffix_L.ino", content: `long l1 = 200L; long l2 = 200ll;` },
			{ name: "numeric_test_suffix_UL.ino", content: `unsigned long ul1 = 300UL; unsigned long ul2 = 300ull;` },
			{ name: "numeric_test_suffix_F.ino", content: `float f4 = 1.23F;` },
			{ name: "numeric_test_suffix_D.ino", content: `double d1 = 4.56D;` },

			// --- Invalid Numeric Literals (Expecting LexerError) ---
			{ name: "numeric_test_invalid_octal.ino", content: `int bad_octal = 018;` }, // Should fail: Invalid digit '8' in octal literal
			{ name: "numeric_test_invalid_hex_empty.ino", content: `int bad_hex = 0x;` },     // Should fail: Invalid hexadecimal literal
			{ name: "numeric_test_invalid_bin_empty.ino", content: `int bad_bin = 0b;` },     // Should fail: Invalid binary literal
			{ name: "numeric_test_num_followed_by_id.ino", content: `int x = 10myVar;` }, // Should fail: Invalid numeric literal: '10m' - cannot start identifier with digit.
			{ name: "numeric_test_float_malformed.ino", content: `float f_mal = 1.2.3;` }, // Should fail: Unrecognized character '.'
			{ name: "numeric_test_float_no_digit.ino", content: `float f_mal = .;` },     // Should fail: Unrecognized character '.' (or similar, depending on exact parsing path)
			// Add these to your 'testFiles' array in test_harness.html

			// Basic Integers
			{ name: "num_valid_int_decimal.ino", content: `int x = 123;` },
			{ name: "num_valid_int_zero.ino", content: `int z = 0;` },

			// Hexadecimal Literals
			{ name: "num_valid_hex_basic.ino", content: `int h1 = 0xAF;` },
			{ name: "num_valid_hex_mixed_case.ino", content: `int h2 = 0Xbeef;` },
			{ name: "num_valid_hex_long.ino", content: `long h3 = 0x12345678;` },

			// Octal Literals (digits 0-7, leading zero)
			{ name: "num_valid_octal_basic.ino", content: `int o1 = 07;` },
			{ name: "num_valid_octal_multiple_digits.ino", content: `int o2 = 0123;` },
			{ name: "num_valid_octal_zero.ino", content: `int o3 = 00;` },

			// Binary Literals
			{ name: "num_valid_bin_basic.ino", content: `int b1 = 0b101;` },
			{ name: "num_valid_bin_long.ino", content: `int b2 = 0B11110000;` },

			// Floating-Point Literals
			{ name: "num_valid_float_basic.ino", content: `float f1 = 3.14;` },
			{ name: "num_valid_float_leading_dot.ino", content: `float f2 = .5;` },
			{ name: "num_valid_float_trailing_dot.ino", content: `float f3 = 1.0;` },
			{ name: "num_valid_float_scientific_e_plus.ino", content: `float f4 = 1.0e+5;` },
			{ name: "num_valid_float_scientific_e_minus.ino", content: `float f5 = 1.2E-3;` },
			{ name: "num_valid_float_scientific_no_sign.ino", content: `float f6 = 2.5e2;` },

			// Integer Suffixes (U, L, LL, and lowercase variants)
			{ name: "num_valid_suffix_U.ino", content: `unsigned int val = 100U;` },
			{ name: "num_valid_suffix_L.ino", content: `long big_val = 200L;` },
			{ name: "num_valid_suffix_UL.ino", content: `unsigned long huge_val = 300UL;` },
			{ name: "num_valid_suffix_LL.ino", content: `long long very_big = 400LL;` },
			{ name: "num_valid_suffix_ULL.ino", content: `unsigned long long max_val = 500ULL;` },
			{ name: "num_valid_suffix_lowercase.ino", content: `int x = 10u; long y = 20l;` },

			// Floating-Point Suffixes (F, D)
			{ name: "num_valid_float_suffix_F.ino", content: `float pi = 3.14159F;` },
			{ name: "num_valid_float_suffix_D.ino", content: `double dbl = 1.23456789D;` },
			// Add these to your 'testFiles' array in test_harness.html

			// Invalid Octal Digits (8 or 9)
			{ name: "num_invalid_octal_digit_8.ino", content: `int invalid_oct = 018;` },   // Expected: Lexer Error: Invalid digit '8' in octal literal
			{ name: "num_invalid_octal_digit_9.ino", content: `int invalid_oct2 = 079;` },  // Expected: Lexer Error: Invalid digit '9'

			// Empty Hexadecimal/Binary Literals
			{ name: "num_invalid_hex_empty.ino", content: `int empty_hex = 0x;` },      // Expected: Lexer Error: Invalid hexadecimal literal
			{ name: "num_invalid_bin_empty.ino", content: `int empty_bin = 0b;` },      // Expected: Lexer Error: Invalid binary literal

			// Numbers Immediately Followed by Identifiers (New check)
			{ name: "num_invalid_num_id.ino", content: `int val = 10myVar;` },    // Expected: Lexer Error: Invalid numeric literal: '10m' - cannot start identifier with digit.
			{ name: "num_invalid_hex_id.ino", content: `int val = 0xAFG;` },     // Expected: Lexer Error: Invalid numeric literal: '0xAFG' - cannot start identifier with digit.
			{ name: "num_invalid_float_id.ino", content: `float f = 1.2eX;` },     // Expected: Lexer Error: Invalid numeric literal: '1.2eX' - cannot start identifier with digit.

			// Malformed Floating-Point Literals (may result in Lexer or Parser errors depending on exact implementation)
			{ name: "num_invalid_float_multiple_dots.ino", content: `float bad_float = 1.2.3;` }, // Expected: Lexer Error (Unrecognized character '.') or Parser Error
			{ name: "num_invalid_float_only_dot.ino", content: `float dot_only = .;` },     // Expected: Lexer Error (Unrecognized character '.') or Parser Error
			// Add these to your 'testFiles' array in test_harness.html

			{ name: "type_test_typedef_basic.ino", content: "typedef int MyInt; MyInt x = 10; void setup() {} void loop() {}" },
			{ name: "type_test_typedef_struct.ino", content: "typedef struct Point { int x; int y; } MyPoint; MyPoint p; void setup() {} void loop() {}" },
			{ name: "type_test_typedef_func_ptr.ino", content: "typedef void (*MyFuncPtr)(int); MyFuncPtr func = 0; void setup() {} void loop() {}" },
			{ name: "type_test_struct_tag_usage.ino", content: "struct Vec { float x; float y; }; struct Vec v; void setup() {} void loop() {}" },
			{ name: "type_test_ambiguous_cast_deref.ino", content: "typedef int MyType; void setup() { int* ptr; MyType cast_result = (MyType) *ptr; } void loop() {}" },
			{ name: "type_test_ambiguous_expr_mult.ino", content: "void setup() { int x = 5; int y = 10; int result = (x) * y; } void loop() {}" },
			// Add these to your 'testFiles' array in test_harness.html

			{ name: "type_test_invalid_var_as_type.ino", content: "int myVar; myVar anotherVar; void setup() {} void loop() {}" },
			{ name: "type_test_undeclared_as_type.ino", content: "NonExistentType obj; void setup() {} void loop() {}" },
        ];

        // Override console.log and console.error to capture output
        const originalConsoleLog = console.log;
        const originalConsoleError = console.error;

        function captureLog(message) {
            fullLog += message + '\n';
        }

        console.log = captureLog;
        console.error = captureLog;

        async function runAllTests() {
            const timestamp = new Date().toLocaleString();
            fullLog += `Interpreter Version: ${INTERPRETER_VERSION}\n`;
            fullLog += `Test run started at: ${timestamp}\n\n`;

            logElement.textContent = 'Running tests... please wait.';

            for (const testFile of testFiles) {
                fullLog += `\n--- Running: ${testFile.name} ---\n`;
                
                try {
                    const rawCode = testFile.content;
                    // --- NEW: Preprocess the code before lexing ---
                    const preprocessor = new Preprocessor(rawCode);
                    const preprocessedCode = preprocessor.process();
                    
                    //const lexer = new Lexer(preprocessedCode); // Pass preprocessed code to lexer
					// NEW: Create Interpreter first to get access to its symbolTable
                    const interpreter = new Interpreter(null); // Pass null for AST initially, will set later
                    const lexer = new Lexer(preprocessedCode, interpreter.symbolTable); // Pass preprocessed code and symbolTable to lexer

                    const parser = new Parser(lexer);
                    const ast = parser.parse();
                    
                    fullLog += `[SUCCESS] Parsed successfully.\n`;
                    fullLog += `--- Abstract Syntax Tree ---\n`;
                    fullLog += prettyPrintAST(ast);
                    fullLog += `--- End of AST ---\n`;

                    // --- NEW: Run Semantic Analysis ---
                    interpreter.tree = ast; // Set the parsed AST to the interpreter
                    fullLog += `\n--- Starting Semantic Analysis ---\n`;
                    //const interpreter = new Interpreter(ast);
                    interpreter.interpret();
                    fullLog += `--- Semantic Analysis Complete ---\n`;

                    
                } catch (error) {
                    // Enhanced error reporting to distinguish between Lexer, Parser, and Semantic errors
                    if (error.name === 'LexerError') {
                        fullLog += `[FAILURE - Lexer] ${error.message}\n`;
                    } else if (error.name === 'ParserError') {
                        fullLog += `[FAILURE - Parser] ${error.message}\n`;
                    } else if (error.name === 'SemanticError') {
                        fullLog += `[FAILURE - Semantic] ${error.message}\n`;
                    } else {
                        fullLog += `[FAILURE - Unknown] ${error.name}: ${error.message}\n`;
                    }
                }
            }

            // Restore original console functions
            console.log = originalConsoleLog;
            console.error = originalConsoleError;
            
            // Display the final log
            logElement.innerHTML = fullLog
                .replace(/\[SUCCESS\]/g, '<span class="success">[SUCCESS]</span>')
                .replace(/\[FAILURE\]/g, '<span class="failure">[FAILURE]</span>');

            console.log("--- TEST HARNESS COMPLETE ---");
            console.log(fullLog); // Also log to the actual browser console for easy copying
        }

        // Run the tests when the page loads
        window.onload = runAllTests;
    </script>

</body>
</html>
