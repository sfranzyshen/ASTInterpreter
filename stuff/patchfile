--- a/interpreter.js
+++ b/interpreter.js
@@ -419,6 +419,7 @@
 class ForNode extends ASTNode { constructor(init, condition, update, body) { super(); this.init = init; this.condition = condition; this.update = update; this.body = body; } }
 class WhileNode extends ASTNode { constructor(condition, body) { super(); this.condition = condition; this.body = body; } }
 class DoWhileNode extends ASTNode { constructor(condition, body) { super(); this.condition = condition; this.body = body; } }
+class StructDefNode extends ASTNode { constructor(members) { super(); this.members = members; } }
 class SwitchNode extends ASTNode { constructor(expression, body) { super(); this.expression = expression; this.body = body; } }
 class CaseNode extends ASTNode { constructor(value, statements) { super(); this.value = value; this.statements = statements; } }
 class DefaultNode extends ASTNode { constructor(statements) { super(); this.statements = statements; } }
@@ -531,17 +532,11 @@
         // This is a list of VarDeclNodes if there are multiple declarators
         const declarations = [];
         const type = this.declaration_specifiers();
-
-        if (this.currentToken.type === TokenType.LBRACE) {
-            this.eat(TokenType.LBRACE);
-            let braceCount = 1;
-            while (braceCount > 0 && this.currentToken.type !== TokenType.EOF) {
-                if (this.currentToken.type === TokenType.LBRACE) braceCount++;
-                if (this.currentToken.type === TokenType.RBRACE) braceCount--;
-                this.eat(this.currentToken.type);
-            }
-            this.eat(TokenType.SEMICOLON);
-            return new NoOpNode(); 
+        
+        // Handle inline struct/union/enum definitions that are part of the type
+        if ((type.value.includes('struct') || type.value.includes('enum')) && this.currentToken.type === TokenType.LBRACE) {
+             const structBody = this.parse_struct_body();
+             type.structBody = structBody; // Attach the parsed body to the type node
         }
 
         if (this.currentToken.type === TokenType.SEMICOLON) {
@@ -588,12 +583,12 @@
                 if (this.currentToken.type === TokenType.LBRACE) {
                     elements.push(this.array_initializer());
                 } else {
-                    elements.push(this.assignment()); // Use assignment() to prevent consuming comma separators
+                    elements.push(this.argument_expression());
                 }
             } while (this.currentToken.type === TokenType.COMMA);
         }
         this.eat(TokenType.RBRACE);
         return new ArrayInitializerNode(elements);
     }
 
+    parse_struct_body() {
+        this.eat(TokenType.LBRACE);
+        const members = [];
+        while(this.currentToken.type !== TokenType.RBRACE && this.currentToken.type !== TokenType.EOF) {
+            // A struct body is a list of member declarations
+            members.push(this.declaration());
+        }
+        this.eat(TokenType.RBRACE);
+        return new StructDefNode(members);
+    }
+
     func_declaration(returnType, declarator) {
         this.eat(TokenType.LPAREN);
         const params = this.parameter_list();
@@ -837,6 +843,13 @@
         return expr;
     }
 
+    // An expression that can appear as a single function argument or array element.
+    // It's everything an expression can be, EXCEPT the top-level comma operator.
+    argument_expression() {
+        return this.assignment();
+    }
+
     expression() { return this.comma_expression(); }
 
     comma_expression() {
@@ -1014,10 +1027,10 @@
                     this.eat(TokenType.LPAREN);
                     const args = [];
                     if (this.currentToken.type !== TokenType.RPAREN) {
-                        args.push(this.assignment()); // Use assignment() to parse args separately
+                        args.push(this.argument_expression());
                         while (this.currentToken.type === TokenType.COMMA) {
                             this.eat(TokenType.COMMA);
-                            args.push(this.assignment());
+                            args.push(this.argument_expression());
                         }
                     }
                     this.eat(TokenType.RPAREN);
